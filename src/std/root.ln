/**
 * The Alan root scope. The functions and types it binds from Rust are either part of the standard
 * library, or are defined in the sibling root.rs file
 **/

/// Type system setup

// Declaration of the types the compiler-time type system is built on
export ctype Type; // Any kind of concrete type
export ctype Generic; // Any type that is a generic type (not yet realized into a concrete type)
export ctype Bound; // A direct reference into the platform language's type system equivalent to a concrete type
export ctype BoundGeneric; // A direct reference into the platform language's generic type system
export ctype Int; // An integer used *to define a type*, like the length of a fixed array
export ctype Float; // A float used to define a type. I have no idea why you'd want this, yet
export ctype Bool; // A bool used to define a type. Heavily used for conditional compilation
export ctype String; // A string used to define a type. Useful for conditional inclusion of files/code
export ctype Group{G}; // A grouping of type statements `()`. Useful to allow for tuples of tuples
export ctype Function{I, O}; // A function type, indicating the input and output of the function
export ctype Tuple{A, B}; // A tuple of two (or more) types in a single compound type
export ctype Field{L, V}; // Labeling a type with a property name. Useful to turn tuples into structs
export ctype Either{A, B}; // An either type, allowing the value to be from *one* of the specified types, kinda like Rust enums
export ctype AnyOf{A, B}; // The AnyOf type is kinda like a Tuple, in that all sub-types are present, but it only *resolves* into one of these types above it. Useful for choosing the "best" integer, or a particular function by name.
export ctype Buffer{T, S}; // A buffer type, a pre-allocated, fixed-length array of the specified type the specified amount
export ctype Array{T}; // An array type, a variable-length array of the specified type the specified amount. This would usually be an stdlib type built in the language itself, but we're just going to re-use the one in the platform language

// The following `ctype`s don't represent data but instead represent transforms that convert into one of the many ctypes above. (I did not expect to need so many of them.)
export ctype Fail{M}; // A special type that if ever encountered at compile time causes the compilation to fail with the specified error message. Useful with conditional types
export ctype Add{A, B}; // Combines the Int or Float types together at compile time into a new Int or Float. Fails if an Int and Float are mixed.
export ctype Sub{A, B}; // Same, but subtracts them
export ctype Mul{A, B}; // Multiplication
export ctype Div{A, B}; // Division
export ctype Mod{A, B}; // Modulus (remainder)
export ctype Pow{A, B}; // Exponentiation/Power
export ctype Min{A, B}; // Minimum value of the two
export ctype Max{A, B}; // Maximum value of the two
export ctype Neg{A}; // Negate the value
export ctype Len{A}; // Returns the length of the input type in terms of the number of elements it contains, which is most useful for Buffers, Tuples, and Either, causes a compiler failure for Arrays, and returns 1 for everything else
export ctype Size{T}; // Returns the size in bytes of the type in question, if possible, causing a compiler failure otherwise.
export ctype FileStr{F}; // Read a file and return a string constant, useful for including large strings from a separate, nearby file, or fails if it doesn't exist
export ctype Env{K}; // Read an environment variable at compile time and return a string of the value. Returns an empty string if the key doesn't exist. Intended to be used with...
export ctype EnvExists{K}; // Returns a boolean if the environment variable key exists at compile time, and...
export ctype If{C, A, B}; // A conditional type, if C is true, resolves to A, otherwise to B. There's also a simpler version...
export ctype If{C, T}; // That expects a two-type tuple and extracts the first tuple type for true and the second for false, which can be bound to symbolic syntax
export ctype Env{K, D}; // Finally, since the majority of the time this is what you'd want, this variant of `Env` takes a default value to use when the key does not exist, making this another conditional type
export ctype And{A, B}; // Performs a boolean or bitwise AND on the inputs, depending on type
export ctype Or{A, B}; // Performs a boolean or bitwise OR on the inputs
export ctype Xor{A, B}; // Performs a boolean or bitwise XOR on the inputs
export ctype Not{B}; // Inverts the boolean provided
export ctype Nand{A, B}; // Performs a boolean or bitwise NAND on the inputs
export ctype Nor{A, B}; // Performs a boolean or bitwise NOR on the inputs
export ctype Xnor{A, B}; // Performs a boolean or bitwise XNOR on the inputs (same as EQ for booleans)
export ctype Eq{A, B}; // Returns true if the two types are the same (or are the same int, float, bool, or string), false otherwise
export ctype Neq{A, B}; // Returns true if the two types are difference
export ctype Lt{A, B}; // Returns true if A is less than B (and are an int or float)
export ctype Lte{A, B}; // Returns true if A is less than or equal to B
export ctype Gt{A, B}; // Returns true if A is greater than B
export ctype Gte{A, B}; // Returns true if A is greater than or equal to B

// Defining derived types
export type void = ();
export type Error binds AlanError;
export type Fallible{T} = Either{T, Error};
export type Maybe{T} = Either{T, ()};
export type Test = Eq{Env{"ALAN_TARGET"}, "test"};
export type Release = Eq{Env{"ALAN_TARGET"}, "release"};
export type Debug = Eq{Env{"ALAN_TARGET"}, "debug"};

// Defining the operators in the type system
export type infix Function as -> precedence 3; // I -> O, where I is the input and O is the output. With Tuples and Fields you can reconstruct arguments for functions.
export type infix Tuple as , precedence 0; // A, B, C, ... The tuple type combines with other tuple types to become a larger tuple type. To have a tuple of tuples, you need to `Group` the inner tuple, eg `(a, b), c`
export type infix Field as : precedence 1; // Foo: Bar, let's you specify a property access label for the type, useful for syntactic sugar on a tuple type and the Either type (eventually).
export type infix Either as | precedence 0; // A | B, the type has a singular value from only one of the types at once. `Result` is just `Either{T, Error}` and `Option` is just `Either{T, ()}` (or `Either{T, void}`, however we want to represent it, also might go with `Fallible` and `Maybe` instead of `Result` and `Option` as those feel more descriptive of what they are.
export type infix AnyOf as & precedence 0; // A & B, which can be passed to a function that takes A or B as necessary.
export type infix Buffer as [ precedence 1; // Technically allows `Foo[3` by itself to be valid syntax, but...
export type postfix Group as ] precedence 1; // Technically not necessary, but allows for `Foo[3]` to do the "right thing" and become a buffer of size 3, with a singular useless Group being wrapped around it (and then unwrapped on type generation). The only "bad" thing here is `Group` gets special behavior, matching the `(...)` syntax, so there's two ways to invoke a Group via symbols.
export type postfix Array as [] precedence 4; // Allows `Foo[]` to do the right thing
export type postfix Maybe as ? precedence 4; // Allows `Foo?` for nullable types. Should this have a precedence of 5?
export type postfix Fallible as ! precedence 4; // Allows `Foo!` for fallible types. Same question on the precedence.
export type infix Add as + precedence 2;
export type infix Sub as - precedence 2;
export type infix Mul as * precedence 3;
export type infix Div as / precedence 3;
export type infix Mod as % precedence 3;
export type infix Pow as ** precedence 4;
export type infix If as ?? precedence 1; // C puts this kind of thing as a very high precedence. I'm not sure if I want to follow it. I feel like that would force grouping parens everywhere.
export type infix And as && precedence 3;
export type infix Or as || precedence 2;
export type infix Xor as ^ precedence 2;
export type prefix Not as ! precedence 4; // TODO: Do we want `!` to mean `Not` or `Result` depending on where it's placed syntactically? Seems easily ambiguous
export type infix Nand as !& precedence 3;
export type infix Nor as !| precedence 2;
export type infix Xnor as !^ precedence 2;
export type infix Eq as == precedence 1;
export type infix Neq as != precedence 1;
export type infix Lt as < precedence 1;
export type infix Lte as <= precedence 1;
export type infix Gt as > precedence 1;
export type infix Gte as >= precedence 1;

// Binding the integer types
export type i8 binds i8;
export type i16 binds i16;
export type i32 binds i32;
export type i64 binds i64;
export type u8 binds u8;
export type u16 binds u16;
export type u32 binds u32;
export type u64 binds u64;

// Binding the float types
export type f32 binds f32;
export type f64 binds f64;

// Binding the string types
export type string binds String;

// Binding the boolean types
export type bool binds bool;

// Binding the exit code type
export type ExitCode binds std::process::ExitCode;

// Binding the time types
export type Instant binds std::time::Instant;
export type Duration binds std::time::Duration;

// Binding the uuid type
export type uuid binds uuid::Uuid;

// Binding the Dict and Set types
export type Dict{K, V} binds OrderedHashMap<K, V>;
export type Set{V} binds std::collections::HashSet<V>;

/// Functions for (potentially) every type
export fn clone{T}(v: T) -> T binds clone;
// TODO: The "proper" way to hash this consistently for all types is to decompose the input type
// into the various primitive types of Alan and then have hashing rules for each of them, which
// may themselves decompose, etc. This might be doable in Alan code on top of specialized hashing
// functions in Rust (as partially implemented here) or it might be better done as a special `hash`
// function created by the compiler for the specific type *if* ever actually used, walking the
// CType tree to determine the correct code to run. In either case, this is "good enough" for now.
export fn hash{T}(v: Array{T}) -> i64 binds hasharray;
export fn hash(v: string) -> i64 binds hashstring;
export fn hash{T}(v: T) -> i64 binds hash;
export fn void{T}(v: T) -> void {}
export fn void() -> void {}
export fn store{T}(a: T, b: T) -> T binds storeswap;

/// Fallible, Maybe, and Either functions
export fn getOr{T}(v: Maybe{T}, d: T) -> T binds maybe_get_or;
export fn getOr{T}(v: Fallible{T}, d: T) -> T binds fallible_get_or;
export fn getOr{T, U}(v: U, d: T) -> T = {T}(v).getOr(d);
export fn none{T}() -> Maybe{T} binds maybe_none;
export fn error{T}(m: string) -> Fallible{T} binds fallible_error;
export fn exists{T}(v: Maybe{T}) -> bool binds maybe_exists;

/// Signed Integer-related functions and function bindings
export fn i8(i: i8) -> i8 = i;
export fn i8(i: i16) -> i8 binds i16toi8;
export fn i8(i: i32) -> i8 binds i32toi8;
export fn i8(i: i64) -> i8 binds i64toi8;
export fn i8(i: u8) -> i8 binds u8toi8;
export fn i8(i: u16) -> i8 binds u16toi8;
export fn i8(i: u32) -> i8 binds u32toi8;
export fn i8(i: u64) -> i8 binds u64toi8;
export fn i8(f: f32) -> i8 binds f32toi8;
export fn i8(f: f64) -> i8 binds f64toi8;
export fn i8(s: string) -> Fallible{i8} binds stringtoi8;
export fn add(a: i8, b: i8) -> i8 binds addi8;
export fn sub(a: i8, b: i8) -> i8 binds subi8;
export fn mul(a: i8, b: i8) -> i8 binds muli8;
export fn div(a: i8, b: i8) -> i8 binds divi8;
export fn mod(a: i8, b: i8) -> i8 binds modi8;
export fn pow(a: i8, b: i8) -> i8 binds powi8;
export fn min(a: i8, b: i8) -> i8 binds mini8;
export fn max(a: i8, b: i8) -> i8 binds maxi8;
export fn neg(a: i8) -> i8 binds negi8;
export fn and(a: i8, b: i8) -> i8 binds andi8;
export fn or(a: i8, b: i8) -> i8 binds ori8;
export fn xor(a: i8, b: i8) -> i8 binds xori8;
export fn not(a: i8) -> i8 binds noti8;
export fn nand(a: i8, b: i8) -> i8 binds nandi8;
export fn nor(a: i8, b: i8) -> i8 binds nori8;
export fn xnor(a: i8, b: i8) -> i8 binds xnori8;
export fn eq(a: i8, b: i8) -> bool binds eqi8;
export fn neq(a: i8, b: i8) -> bool binds neqi8;
export fn lt(a: i8, b: i8) -> bool binds lti8;
export fn lte(a: i8, b: i8) -> bool binds ltei8;
export fn gt(a: i8, b: i8) -> bool binds gti8;
export fn gte(a: i8, b: i8) -> bool binds gtei8;
export fn shl(a: i8, b: i8) -> i8 binds shli8;
export fn shr(a: i8, b: i8) -> i8 binds shri8;
export fn wrl(a: i8, b: i8) -> i8 binds wrli8;
export fn wrr(a: i8, b: i8) -> i8 binds wrri8;

export fn i16(i: i8) -> i16 binds i8toi16;
export fn i16(i: i16) -> i16 = i;
export fn i16(i: i32) -> i16 binds i32toi16;
export fn i16(i: i64) -> i16 binds i64toi16;
export fn i16(i: u8) -> i16 binds u8toi16;
export fn i16(i: u16) -> i16 binds u16toi16;
export fn i16(i: u32) -> i16 binds u32toi16;
export fn i16(i: u64) -> i16 binds u64toi16;
export fn i16(f: f32) -> i16 binds f32toi16;
export fn i16(f: f64) -> i16 binds f64toi16;
export fn i16(s: string) -> Fallible{i16} binds stringtoi16;
export fn add(a: i16, b: i16) -> i16 binds addi16;
export fn sub(a: i16, b: i16) -> i16 binds subi16;
export fn mul(a: i16, b: i16) -> i16 binds muli16;
export fn div(a: i16, b: i16) -> i16 binds divi16;
export fn mod(a: i16, b: i16) -> i16 binds modi16;
export fn pow(a: i16, b: i16) -> i16 binds powi16;
export fn min(a: i16, b: i16) -> i16 binds mini16;
export fn max(a: i16, b: i16) -> i16 binds maxi16;
export fn neg(a: i16) -> i16 binds negi16;
export fn and(a: i16, b: i16) -> i16 binds andi16;
export fn or(a: i16, b: i16) -> i16 binds ori16;
export fn xor(a: i16, b: i16) -> i16 binds xori16;
export fn not(a: i16) -> i16 binds noti16;
export fn nand(a: i16, b: i16) -> i16 binds nandi16;
export fn nor(a: i16, b: i16) -> i16 binds nori16;
export fn xnor(a: i16, b: i16) -> i16 binds xnori16;
export fn eq(a: i16, b: i16) -> bool binds eqi16;
export fn neq(a: i16, b: i16) -> bool binds neqi16;
export fn lt(a: i16, b: i16) -> bool binds lti16;
export fn lte(a: i16, b: i16) -> bool binds ltei16;
export fn gt(a: i16, b: i16) -> bool binds gti16;
export fn gte(a: i16, b: i16) -> bool binds gtei16;
export fn shl(a: i16, b: i16) -> i16 binds shli16;
export fn shr(a: i16, b: i16) -> i16 binds shri16;
export fn wrl(a: i16, b: i16) -> i16 binds wrli16;
export fn wrr(a: i16, b: i16) -> i16 binds wrri16;

export fn i32(i: i8) -> i32 binds i8toi32;
export fn i32(i: i16) -> i32 binds i16toi32;
export fn i32(i: i32) -> i32 = i;
export fn i32(i: i64) -> i32 binds i64toi32;
export fn i32(i: u8) -> i32 binds u8toi32;
export fn i32(i: u16) -> i32 binds u16toi32;
export fn i32(i: u32) -> i32 binds u32toi32;
export fn i32(i: u64) -> i32 binds u64toi32;
export fn i32(f: f32) -> i32 binds f32toi32;
export fn i32(f: f64) -> i32 binds f64toi32;
export fn i32(s: string) -> Fallible{i32} binds stringtoi32;
export fn add(a: i32, b: i32) -> i32 binds addi32;
export fn sub(a: i32, b: i32) -> i32 binds subi32;
export fn mul(a: i32, b: i32) -> i32 binds muli32;
export fn div(a: i32, b: i32) -> i32 binds divi32;
export fn mod(a: i32, b: i32) -> i32 binds modi32;
export fn pow(a: i32, b: i32) -> i32 binds powi32;
export fn min(a: i32, b: i32) -> i32 binds mini32;
export fn max(a: i32, b: i32) -> i32 binds maxi32;
export fn neg(a: i32) -> i32 binds negi32;
export fn and(a: i32, b: i32) -> i32 binds andi32;
export fn or(a: i32, b: i32) -> i32 binds ori32;
export fn xor(a: i32, b: i32) -> i32 binds xori32;
export fn not(a: i32) -> i32 binds noti32;
export fn nand(a: i32, b: i32) -> i32 binds nandi32;
export fn nor(a: i32, b: i32) -> i32 binds nori32;
export fn xnor(a: i32, b: i32) -> i32 binds xnori32;
export fn eq(a: i32, b: i32) -> bool binds eqi32;
export fn neq(a: i32, b: i32) -> bool binds neqi32;
export fn lt(a: i32, b: i32) -> bool binds lti32;
export fn lte(a: i32, b: i32) -> bool binds ltei32;
export fn gt(a: i32, b: i32) -> bool binds gti32;
export fn gte(a: i32, b: i32) -> bool binds gtei32;
export fn shl(a: i32, b: i32) -> i32 binds shli32;
export fn shr(a: i32, b: i32) -> i32 binds shri32;
export fn wrl(a: i32, b: i32) -> i32 binds wrli32;
export fn wrr(a: i32, b: i32) -> i32 binds wrri32;

export fn i64(i: i8) -> i64 binds i8toi64;
export fn i64(i: i16) -> i64 binds i16toi64;
export fn i64(i: i32) -> i64 binds i32toi64;
export fn i64(i: i64) -> i64 = i;
export fn i64(i: u8) -> i64 binds u8toi64;
export fn i64(i: u16) -> i64 binds u16toi64;
export fn i64(i: u32) -> i64 binds u32toi64;
export fn i64(i: u64) -> i64 binds u64toi64;
export fn i64(f: f32) -> i64 binds f32toi64;
export fn i64(f: f64) -> i64 binds f64toi64;
export fn i64(s: string) -> Fallible{i64} binds stringtoi64;
export fn add(a: i64, b: i64) -> i64 binds addi64;
export fn sub(a: i64, b: i64) -> i64 binds subi64;
export fn mul(a: i64, b: i64) -> i64 binds muli64;
export fn div(a: i64, b: i64) -> i64 binds divi64;
export fn mod(a: i64, b: i64) -> i64 binds modi64;
export fn pow(a: i64, b: i64) -> i64 binds powi64;
export fn min(a: i64, b: i64) -> i64 binds mini64;
export fn max(a: i64, b: i64) -> i64 binds maxi64;
export fn neg(a: i64) -> i64 binds negi64;
export fn and(a: i64, b: i64) -> i64 binds andi64;
export fn or(a: i64, b: i64) -> i64 binds ori64;
export fn xor(a: i64, b: i64) -> i64 binds xori64;
export fn not(a: i64) -> i64 binds noti64;
export fn nand(a: i64, b: i64) -> i64 binds nandi64;
export fn nor(a: i64, b: i64) -> i64 binds nori64;
export fn xnor(a: i64, b: i64) -> i64 binds xnori64;
export fn eq(a: i64, b: i64) -> bool binds eqi64;
export fn neq(a: i64, b: i64) -> bool binds neqi64;
export fn lt(a: i64, b: i64) -> bool binds lti64;
export fn lte(a: i64, b: i64) -> bool binds ltei64;
export fn gt(a: i64, b: i64) -> bool binds gti64;
export fn gte(a: i64, b: i64) -> bool binds gtei64;
export fn shl(a: i64, b: i64) -> i64 binds shli64;
export fn shr(a: i64, b: i64) -> i64 binds shri64;
export fn wrl(a: i64, b: i64) -> i64 binds wrli64;
export fn wrr(a: i64, b: i64) -> i64 binds wrri64;

/// Unsigned Integer-related functions and function bindings
export fn u8(i: i8) -> u8 binds i8tou8;
export fn u8(i: i16) -> u8 binds i16tou8;
export fn u8(i: i32) -> u8 binds i32tou8;
export fn u8(i: i64) -> u8 binds i64tou8;
export fn u8(i: u8) -> u8 = i;
export fn u8(i: u16) -> u8 binds u16tou8;
export fn u8(i: u32) -> u8 binds u32tou8;
export fn u8(i: u64) -> u8 binds u64tou8;
export fn u8(f: f32) -> u8 binds f32tou8;
export fn u8(f: f64) -> u8 binds f64tou8;
export fn u8(s: string) -> Fallible{u8} binds stringtou8;
export fn add(a: u8, b: u8) -> u8 binds addu8;
export fn sub(a: u8, b: u8) -> u8 binds subu8;
export fn mul(a: u8, b: u8) -> u8 binds mulu8;
export fn div(a: u8, b: u8) -> u8 binds divu8;
export fn mod(a: u8, b: u8) -> u8 binds modu8;
export fn pow(a: u8, b: u8) -> u8 binds powu8;
export fn min(a: u8, b: u8) -> u8 binds minu8;
export fn max(a: u8, b: u8) -> u8 binds maxu8;
export fn and(a: u8, b: u8) -> u8 binds andu8;
export fn or(a: u8, b: u8) -> u8 binds oru8;
export fn xor(a: u8, b: u8) -> u8 binds xoru8;
export fn not(a: u8) -> u8 binds notu8;
export fn nand(a: u8, b: u8) -> u8 binds nandu8;
export fn nor(a: u8, b: u8) -> u8 binds noru8;
export fn xnor(a: u8, b: u8) -> u8 binds xnoru8;
export fn eq(a: u8, b: u8) -> bool binds equ8;
export fn neq(a: u8, b: u8) -> bool binds nequ8;
export fn lt(a: u8, b: u8) -> bool binds ltu8;
export fn lte(a: u8, b: u8) -> bool binds lteu8;
export fn gt(a: u8, b: u8) -> bool binds gtu8;
export fn gte(a: u8, b: u8) -> bool binds gteu8;
export fn shl(a: u8, b: u8) -> u8 binds shlu8;
export fn shr(a: u8, b: u8) -> u8 binds shru8;
export fn wrl(a: u8, b: u8) -> u8 binds wrlu8;
export fn wrr(a: u8, b: u8) -> u8 binds wrru8;

export fn u16(i: i8) -> u16 binds i8tou16;
export fn u16(i: i16) -> u16 binds i16tou16;
export fn u16(i: i32) -> u16 binds i32tou16;
export fn u16(i: i64) -> u16 binds i64tou16;
export fn u16(i: u8) -> u16 binds u8tou16;
export fn u16(i: u16) -> u16 = i;
export fn u16(i: u32) -> u16 binds u32tou16;
export fn u16(i: u64) -> u16 binds u64tou16;
export fn u16(f: f32) -> u16 binds f32tou16;
export fn u16(f: f64) -> u16 binds f64tou16;
export fn u16(s: string) -> Fallible{u16} binds stringtou16;
export fn add(a: u16, b: u16) -> u16 binds addu16;
export fn sub(a: u16, b: u16) -> u16 binds subu16;
export fn mul(a: u16, b: u16) -> u16 binds mulu16;
export fn div(a: u16, b: u16) -> u16 binds divu16;
export fn mod(a: u16, b: u16) -> u16 binds modu16;
export fn pow(a: u16, b: u16) -> u16 binds powu16;
export fn min(a: u16, b: u16) -> u16 binds minu16;
export fn max(a: u16, b: u16) -> u16 binds maxu16;
export fn and(a: u16, b: u16) -> u16 binds andu16;
export fn or(a: u16, b: u16) -> u16 binds oru16;
export fn xor(a: u16, b: u16) -> u16 binds xoru16;
export fn not(a: u16) -> u16 binds notu16;
export fn nand(a: u16, b: u16) -> u16 binds nandu16;
export fn nor(a: u16, b: u16) -> u16 binds noru16;
export fn xnor(a: u16, b: u16) -> u16 binds xnoru16;
export fn eq(a: u16, b: u16) -> bool binds equ16;
export fn neq(a: u16, b: u16) -> bool binds nequ16;
export fn lt(a: u16, b: u16) -> bool binds ltu16;
export fn lte(a: u16, b: u16) -> bool binds lteu16;
export fn gt(a: u16, b: u16) -> bool binds gtu16;
export fn gte(a: u16, b: u16) -> bool binds gteu16;
export fn shl(a: u16, b: u16) -> u16 binds shlu16;
export fn shr(a: u16, b: u16) -> u16 binds shru16;
export fn wrl(a: u16, b: u16) -> u16 binds wrlu16;
export fn wrr(a: u16, b: u16) -> u16 binds wrru16;

export fn u32(i: i8) -> u32 binds i8tou32;
export fn u32(i: i16) -> u32 binds i16tou32;
export fn u32(i: i32) -> u32 binds i32tou32;
export fn u32(i: i64) -> u32 binds i64tou32;
export fn u32(i: u8) -> u32 binds u8tou32;
export fn u32(i: u16) -> u32 binds u16tou32;
export fn u32(i: u32) -> u32 = i;
export fn u32(i: u64) -> u32 binds u64tou32;
export fn u32(f: f32) -> u32 binds f32tou32;
export fn u32(f: f64) -> u32 binds f64tou32;
export fn u32(s: string) -> Fallible{u32} binds stringtou32;
export fn add(a: u32, b: u32) -> u32 binds addu32;
export fn sub(a: u32, b: u32) -> u32 binds subu32;
export fn mul(a: u32, b: u32) -> u32 binds mulu32;
export fn div(a: u32, b: u32) -> u32 binds divu32;
export fn mod(a: u32, b: u32) -> u32 binds modu32;
export fn pow(a: u32, b: u32) -> u32 binds powu32;
export fn min(a: u32, b: u32) -> u32 binds minu32;
export fn max(a: u32, b: u32) -> u32 binds maxu32;
export fn and(a: u32, b: u32) -> u32 binds andu32;
export fn or(a: u32, b: u32) -> u32 binds oru32;
export fn xor(a: u32, b: u32) -> u32 binds xoru32;
export fn not(a: u32) -> u32 binds notu32;
export fn nand(a: u32, b: u32) -> u32 binds nandu32;
export fn nor(a: u32, b: u32) -> u32 binds noru32;
export fn xnor(a: u32, b: u32) -> u32 binds xnoru32;
export fn eq(a: u32, b: u32) -> bool binds equ32;
export fn neq(a: u32, b: u32) -> bool binds nequ32;
export fn lt(a: u32, b: u32) -> bool binds ltu32;
export fn lte(a: u32, b: u32) -> bool binds lteu32;
export fn gt(a: u32, b: u32) -> bool binds gtu32;
export fn gte(a: u32, b: u32) -> bool binds gteu32;
export fn shl(a: u32, b: u32) -> u32 binds shlu32;
export fn shr(a: u32, b: u32) -> u32 binds shru32;
export fn wrl(a: u32, b: u32) -> u32 binds wrlu32;
export fn wrr(a: u32, b: u32) -> u32 binds wrru32;

export fn u64(i: i8) -> u64 binds i8tou64;
export fn u64(i: i16) -> u64 binds i16tou64;
export fn u64(i: i32) -> u64 binds i32tou64;
export fn u64(i: i64) -> u64 binds i64tou64;
export fn u64(i: u8) -> u64 binds u8tou64;
export fn u64(i: u16) -> u64 binds u16tou64;
export fn u64(i: u32) -> u64 binds u32tou64;
export fn u64(i: u64) -> u64 = i;
export fn u64(f: f32) -> u64 binds f32tou64;
export fn u64(f: f64) -> u64 binds f64tou64;
export fn u64(s: string) -> Fallible{u64} binds stringtou64;
export fn add(a: u64, b: u64) -> u64 binds addu64;
export fn sub(a: u64, b: u64) -> u64 binds subu64;
export fn mul(a: u64, b: u64) -> u64 binds mulu64;
export fn div(a: u64, b: u64) -> u64 binds divu64;
export fn mod(a: u64, b: u64) -> u64 binds modu64;
export fn pow(a: u64, b: u64) -> u64 binds powu64;
export fn min(a: u64, b: u64) -> u64 binds minu64;
export fn max(a: u64, b: u64) -> u64 binds maxu64;
export fn and(a: u64, b: u64) -> u64 binds andu64;
export fn or(a: u64, b: u64) -> u64 binds oru64;
export fn xor(a: u64, b: u64) -> u64 binds xoru64;
export fn not(a: u64) -> u64 binds notu64;
export fn nand(a: u64, b: u64) -> u64 binds nandu64;
export fn nor(a: u64, b: u64) -> u64 binds noru64;
export fn xnor(a: u64, b: u64) -> u64 binds xnoru64;
export fn eq(a: u64, b: u64) -> bool binds equ64;
export fn neq(a: u64, b: u64) -> bool binds nequ64;
export fn lt(a: u64, b: u64) -> bool binds ltu64;
export fn lte(a: u64, b: u64) -> bool binds lteu64;
export fn gt(a: u64, b: u64) -> bool binds gtu64;
export fn gte(a: u64, b: u64) -> bool binds gteu64;
export fn shl(a: u64, b: u64) -> u64 binds shlu64;
export fn shr(a: u64, b: u64) -> u64 binds shru64;
export fn wrl(a: u64, b: u64) -> u64 binds wrlu64;
export fn wrr(a: u64, b: u64) -> u64 binds wrru64;

/// Float-related functions and function bindings
export fn f32(i: i8) -> f32 binds i8tof32;
export fn f32(i: i16) -> f32 binds i16tof32;
export fn f32(i: i32) -> f32 binds i32tof32;
export fn f32(i: i64) -> f32 binds i64tof32;
export fn f32(u: u8) -> f32 binds u8tof32;
export fn f32(u: u16) -> f32 binds u16tof32;
export fn f32(u: u32) -> f32 binds u32tof32;
export fn f32(u: u64) -> f32 binds u64tof32;
export fn f32(f: f32) -> f32 = f;
export fn f32(f: f64) -> f32 binds f64tof32;
export fn f32(s: string) -> Fallible{f32} binds stringtof32;
export fn add(a: f32, b: f32) -> f32 binds addf32;
export fn sub(a: f32, b: f32) -> f32 binds subf32;
export fn mul(a: f32, b: f32) -> f32 binds mulf32;
export fn div(a: f32, b: f32) -> f32 binds divf32;
export fn sqrt(f: f32) -> f32 binds sqrtf32;
export fn pow(a: f32, b: f32) -> f32 binds powf32;
export fn min(a: f32, b: f32) -> f32 binds minf32;
export fn max(a: f32, b: f32) -> f32 binds maxf32;
export fn neg(a: f32) -> f32 binds negf32;
export fn neg(a: Fallible{f32}) -> Fallible{f32} binds negf32_result;
export fn eq(a: f32, b: f32) -> bool binds eqf32;
export fn neq(a: f32, b: f32) -> bool binds neqf32;
export fn lt(a: f32, b: f32) -> bool binds ltf32;
export fn lte(a: f32, b: f32) -> bool binds ltef32;
export fn gt(a: f32, b: f32) -> bool binds gtf32;
export fn gte(a: f32, b: f32) -> bool binds gtef32;

export fn f64(i: i8) -> f64 binds i8tof64;
export fn f64(i: i16) -> f64 binds i16tof64;
export fn f64(i: i32) -> f64 binds i32tof64;
export fn f64(i: i64) -> f64 binds i64tof64;
export fn f64(u: u8) -> f64 binds u8tof64;
export fn f64(u: u16) -> f64 binds u16tof64;
export fn f64(u: u32) -> f64 binds u32tof64;
export fn f64(u: u64) -> f64 binds u64tof64;
export fn f64(f: f32) -> f64 binds f32tof64;
export fn f64(f: f64) -> f64 = f;
export fn f64(s: string) -> Fallible{f64} binds stringtof64;
export fn add(a: f64, b: f64) -> f64 binds addf64;
export fn sub(a: f64, b: f64) -> f64 binds subf64;
export fn mul(a: f64, b: f64) -> f64 binds mulf64;
export fn div(a: f64, b: f64) -> f64 binds divf64;
export fn sqrt(f: f64) -> f64 binds sqrtf64;
export fn pow(a: f64, b: f64) -> f64 binds powf64;
export fn min(a: f64, b: f64) -> f64 binds minf64;
export fn max(a: f64, b: f64) -> f64 binds maxf64;
export fn neg(a: f64) -> f64 binds negf64;
export fn eq(a: f64, b: f64) -> bool binds eqf64;
export fn neq(a: f64, b: f64) -> bool binds neqf64;
export fn lt(a: f64, b: f64) -> bool binds ltf64;
export fn lte(a: f64, b: f64) -> bool binds ltef64;
export fn gt(a: f64, b: f64) -> bool binds gtf64;
export fn gte(a: f64, b: f64) -> bool binds gtef64;

/// String related bindings
export fn string(i: i8) -> string binds i8tostring;
export fn string(i: i16) -> string binds i16tostring;
export fn string(i: i32) -> string binds i32tostring;
export fn string(i: i64) -> string binds i64tostring;
export fn string(i: u8) -> string binds u8tostring;
export fn string(i: u16) -> string binds u16tostring;
export fn string(i: u32) -> string binds u32tostring;
export fn string(i: u64) -> string binds u64tostring;
export fn string(f: f32) -> string binds f32tostring;
export fn string(f: f64) -> string binds f64tostring;
export fn string(b: bool) -> string binds booltostring;
export fn string(s: string) -> string = s;
export fn concat(a: string, b: string) -> string binds concatstring;
export fn repeat(a: string, n: i64) -> string binds repeatstring;
export fn replace(s: string, o: string, n: string) -> string binds replacestring;
export fn split(a: string, b: string) -> string[] binds splitstring;
export fn len(a: string) -> i64 binds lenstring;
export fn get(a: string, i: i64) -> Fallible{string} binds getstring;
export fn trim(a: string) -> string binds trimstring;
export fn index(a: string, b: string) -> Fallible{i64} binds indexstring;
export fn min(a: string, b: string) -> string binds minstring;
export fn max(a: string, b: string) -> string binds maxstring;
export fn eq(a: string, b: string) -> bool binds eqstring;
export fn neq(a: string, b: string) -> bool binds neqstring;
export fn lt(a: string, b: string) -> bool binds ltstring;
export fn lte(a: string, b: string) -> bool binds ltestring;
export fn gt(a: string, b: string) -> bool binds gtstring;
export fn gte(a: string, b: string) -> bool binds gtestring;
export fn join(a: Array{string}, s: string) -> string binds joinstring;
export fn join{S}(a: Buffer{string, S}, s: string) -> string binds bufferjoinstring;

/// Boolean related bindings
export fn bool(i: i8) -> bool binds i8tobool;
export fn bool(i: i16) -> bool binds i16tobool;
export fn bool(i: i32) -> bool binds i32tobool;
export fn bool(i: i64) -> bool binds i64tobool;
export fn bool(i: u8) -> bool binds u8tobool;
export fn bool(i: u16) -> bool binds u16tobool;
export fn bool(i: u32) -> bool binds u32tobool;
export fn bool(i: u64) -> bool binds u64tobool;
export fn bool(f: f32) -> bool binds f32tobool;
export fn bool(f: f64) -> bool binds f64tobool;
export fn bool(s: string) -> bool binds stringtobool;
export fn bool(b: bool) -> bool = b;
export fn and(a: bool, b: bool) -> bool binds andbool;
export fn or(a: bool, b: bool) -> bool binds orbool;
export fn xor(a: bool, b: bool) -> bool binds xorbool;
export fn not(a: bool) -> bool binds notbool;
export fn nand(a: bool, b: bool) -> bool binds nandbool;
export fn nor(a: bool, b: bool) -> bool binds norbool;
export fn xnor(a: bool, b: bool) -> bool binds xnorbool;
export fn eq(a: bool, b: bool) -> bool binds eqbool;
export fn neq(a: bool, b: bool) -> bool binds neqbool;
export fn cond{T}(c: bool, t: () -> T, f: () -> T) -> T binds condbool;
export fn cond{T}(c: bool, t: () -> T) -> Maybe{T} = cond(c, fn = Maybe{T}(t()), fn = none{T}());

/// Array related bindings
export fn get{T}(a: T[], i: i64) -> Maybe{T} binds getarray;
export fn len{T}(a: T[]) -> i64 binds lenarray;
export fn push{T}(a: Array{T}, v: T) -> () binds pusharray;
export fn pop{T}(a: T[]) -> Maybe{T} binds poparray;
export fn map{T, U}(a: Array{T}, m: T -> U) -> Array{U} binds map_onearg;
export fn map{T, U}(a: Array{T}, m: (T, i64) -> U) -> Array{U} binds map_twoarg;
export fn parmap{T, U}(a: Array{T}, m: T -> U) -> Array{U} binds parmap_onearg;
export fn filter{T}(a: Array{T}, f: T -> bool) -> Array{T} binds filter_onearg;
export fn filter{T}(a: Array{T}, f: (T, i64) -> bool) -> Array{T} binds filter_twoarg;
export fn reduce{T}(a: Array{T}, f: (T, T) -> T) -> Maybe{T} binds reduce_sametype;
export fn reduce{T, U}(a: Array{T}, i: U, f: (U, T) -> U) -> U binds reduce_difftype;
export fn concat{T}(a: Array{T}, b: Array{T}) -> Array{T} binds concat;
export fn filled{T}(v: T, l: i64) -> Array{T} binds filled;
export fn has{T}(a: Array{T}, v: T) -> bool binds hasarray;
export fn has{T}(a: Array{T}, f: (T) -> bool) -> bool binds hasfnarray;
export fn find{T}(a: Array{T}, f: (T) -> bool) -> Maybe{T} binds findarray;
export fn every{T}(a: Array{T}, f: (T) -> bool) -> bool binds everyarray;
export fn repeat{T}(a: Array{T}, c: i64) -> Array{T} binds repeatarray;
export fn store{T}(a: Array{T}, i: i64, v: T) -> Fallible{void} binds storearray;
export fn delete{T}(a: Array{T}, i: i64) -> Fallible{T} binds deletearray;

/// Buffer related bindings
export fn get{T, S}(b: T[S], i: i64) -> Maybe{T} binds getbuffer;
export fn len{T, S}(T[S]) -> i64 = {S}();
export fn map{T, S, U}(a: Buffer{T, S}, m: T -> U) -> Buffer{U, S} binds mapbuffer_onearg;
export fn map{T, S, U}(a: Buffer{T, S}, m: (T, i64) -> U) -> Buffer{U, S} binds mapbuffer_twoarg;
export fn reduce{T, S}(a: Buffer{T, S}, f: (T, T) -> T) -> Maybe{T} binds reducebuffer_sametype;
export fn reduce{T, S, U}(a: Buffer{T, S}, i: U, f: (U, T) -> U) -> U binds reducebuffer_difftype;
export fn has{T, S}(a: Buffer{T, S}, v: T) -> bool binds hasbuffer;
export fn has{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> bool binds hasfnbuffer;
export fn find{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> Maybe{T} binds findbuffer;
export fn every{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> bool binds everybuffer;
fn concatInner{T, S, N}(o: Buffer{T, S + N}, a: Buffer{T, S}, b: Buffer{T, N}) -> void binds concatbuffer;
export fn concat{T, S, N}(a: Buffer{T, S}, b: Buffer{T, N}) -> Buffer{T, S + N} {
  // I can't bind directly into Rust because Rust can't add const integer type parameters together.
  // It's *theoretically* possible to generate a new Rust function in each case with the required
  // sizes, but it will be really difficult, so I'm implementing this for now with the intent to
  // eventually replace it.
  let o = {T[S + N]}(a[0].getOrExit);
  concatInner(o, a, b);
  return o;
}
// TODO: Be able to resolve explicit integer constant values as the integer type so it can be
// grabbed by the type inference system. For now, repeat for buffers outputs an array, instead.
export fn repeat{T, S}(b: Buffer{T, S}, c: i64) -> Array{T} binds repeatbuffertoarray;
export fn store{T, S}(b: Buffer{T, S}, i: i64, v: T) -> Fallible{T} binds storebuffer;

/// Dictionary-related bindings
export fn Dict{K, V}() -> Dict{K, V} binds newdict;
export fn Dict{K, V}(k: K, v: V) -> Dict{K, V} {
  let out = Dict{K, V}();
  out.store(k, v);
  return out;
}
export fn Dict{K, V}(a: Array{(K, V)}) -> Dict{K, V} = a.reduce(Dict{K, V}(), fn (d: Dict{K, V}, v: (K, V)) -> Dict{K, V} {
  d.store(v.0, v.1);
  return d;
});
export fn store{K, V}(d: Dict{K, V}, k: K, v: V) -> void binds storedict;
export fn get{K, V}(d: Dict{K, V}, k: K) -> Maybe{V} binds getdict;
export fn has{K, V}(d: Dict{K, V}, k: K) -> bool binds hasdict;
export fn len{K, V}(d: Dict{K, V}) -> i64 binds lendict;
export fn keys{K, V}(d: Dict{K, V}) -> Array{K} binds keysdict;
export fn vals{K, V}(d: Dict{K, V}) -> Array{V} binds valsdict;
export fn Array{K, V}(d: Dict{K, V}) -> Array{(K, V)} binds arraydict;
export fn concat{K, V}(a: Dict{K, V}, b: Dict{K, V}) -> Dict{K, V} binds concatdict;

/// Set-related bindings
export fn Set{V}() -> Set{V} binds newset;
export fn Set{V}(a: Array{V}) -> Set{V} = a.reduce(Set{V}(), fn (s: Set{V}, v: V) -> Set{V} {
  s.store(v);
  return s;
});
export fn Set{V}(v: V) -> Set{V} {
  let out = Set{V}();
  out.store(v);
  return out;
}
export fn store{V}(s: Set{V}, v: V) -> void binds storeset;
export fn has{V}(s: Set{V}, v: V) -> bool binds hasset;
export fn len{V}(s: Set{V}) -> i64 binds lenset;
export fn Array{V}(s: Set{V}) -> Array{V} binds arrayset;
export fn union{V}(a: Set{V}, b: Set{V}) -> Set{V} binds unionset;
export fn or{V}(a: Set{V}, b: Set{V}) -> Set{V} = union(a, b);
export fn intersect{V}(a: Set{V}, b: Set{V}) -> Set{V} binds intersectset;
export fn and{V}(a: Set{V}, b: Set{V}) -> Set{V} = intersect(a, b);
export fn difference{V}(a: Set{V}, b: Set{V}) -> Set{V} binds differenceset;
export fn div{V}(a: Set{V}, b: Set{V}) -> Set{V} = difference(a, b);
export fn symmetricDifference{V}(a: Set{V}, b: Set{V}) -> Set{V} binds symmetric_differenceset;
export fn xor{V}(a: Set{V}, b: Set{V}) -> Set{V} = symmetricDifference(a, b);
export fn product{V}(a: Set{V}, b: Set{V}) -> Set{(V, V)} binds productset;
export fn mul{V}(a: Set{V}, b: Set{V}) -> Set{(V, V)} = product(a, b);

/// Process exit-related bindings
export fn ExitCode(e: u8) -> ExitCode binds to_exit_code;
export fn ExitCode(e: u16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u64) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i8) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i64) -> ExitCode = ExitCode(e.u8);
export fn getOrExit{T}(a: Fallible{T}) -> T binds get_or_exit;
export fn getOrExit{T}(a: T?) -> T binds get_or_maybe_exit;

/// Thread-related bindings
export fn wait(t: i64) binds wait;

/// Time-related bindings
export fn now() -> Instant binds now;
export fn elapsed(i: Instant) -> Duration binds elapsed;

/// Uuid-related bindings
export fn uuid() -> uuid binds uuid::Uuid::new_v4;
export fn string(uuid) -> string binds uuidstring;

/// GPU-related bindings

// The base bindings to create buffers of memory on the GPU, construct a plan for a compute shader,
// execute it, and read the buffer back to the CPU
export type BufferUsages binds wgpu::BufferUsages;
export type GBuffer binds GBuffer;
export type GPGPU binds GPGPU;
export fn mapReadBuffer() -> BufferUsages binds map_read_buffer_type;
export fn storageBuffer() -> BufferUsages binds storage_buffer_type;
export fn GBuffer(usage: BufferUsages, vals: Array{i32}) -> GBuffer binds create_buffer_init;
export fn GBuffer(usage: BufferUsages, size: i64) -> GBuffer binds create_empty_buffer;
export fn GBuffer(vals: Array{i32}) -> GBuffer = GBuffer(storageBuffer(), vals);
export fn GBuffer(size: i64) -> GBuffer = GBuffer(storageBuffer(), size);
export fn id(b: GBuffer) -> string binds buffer_id;
export fn GPGPU(source: string, buffers: Array{Array{GBuffer}}, maxGlobalId: i64[3]) -> GPGPU binds GPGPU_new;
export fn GPGPU(source: string, buffer: GBuffer) -> GPGPU binds GPGPU_new_easy;
export fn run(gg: GPGPU) binds gpu_run;
export fn read{T}(b: GBuffer) -> Array{T} binds read_buffer;

// The WgpuType provides a mechanism to build up the logic for a compute shader with normal-looking
// Alan code, not requiring to think in two different languages at the same time. All of the GPU
// types hereafter are derivative of this type
export type WgpuType{N} =
  typeName: N,
  varName: string, // Key to the next field
  statements: Dict{string, string},
  buffers: Set{GBuffer};

// Scalar types and constructors
export type gu32 = WgpuType{"u32"};
export type gi32 = WgpuType{"i32"};
export type gf32 = WgpuType{"f32"};
export type gbool = WgpuType{"bool"};

// TODO: Better constraining on the input types allowed. It will still fail to compile, but the
// error message isn't great at the moment.
export fn build{N}(ret: N) -> GPGPU {
  // TODO: Don't assume all of the buffers involved here are storage buffers
  // Also TODO: Support other buffer types than i32
  let bufferArray = Array{GBuffer}().concat(ret.buffers.Array); // TODO: Shouldn't need this concat
  // let bufferArray = ret.buffers.Array;
  let wgslHeader = bufferArray.map(fn (gb: GBuffer, i: i64) -> string {
    return "@group(0)\n@binding("
      .concat(i.string)
      .concat(")\nvar<storage, read_write> ")
      .concat(gb.id)
      .concat(": array<i32>;\n");
  }).join("\n");
  let wgslFunctionHeader = "@compute\n@workgroup_size(1)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n";
  let wgslFunctionBody = ret.statements.Array.map(fn (kv: (string, string)) -> string {
    return cond(kv.0 == "@builtin(global_invocation_id) id: vec3u", fn () -> string = "", fn () -> string {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let wgsl = wgslHeader.concat(wgslFunctionHeader).concat(wgslFunctionBody).concat("}");
  let maxGlobalIdArray = ret
    .statements['@builtin(global_invocation_id) id: vec3u']
    .getOr('0,0,0')
    .split(',')
    .map(fn (s: string) -> i64 = s.i64.getOr(0));
  let maxGlobalId = {i64[3]}(
    maxGlobalIdArray[0].getOr(0),
    maxGlobalIdArray[1].getOr(0),
    maxGlobalIdArray[2].getOr(0)
  );
  let buffers = Array{Array{GBuffer}}();
  buffers.push(bufferArray);
  return GPGPU(wgsl, buffers, maxGlobalId);
}

export fn gu32(u: u32) -> gu32 = gu32(u.string, Dict{string, string}(), Set{GBuffer}());
export fn gu32(gi: gi32) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32(gf: gf32) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32(gb: gbool) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32{T}(u: T) -> gu32 = gu32(u.u32);

export fn gi32(i: i32) -> gi32 = gi32(i.string, Dict{string, string}(), Set{GBuffer}());
export fn gi32(gu: gu32) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32(gf: gf32) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32(gb: gbool) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32{T}(i: T) -> gi32 = gi32(i.i32);

export fn gf32(f: f32) -> gf32 = gf32(f.string, Dict{string, string}(), Set{GBuffer}());
export fn gf32(gu: gu32) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32(gi: gi32) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32(gb: gbool) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32{T}(f: T) -> gf32 = gf32(f.f32);

export fn gbool(b: bool) -> gbool = gbool(b.string, Dict{string, string}(), Set{GBuffer}());
export fn gbool(gu: gu32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool(gi: gi32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool(gf: gf32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool{T}(b: T) -> gbool = gbool(b.bool);

// Vector types and constructors
export type gvec2u = WgpuType{"vec2u"};
export type gvec2i = WgpuType{"vec2i"};
export type gvec2f = WgpuType{"vec2f"};
export type gvec2b = WgpuType{"vec2<bool>"};
export type gvec3u = WgpuType{"vec3u"};
export type gvec3i = WgpuType{"vec3i"};
export type gvec3f = WgpuType{"vec3f"};
export type gvec3b = WgpuType{"vec3<bool>"};
export type gvec4u = WgpuType{"vec4u"};
export type gvec4i = WgpuType{"vec4i"};
export type gvec4f = WgpuType{"vec4f"};
export type gvec4b = WgpuType{"vec4<bool>"};

export fn gvec2u() -> gvec2u = gvec2u("vec2u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2u(a: gu32, b: gu32) -> gvec2u {
  let statement = "vec2u(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(statement, statements, buffers);
}
export fn gvec2u{T}(a: T, b: T) -> gvec2u = gvec2u(a.gu32, b.gu32);

export fn gvec2i() -> gvec2i = gvec2i("vec2i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2i(a: gi32, b: gi32) -> gvec2i {
  let statement = "vec2i(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(statement, statements, buffers);
}
export fn gvec2i{T}(a: T, b: T) -> gvec2i = gvec2i(a.gi32, b.gi32);

export fn gvec2f() -> gvec2f = gvec2f("vec2f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2f(a: gf32, b: gf32) -> gvec2f {
  let statement = "vec2f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(statement, statements, buffers);
}
export fn gvec2f{T}(a: T, b: T) -> gvec2f = gvec2f(a.gf32, b.gf32);

export fn gvec2b() -> gvec2b = gvec2b("vec2<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2b(a: gbool, b: gbool) -> gvec2b {
  let statement = "vec2<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2b(statement, statements, buffers);
}
export fn gvec2b{T}(a: T, b: T) -> gvec2b = gvec2b(a.gbool, b.gbool);

export fn gvec3u() -> gvec3u = gvec3u("vec3u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3u(a: gu32, b: gu32, c: gu32) -> gvec3u {
  let statement = "vec3u(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3u(statement, statements, buffers);
}
export fn gvec3u{T}(a: T, b: T, c: T) -> gvec3u = gvec3u(a.gu32, b.gu32, c.gu32);

export fn gvec3i() -> gvec3i = gvec3i("vec3i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3i(a: gi32, b: gi32, c: gi32) -> gvec3i {
  let statement = "vec3i(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3i(statement, statements, buffers);
}
export fn gvec3i{T}(a: T, b: T, c: T) -> gvec3i = gvec3i(a.gi32, b.gi32, c.gi32);

export fn gvec3f() -> gvec3f = gvec3f("vec3f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3f(a: gf32, b: gf32, c: gf32) -> gvec3f {
  let statement = "vec3f(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3f(statement, statements, buffers);
}
export fn gvec3f{T}(a: T, b: T, c: T) -> gvec3f = gvec3f(a.gf32, b.gf32, c.gf32);

export fn gvec3b() -> gvec3b = gvec3b("vec3<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3b(a: gbool, b: gbool, c: gbool) -> gvec3b {
  let statement = "vec3<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3b(statement, statements, buffers);
}
export fn gvec3b{T}(a: T, b: T, c: T) -> gvec3b = gvec3b(a.gbool, b.gbool, c.gbool);

export fn gvec4u() -> gvec4u = gvec4u("vec4u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4u(a: gu32, b: gu32, c: gu32, d: gu32) -> gvec4u {
  let statement = "vec4u(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4u(statement, statements, buffers);
}
export fn gvec4u{T}(a: T, b: T, c: T, d: T) -> gvec4u = gvec4u(a.gu32, b.gu32, c.gu32, d.gu32);

export fn gvec4i() -> gvec4i = gvec4i("vec4i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4i(a: gi32, b: gi32, c: gi32, d: gi32) -> gvec4i {
  let statement = "vec4i(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4i(statement, statements, buffers);
}
export fn gvec4i{T}(a: T, b: T, c: T, d: T) -> gvec4i = gvec4i(a.gi32, b.gi32, c.gi32, d.gi32);

export fn gvec4f() -> gvec4f = gvec4f("vec4f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4f(a: gf32, b: gf32, c: gf32, d: gf32) -> gvec4f {
  let statement = "vec4f(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4f(statement, statements, buffers);
}
export fn gvec4f{T}(a: T, b: T, c: T, d: T) -> gvec4f = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);

export fn gvec4b() -> gvec4b = gvec4b("vec4<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4b(a: gbool, b: gbool, c: gbool, d: gbool) -> gvec4b {
  let statement = "vec4<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4b(statement, statements, buffers);
}
export fn gvec4b{T}(a: T, b: T, c: T, d: T) -> gvec4b = gvec4b(a.gbool, b.gbool, c.gbool, d.gbool);

// The global_invocation_id; the entry value to a compute shader, and it's constructor, a
// specialized version of gvec3u that initializes a bit differently.
export fn gFor(x: u32, y: u32, z: u32) -> gvec3u {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',').concat(z.string));
  return gvec3u('id', statements, Set{GBuffer}());
}
export fn gFor{T}(x: T, y: T, z: T) -> gvec3u = gFor(x.u32, y.u32, z.u32);
export fn gFor{T}(x: T, y: T) -> gvec3u = gFor(x.u32, y.u32, 1.u32);
export fn gFor{T}(x: T) -> gu32 = gFor(x.u32, 1.u32, 1.u32).x;

// Matrix types
export type gmat2x2f = WgpuType{"mat2x2f"};
export type gmat2x3f = WgpuType{"mat2x3f"};
export type gmat2x4f = WgpuType{"mat2x4f"};
export type gmat3x2f = WgpuType{"mat3x2f"};
export type gmat3x3f = WgpuType{"mat3x3f"};
export type gmat3x4f = WgpuType{"mat3x4f"};
export type gmat4x2f = WgpuType{"mat4x2f"};
export type gmat4x3f = WgpuType{"mat4x3f"};
export type gmat4x4f = WgpuType{"mat4x4f"};

// TODO: Constructors for matrix types

// TODO: Fixed-length buffers within wgsl

// TODO: How to handle structs?

// GPU Type accessors

export fn x(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2u) -> gu32 = v.x;
export fn j(v: gvec2u) -> gu32 = v.y;

export fn x(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2i) -> gi32 = v.x;
export fn j(v: gvec2i) -> gi32 = v.y;

export fn x(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2f) -> gf32 = v.x;
export fn j(v: gvec2f) -> gf32 = v.y;

export fn x(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec2b) -> gbool = v.x;
export fn j(v: gvec2b) -> gbool = v.y;

export fn x(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3u) -> gu32 = v.x;
export fn j(v: gvec3u) -> gu32 = v.y;
export fn k(v: gvec3u) -> gu32 = v.z;

export fn x(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3i) -> gi32 = v.x;
export fn j(v: gvec3i) -> gi32 = v.y;
export fn k(v: gvec3i) -> gi32 = v.z;

export fn x(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3f) -> gf32 = v.x;
export fn j(v: gvec3f) -> gf32 = v.y;
export fn k(v: gvec3f) -> gf32 = v.z;

export fn x(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec3b) -> gbool = v.x;
export fn j(v: gvec3b) -> gbool = v.y;
export fn k(v: gvec3b) -> gbool = v.z;

export fn x(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.w');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4u) -> gu32 = v.x;
export fn j(v: gvec4u) -> gu32 = v.y;
export fn k(v: gvec4u) -> gu32 = v.z;
export fn l(v: gvec4u) -> gu32 = v.w;

export fn x(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.w');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4i) -> gi32 = v.x;
export fn j(v: gvec4i) -> gi32 = v.y;
export fn k(v: gvec4i) -> gi32 = v.z;
export fn l(v: gvec4i) -> gi32 = v.w;

export fn x(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.w');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4f) -> gf32 = v.x;
export fn j(v: gvec4f) -> gf32 = v.y;
export fn k(v: gvec4f) -> gf32 = v.z;
export fn l(v: gvec4f) -> gf32 = v.w;

export fn x(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn w(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.w');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec4b) -> gbool = v.x;
export fn j(v: gvec4b) -> gbool = v.y;
export fn k(v: gvec4b) -> gbool = v.z;
export fn l(v: gvec4b) -> gbool = v.w;

// TODO: Improve GBuffer to support other buffer types
export fn get(gb: GBuffer, i: gu32) -> gi32 {
  let statement = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(gb));
  return gi32(statement, i.statements, buffers);
}

export fn store(a: gi32, b: gi32) -> gi32 {
    let statement = a.varName.concat(" = ").concat(b.varName);
    let statements = a.statements.concat(b.statements).concat(Dict(statement, statement));
    let buffers = a.buffers.union(b.buffers);
    return gi32(statement, statements, buffers);
}

// GPU Math

export fn add(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn add{T}(a: gu32, b: T) -> gu32 = add(a, b.gu32);
export fn add{T}(a: T, b: gu32) -> gu32 = add(a.gu32, b);

export fn add(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn add{T}(a: gi32, b: T) -> gi32 = add(a, b.gi32);
export fn add{T}(a: T, b: gi32) -> gi32 = add(a.gi32, b);

export fn add(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn add{T}(a: gf32, b: T) -> gf32 = add(a, b.gf32);
export fn add{T}(a: T, b: gf32) -> gf32 = add(a.gf32, b);

export fn mul(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn mul{T}(a: gu32, b: T) -> gu32 = mul(a, b.gu32);
export fn mul{T}(a: T, b: gu32) -> gu32 = mul(a.gu32, b);

export fn mul(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn mul{T}(a: gi32, b: T) -> gi32 = mul(a, b.gi32);
export fn mul{T}(a: T, b: gi32) -> gi32 = mul(a.gi32, b);

export fn mul(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn mul{T}(a: gf32, b: T) -> gf32 = mul(a, b.gf32);
export fn mul{T}(a: T, b: gf32) -> gf32 = mul(a.gf32, b);

/// Stdout/stderr-related bindings
// TODO: Rework this to just print anything that can be converted to `string` via interfaces
export fn print(d: Duration) binds print_duration;
export fn print{T}(v: Fallible{T}) binds println_result;
export fn print{T}(v: Maybe{T}) binds println_maybe;
export fn print{T}(v: Array{T}) binds print_vec;
export fn print{T, N}(v: Buffer{T, N}) binds print_buffer;
export fn print{T}(v: Array{Fallible{T}}) binds print_vec_result;
export fn print(v: void) binds println_void;
export fn print{T}(v: T) binds println;
export fn eprint{T}(v: Fallible{T}) binds eprintln_result;
export fn eprint{T}(v: Maybe{T}) binds eprintln_maybe;
export fn eprint{T}(v: T) binds eprintln;

/// Built-in operator definitions
// TODO: New plan is to make operators only map to one function per symbol and *kind* of operator,
// so you can have an infix and prefix operator with the same symbol linked to different functions,
// but you can't have an infix operator of the same symbol linked to multiple functions. This does
// produce some ambiguity of what kind of operator an operator is, but should still be unambiguous
// to humans to "read" the symbol as whatever kind of function it represents.
export infix add as + precedence 3;
export infix sub as - precedence 3;
export prefix neg as - precedence 2;
export infix mul as * precedence 4;
export infix div as / precedence 4;
export infix mod as % precedence 4;
// export infix template as % precedence 4;
export infix pow as ** precedence 5;
export infix and as & precedence 4;
export infix and as && precedence 4;
export infix or as | precedence 3;
export infix or as || precedence 3;
export infix xor as ^ precedence 3;
export prefix not as ! precedence 5;
export infix nand as !& precedence 4;
export infix nor as !| precedence 3;
export infix xnor as !^ precedence 3;
export infix eq as == precedence 1;
export infix neq as != precedence 1;
export infix lt as < precedence 1;
export infix lte as <= precedence 1;
export infix gt as > precedence 1;
export infix gte as >= precedence 1;
export prefix len as # precedence 1; // TODO: Is this useful?
export infix shl as << precedence 2;
export infix shr as >> precedence 2;
export infix wrl as <<< precedence 2;
export infix wrr as >>> precedence 2;
export infix store as = precedence 0;
