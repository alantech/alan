/**
 * The Alan root scope. The functions and types it binds from Rust are either part of the standard
 * library, or are defined in the sibling root.rs file
 **/

/// Type system setup

// Declaration of the types the compiler-time type system is built on
export ctype Type; // Any kind of concrete type
export ctype Generic; // Any type that is a generic type (not yet realized into a concrete type)
export ctype Binds{T}; // A direct reference into the platform language's type system
export ctype Int; // An integer used *to define a type*, like the length of a fixed array
export ctype Float; // A float used to define a type. I have no idea why you'd want this, yet
export ctype Bool; // A bool used to define a type. Heavily used for conditional compilation
export ctype String; // A string used to define a type. Useful for conditional inclusion of files/code
export ctype Group{G}; // A grouping of type statements `()`. Useful to allow for tuples of tuples
export ctype Function{I, O}; // A function type, indicating the input and output of the function
export ctype Call{N, F}; // A reference to a function call (or method, etc) in the platform language
export ctype Infix{O}; // A reference to a native infix operation in the platform language
export ctype Prefix{O}; // A reference to a native prefix operation in the platform language
export ctype Tuple{A, B}; // A tuple of two (or more) types in a single compound type
export ctype Field{L, V}; // Labeling a type with a property name. Useful to turn tuples into structs
export ctype Either{A, B}; // An either type, allowing the value to be from *one* of the specified types, kinda like Rust enums
export ctype Prop{T, P}; // Extracts the inner type from the outer type by the property name or number
export ctype AnyOf{A, B}; // The AnyOf type is kinda like a Tuple, in that all sub-types are present, but it only *resolves* into one of these types above it. Useful for choosing the "best" integer, or a particular function by name.
export ctype Buffer{T, S}; // A buffer type, a pre-allocated, fixed-length array of the specified type the specified amount
export ctype Array{T}; // An array type, a variable-length array of the specified type the specified amount. This would usually be an stdlib type built in the language itself, but we're just going to re-use the one in the platform language

// The following `ctype`s don't represent data but instead represent transforms that convert into one of the many ctypes above. (I did not expect to need so many of them.)
export ctype Fail{M}; // A special type that if ever encountered at compile time causes the compilation to fail with the specified error message. Useful with conditional types
export ctype Add{A, B}; // Combines the Int or Float types together at compile time into a new Int or Float. Fails if an Int and Float are mixed.
export ctype Sub{A, B}; // Same, but subtracts them
export ctype Mul{A, B}; // Multiplication
export ctype Div{A, B}; // Division
export ctype Mod{A, B}; // Modulus (remainder)
export ctype Pow{A, B}; // Exponentiation/Power
export ctype Min{A, B}; // Minimum value of the two
export ctype Max{A, B}; // Maximum value of the two
export ctype Neg{A}; // Negate the value
export ctype Len{A}; // Returns the length of the input type in terms of the number of elements it contains, which is most useful for Buffers, Tuples, and Either, causes a compiler failure for Arrays, and returns 1 for everything else
export ctype Size{T}; // Returns the size in bytes of the type in question, if possible, causing a compiler failure otherwise.
export ctype FileStr{F}; // Read a file and return a string constant, useful for including large strings from a separate, nearby file, or fails if it doesn't exist
export ctype Env{K}; // Read an environment variable at compile time and return a string of the value. Returns an empty string if the key doesn't exist. Intended to be used with...
export ctype EnvExists{K}; // Returns a boolean if the environment variable key exists at compile time, and...
export ctype If{C, A, B}; // A conditional type, if C is true, resolves to A, otherwise to B. There's also a simpler version...
export ctype If{C, T}; // That expects a two-type tuple and extracts the first tuple type for true and the second for false, which can be bound to symbolic syntax
export ctype Env{K, D}; // Finally, since the majority of the time this is what you'd want, this variant of `Env` takes a default value to use when the key does not exist, making this another conditional type
export ctype And{A, B}; // Performs a boolean or bitwise AND on the inputs, depending on type
export ctype Or{A, B}; // Performs a boolean or bitwise OR on the inputs
export ctype Xor{A, B}; // Performs a boolean or bitwise XOR on the inputs
export ctype Not{B}; // Inverts the boolean provided
export ctype Nand{A, B}; // Performs a boolean or bitwise NAND on the inputs
export ctype Nor{A, B}; // Performs a boolean or bitwise NOR on the inputs
export ctype Xnor{A, B}; // Performs a boolean or bitwise XNOR on the inputs (same as EQ for booleans)
export ctype Eq{A, B}; // Returns true if the two types are the same (or are the same int, float, bool, or string), false otherwise
export ctype Neq{A, B}; // Returns true if the two types are difference
export ctype Lt{A, B}; // Returns true if A is less than B (and are an int or float)
export ctype Lte{A, B}; // Returns true if A is less than or equal to B
export ctype Gt{A, B}; // Returns true if A is greater than B
export ctype Gte{A, B}; // Returns true if A is greater than or equal to B

// Defining derived types
export type void = ();
export type Error = Binds{"AlanError"};
export type Fallible{T} = Either{T, Error};
export type Maybe{T} = Either{T, ()};
export type Test = Eq{Env{"ALAN_TARGET"}, "test"};
export type Release = Eq{Env{"ALAN_TARGET"}, "release"};
export type Debug = Eq{Env{"ALAN_TARGET"}, "debug"};

// Defining the operators in the type system
export type infix Function as -> precedence 3; // I -> O, where I is the input and O is the output. With Tuples and Fields you can reconstruct arguments for functions.
export type infix Call as :: precedence 0; // N :: F, where N is the native function (or method) and F is the function type 
export type infix Tuple as , precedence 0; // A, B, C, ... The tuple type combines with other tuple types to become a larger tuple type. To have a tuple of tuples, you need to `Group` the inner tuple, eg `(a, b), c`
export type infix Field as : precedence 1; // Foo: Bar, let's you specify a property access label for the type, useful for syntactic sugar on a tuple type and the Either type (eventually).
export type infix Either as | precedence 0; // A | B, the type has a singular value from only one of the types at once.
export type infix Prop as . precedence 5; // A.B, returns the sub-type within A referenced by property B. Allows an inverse of a Tuple or Either type, accessed by either the Field name or an integer index
export type infix AnyOf as & precedence 0; // A & B, which can be passed to a function that takes A or B as necessary.
export type infix Buffer as [ precedence 1; // Technically allows `Foo[3` by itself to be valid syntax, but...
export type postfix Group as ] precedence 1; // Technically not necessary, but allows for `Foo[3]` to do the "right thing" and become a buffer of size 3, with a singular useless Group being wrapped around it (and then unwrapped on type generation). The only "bad" thing here is `Group` gets special behavior, matching the `(...)` syntax, so there's two ways to invoke a Group via symbols.
export type postfix Array as [] precedence 4; // Allows `Foo[]` to do the right thing
export type postfix Maybe as ? precedence 4; // Allows `Foo?` for nullable types. Should this have a precedence of 5?
export type postfix Fallible as ! precedence 4; // Allows `Foo!` for fallible types. Same question on the precedence.
export type infix Add as + precedence 2;
export type infix Sub as - precedence 2;
export type infix Mul as * precedence 3;
export type infix Div as / precedence 3;
export type infix Mod as % precedence 3;
export type infix Pow as ** precedence 4;
export type infix If as ?? precedence 1; // C puts this kind of thing as a very high precedence. I'm not sure if I want to follow it. I feel like that would force grouping parens everywhere.
export type infix And as && precedence 3;
export type infix Or as || precedence 2;
export type infix Xor as ^ precedence 2;
export type prefix Not as ~ precedence 4; // TODO: Temporarily change this from ! to ~ until the operator prefix/postfix tiebreaker is updated to accept whichever *works* rather than prefer prefix
export type infix Nand as !& precedence 3;
export type infix Nor as !| precedence 2;
export type infix Xnor as !^ precedence 2;
export type infix Eq as == precedence 1;
export type infix Neq as != precedence 1;
export type infix Lt as < precedence 1;
export type infix Lte as <= precedence 1;
export type infix Gt as > precedence 1;
export type infix Gte as >= precedence 1;

// Binding the integer types
export type i8 = Binds{"i8"};
export type i16 = Binds{"i16"};
export type i32 = Binds{"i32"};
export type i64 = Binds{"i64"};
export type u8 = Binds{"u8"};
export type u16 = Binds{"u16"};
export type u32 = Binds{"u32"};
export type u64 = Binds{"u64"};

// Binding the float types
export type f32 = Binds{"f32"};
export type f64 = Binds{"f64"};

// Binding the string types
export type string = Binds{"String"};

// Binding the boolean types
export type bool = Binds{"bool"};

// Binding the exit code type
export type ExitCode = Binds{"std::process::ExitCode"};

// Binding the time types
export type Instant = Binds{"std::time::Instant"};
export type Duration = Binds{"std::time::Duration"};

// Binding the uuid type
export type uuid = Binds{"uuid::Uuid"};

// Binding the Dict and Set types
export type Dict{K, V} = Binds{"OrderedHashMap", K, V};
export type Set{V} = Binds{"std::collections::HashSet", V};

/// Functions for (potentially) every type
export fn clone{T} "clone" :: T -> T;
// TODO: The "proper" way to hash this consistently for all types is to decompose the input type
// into the various primitive types of Alan and then have hashing rules for each of them, which
// may themselves decompose, etc. This might be doable in Alan code on top of specialized hashing
// functions in Rust (as partially implemented here) or it might be better done as a special `hash`
// function created by the compiler for the specific type *if* ever actually used, walking the
// CType tree to determine the correct code to run. In either case, this is "good enough" for now.
export fn hash{T} "hasharray" :: T[] -> i64;
export fn hash "hashstring" :: string -> i64;
export fn hash{T} "hash" :: T -> i64;
export fn void{T}(v: T) -> void {}
export fn void() -> void {}
export fn store{T} "storeswap" :: (T, T) -> T;

/// Fallible, Maybe, and Either functions
export fn getOr{T} "maybe_get_or" :: (T?, T) -> T;
export fn getOr{T} "fallible_get_or" :: (T!, T) -> T;
export fn Error{T} "fallible_error" :: string -> T!;
export fn Error "bare_error" :: string -> Error;
export fn exists{T} "maybe_exists" :: T? -> bool;

/// Signed Integer-related functions and function bindings
export fn i8(i: i8) -> i8 = i;
export fn i8 "i16toi8" :: i16 -> i8;
export fn i8 "i32toi8" :: i32 -> i8;
export fn i8 "i64toi8" :: i64 -> i8;
export fn i8 "u8toi8" :: u8 -> i8;
export fn i8 "u16toi8" :: u16 -> i8;
export fn i8 "u32toi8" :: u32 -> i8;
export fn i8 "u64toi8" :: u64 -> i8;
export fn i8 "f32toi8" :: f32 -> i8;
export fn i8 "f64toi8" :: f64 -> i8;
export fn i8 "stringtoi8" :: string -> i8!;
export fn add "addi8" :: (i8, i8) -> i8;
export fn sub "subi8" :: (i8, i8) -> i8;
export fn mul "muli8" :: (i8, i8) -> i8;
export fn div "divi8" :: (i8, i8) -> i8;
export fn mod "modi8" :: (i8, i8) -> i8;
export fn pow "powi8" :: (i8, i8) -> i8;
export fn min "mini8" :: (i8, i8) -> i8;
export fn max "maxi8" :: (i8, i8) -> i8;
export fn neg Prefix{"-"} :: i8 -> i8;
export fn and Infix{"&"} :: (i8, i8) -> i8;
export fn or Infix{"|"} :: (i8, i8) -> i8;
export fn xor Infix{"^"} :: (i8, i8) -> i8;
export fn not Prefix{"!"} :: i8 -> i8;
export fn nand "nandi8" :: (i8, i8) -> i8;
export fn nor "nori8" :: (i8, i8) -> i8;
export fn xnor "xnori8" :: (i8, i8) -> i8;
export fn eq Infix{"=="} :: (i8, i8) -> bool;
export fn neq Infix{"!="} :: (i8, i8) -> bool;
export fn lt Infix{"<"} :: (i8, i8) -> bool;
export fn lte Infix{"<="} :: (i8, i8) -> bool;
export fn gt Infix{">"} :: (i8, i8) -> bool;
export fn gte Infix{">="} :: (i8, i8) -> bool;
export fn shl "shli8" :: (i8, i8) -> i8;
export fn shr "shri8" :: (i8, i8) -> i8;
export fn wrl "wrli8" :: (i8, i8) -> i8;
export fn wrr "wrri8" :: (i8, i8) -> i8;

export fn i16 "i8toi16" :: i8 -> i16;
export fn i16(i: i16) -> i16 = i;
export fn i16 "i32toi16" :: i32 -> i16;
export fn i16 "i64toi16" :: i64 -> i16;
export fn i16 "u8toi16" :: u8 -> i16;
export fn i16 "u16toi16" :: u16 -> i16;
export fn i16 "u32toi16" :: u32 -> i16;
export fn i16 "u64toi16" :: u64 -> i16;
export fn i16 "f32toi16" :: f32 -> i16;
export fn i16 "f64toi16" :: f64 -> i16;
export fn i16 "stringtoi16" :: string -> i16!;
export fn add "addi16" :: (i16, i16) -> i16;
export fn sub "subi16" :: (i16, i16) -> i16;
export fn mul "muli16" :: (i16, i16) -> i16;
export fn div "divi16" :: (i16, i16) -> i16;
export fn mod "modi16" :: (i16, i16) -> i16;
export fn pow "powi16" :: (i16, i16) -> i16;
export fn min "mini16" :: (i16, i16) -> i16;
export fn max "maxi16" :: (i16, i16) -> i16;
export fn neg "negi16" :: i16 -> i16;
export fn and "andi16" :: (i16, i16) -> i16;
export fn or "ori16" :: (i16, i16) -> i16;
export fn xor "xori16" :: (i16, i16) -> i16;
export fn not "noti16" :: i16 -> i16;
export fn nand "nandi16" :: (i16, i16) -> i16;
export fn nor "nori16" :: (i16, i16) -> i16;
export fn xnor "xnori16" :: (i16, i16) -> i16;
export fn eq "eqi16" :: (i16, i16) -> bool;
export fn neq "neqi16" :: (i16, i16) -> bool;
export fn lt "lti16" :: (i16, i16) -> bool;
export fn lte "ltei16" :: (i16, i16) -> bool;
export fn gt "gti16" :: (i16, i16) -> bool;
export fn gte "gtei16" :: (i16, i16) -> bool;
export fn shl "shli16" :: (i16, i16) -> i16;
export fn shr "shri16" :: (i16, i16) -> i16;
export fn wrl "wrli16" :: (i16, i16) -> i16;
export fn wrr "wrri16" :: (i16, i16) -> i16;

export fn i32 "i8toi32" :: i8 -> i32;
export fn i32 "i16toi32" :: i16 -> i32;
export fn i32(i: i32) -> i32 = i;
export fn i32 "i64toi32" :: i64 -> i32;
export fn i32 "u8toi32" :: u8 -> i32;
export fn i32 "u16toi32" :: u16 -> i32;
export fn i32 "u32toi32" :: u32 -> i32;
export fn i32 "u64toi32" :: u64 -> i32;
export fn i32 "f32toi32" :: f32 -> i32;
export fn i32 "f64toi32" :: f64 -> i32;
export fn i32 "f64toi32" :: string -> i32!;
export fn add "addi32" :: (i32, i32) -> i32;
export fn sub "subi32" :: (i32, i32) -> i32;
export fn mul "muli32" :: (i32, i32) -> i32;
export fn div "divi32" :: (i32, i32) -> i32;
export fn mod "modi32" :: (i32, i32) -> i32;
export fn pow "powi32" :: (i32, i32) -> i32;
export fn min "mini32" :: (i32, i32) -> i32;
export fn max "maxi32" :: (i32, i32) -> i32;
export fn neg "negi32" :: i32 -> i32;
export fn and "andi32" :: (i32, i32) -> i32;
export fn or "ori32" :: (i32, i32) -> i32;
export fn xor "xori32" :: (i32, i32) -> i32;
export fn not "noti32" :: i32 -> i32;
export fn nand "nandi32" :: (i32, i32) -> i32;
export fn nor "nori32" :: (i32, i32) -> i32;
export fn xnor "xnori32" :: (i32, i32) -> i32;
export fn eq "eqi32" :: (i32, i32) -> bool;
export fn neq "neqi32" :: (i32, i32) -> bool;
export fn lt "lti32" :: (i32, i32) -> bool;
export fn lte "ltei32" :: (i32, i32) -> bool;
export fn gt "gti32" :: (i32, i32) -> bool;
export fn gte "gtei32" :: (i32, i32) -> bool;
export fn shl "shli32" :: (i32, i32) -> i32;
export fn shr "shri32" :: (i32, i32) -> i32;
export fn wrl "wrli32" :: (i32, i32) -> i32;
export fn wrr "wrri32" :: (i32, i32) -> i32;

export fn i64 "i8toi64" :: i8 -> i64;
export fn i64 "i16toi64" :: i16 -> i64;
export fn i64 "i32toi64" :: i32 -> i64;
export fn i64(i: i64) -> i64 = i;
export fn i64 "u8toi64" :: u8 -> i64;
export fn i64 "u16toi64" :: u16 -> i64;
export fn i64 "u32toi64" :: u32 -> i64;
export fn i64 "u64toi64" :: u64 -> i64;
export fn i64 "f32toi64" :: f32 -> i64;
export fn i64 "f64toi64" :: f64 -> i64;
export fn i64 "stringtoi64" :: string -> i64!;
export fn add "addi64" :: (i64, i64) -> i64;
export fn sub "subi64" :: (i64, i64) -> i64;
export fn mul "muli64" :: (i64, i64) -> i64;
export fn div "divi64" :: (i64, i64) -> i64;
export fn mod "modi64" :: (i64, i64) -> i64;
export fn pow "powi64" :: (i64, i64) -> i64;
export fn min "mini64" :: (i64, i64) -> i64;
export fn max "maxi64" :: (i64, i64) -> i64;
export fn neg "negi64" :: i64 -> i64;
export fn and "andi64" :: (i64, i64) -> i64;
export fn or "ori64" :: (i64, i64) -> i64;
export fn xor "xori64" :: (i64, i64) -> i64;
export fn not "noti64" :: i64 -> i64;
export fn nand "nandi64" :: (i64, i64) -> i64;
export fn nor "nori64" :: (i64, i64) -> i64;
export fn xnor "xnori64" :: (i64, i64) -> i64;
export fn eq "eqi64" :: (i64, i64) -> bool;
export fn neq "neqi64" :: (i64, i64) -> bool;
export fn lt "lti64" :: (i64, i64) -> bool;
export fn lte "ltei64" :: (i64, i64) -> bool;
export fn gt "gti64" :: (i64, i64) -> bool;
export fn gte "gtei64" :: (i64, i64) -> bool;
export fn shl "shli64" :: (i64, i64) -> i64;
export fn shr "shri64" :: (i64, i64) -> i64;
export fn wrl "wrli64" :: (i64, i64) -> i64;
export fn wrr "wrri64" :: (i64, i64) -> i64;

/// Unsigned Integer-related functions and function bindings
export fn u8 "i8tou8" :: i8 -> u8;
export fn u8 "i16tou8" :: i16 -> u8;
export fn u8 "i32tou8" :: i32 -> u8;
export fn u8 "i64tou8" :: i64 -> u8;
export fn u8(i: u8) -> u8 = i;
export fn u8 "u16tou8" :: u16 -> u8;
export fn u8 "u32tou8" :: u32 -> u8;
export fn u8 "u64tou8" :: u64 -> u8;
export fn u8 "f32tou8" :: f32 -> u8;
export fn u8 "f64tou8" :: f64 -> u8;
export fn u8 "stringtou8" :: string -> u8!;
export fn add "addu8" :: (u8, u8) -> u8;
export fn sub "subu8" :: (u8, u8) -> u8;
export fn mul "mulu8" :: (u8, u8) -> u8;
export fn div "divu8" :: (u8, u8) -> u8;
export fn mod "modu8" :: (u8, u8) -> u8;
export fn pow "powu8" :: (u8, u8) -> u8;
export fn min "minu8" :: (u8, u8) -> u8;
export fn max "maxu8" :: (u8, u8) -> u8;
export fn and "andu8" :: (u8, u8) -> u8;
export fn or "oru8" :: (u8, u8) -> u8;
export fn xor "xoru8" :: (u8, u8) -> u8;
export fn not "notu8" :: u8 -> u8;
export fn nand "nandu8" :: (u8, u8) -> u8;
export fn nor "noru8" :: (u8, u8) -> u8;
export fn xnor "xnoru8" :: (u8, u8) -> u8;
export fn eq "equ8" :: (u8, u8) -> bool;
export fn neq "nequ8" :: (u8, u8) -> bool;
export fn lt "ltu8" :: (u8, u8) -> bool;
export fn lte "lteu8" :: (u8, u8) -> bool;
export fn gt "gtu8" :: (u8, u8) -> bool;
export fn gte "gteu8" :: (u8, u8) -> bool;
export fn shl "shlu8" :: (u8, u8) -> u8;
export fn shr "shru8" :: (u8, u8) -> u8;
export fn wrl "wrlu8" :: (u8, u8) -> u8;
export fn wrr "wrru8" :: (u8, u8) -> u8;

export fn u16 "i8tou16" :: i8 -> u16;
export fn u16 "i16tou16" :: i16 -> u16;
export fn u16 "i32tou16" :: i32 -> u16;
export fn u16 "i64tou16" :: i64 -> u16;
export fn u16 "u8tou16" :: u8 -> u16;
export fn u16(i: u16) -> u16 = i;
export fn u16 "u32tou16" :: u32 -> u16;
export fn u16 "u64tou16" :: u64 -> u16;
export fn u16 "f32tou16" :: f32 -> u16;
export fn u16 "f64tou16" :: f64 -> u16;
export fn u16 "stringtou16" :: string -> u16!;
export fn add "addu16" :: (u16, u16) -> u16;
export fn sub "subu16" :: (u16, u16) -> u16;
export fn mul "mulu16" :: (u16, u16) -> u16;
export fn div "divu16" :: (u16, u16) -> u16;
export fn mod "modu16" :: (u16, u16) -> u16;
export fn pow "powu16" :: (u16, u16) -> u16;
export fn min "minu16" :: (u16, u16) -> u16;
export fn max "maxu16" :: (u16, u16) -> u16;
export fn and "andu16" :: (u16, u16) -> u16;
export fn or "oru16" :: (u16, u16) -> u16;
export fn xor "xoru16" :: (u16, u16) -> u16;
export fn not "notu16" :: u16 -> u16;
export fn nand "nandu16" :: (u16, u16) -> u16;
export fn nor "noru16" :: (u16, u16) -> u16;
export fn xnor "xnoru16" :: (u16, u16) -> u16;
export fn eq "equ16" :: (u16, u16) -> bool;
export fn neq "nequ16" :: (u16, u16) -> bool;
export fn lt "ltu16" :: (u16, u16) -> bool;
export fn lte "lteu16" :: (u16, u16) -> bool;
export fn gt "gtu16" :: (u16, u16) -> bool;
export fn gte "gteu16" :: (u16, u16) -> bool;
export fn shl "shlu16" :: (u16, u16) -> u16;
export fn shr "shru16" :: (u16, u16) -> u16;
export fn wrl "wrlu16" :: (u16, u16) -> u16;
export fn wrr "wrru16" :: (u16, u16) -> u16;

export fn u32 "i8tou32" :: i8 -> u32;
export fn u32 "i16tou32" :: i16 -> u32;
export fn u32 "i32tou32" :: i32 -> u32;
export fn u32 "i64tou32" :: i64 -> u32;
export fn u32 "u8tou32" :: u8 -> u32;
export fn u32 "u16tou32" :: u16 -> u32;
export fn u32(i: u32) -> u32 = i;
export fn u32 "u64tou32" :: u64 -> u32;
export fn u32 "f32tou32" :: f32 -> u32;
export fn u32 "f64tou32" :: f64 -> u32;
export fn u32 "stringtou32" :: string -> u32!;
export fn add "addu32" :: (u32, u32) -> u32;
export fn sub "subu32" :: (u32, u32) -> u32;
export fn mul "mulu32" :: (u32, u32) -> u32;
export fn div "divu32" :: (u32, u32) -> u32;
export fn mod "modu32" :: (u32, u32) -> u32;
export fn pow "powu32" :: (u32, u32) -> u32;
export fn min "minu32" :: (u32, u32) -> u32;
export fn max "maxu32" :: (u32, u32) -> u32;
export fn and "andu32" :: (u32, u32) -> u32;
export fn or "oru32" :: (u32, u32) -> u32;
export fn xor "xoru32" :: (u32, u32) -> u32;
export fn not "notu32" :: u32 -> u32;
export fn nand "nandu32" :: (u32, u32) -> u32;
export fn nor "noru32" :: (u32, u32) -> u32;
export fn xnor "xnoru32" :: (u32, u32) -> u32;
export fn eq "equ32" :: (u32, u32) -> bool;
export fn neq "nequ32" :: (u32, u32) -> bool;
export fn lt "ltu32" :: (u32, u32) -> bool;
export fn lte "lteu32" :: (u32, u32) -> bool;
export fn gt "gtu32" :: (u32, u32) -> bool;
export fn gte "gteu32" :: (u32, u32) -> bool;
export fn shl "shlu32" :: (u32, u32) -> u32;
export fn shr "shru32" :: (u32, u32) -> u32;
export fn wrl "wrlu32" :: (u32, u32) -> u32;
export fn wrr "wrru32" :: (u32, u32) -> u32;

export fn u64 "i8tou64" :: i8 -> u64;
export fn u64 "i16tou64" :: i16 -> u64;
export fn u64 "i32tou64" :: i32 -> u64;
export fn u64 "i64tou64" :: i64 -> u64;
export fn u64 "u8tou64" :: u8 -> u64;
export fn u64 "u16tou64" :: u16 -> u64;
export fn u64 "u32tou64" :: u32 -> u64;
export fn u64(u: u64) -> u64 = u;
export fn u64 "f32tou64" :: f32 -> u64;
export fn u64 "f64tou64" :: f64 -> u64;
export fn u64 "stringtou64" :: string -> u64!;
export fn add "addu64" :: (u64, u64) -> u64;
export fn sub "subu64" :: (u64, u64) -> u64;
export fn mul "mulu64" :: (u64, u64) -> u64;
export fn div "divu64" :: (u64, u64) -> u64;
export fn mod "modu64" :: (u64, u64) -> u64;
export fn pow "powu64" :: (u64, u64) -> u64;
export fn min "minu64" :: (u64, u64) -> u64;
export fn max "maxu64" :: (u64, u64) -> u64;
export fn and "andu64" :: (u64, u64) -> u64;
export fn or "oru64" :: (u64, u64) -> u64;
export fn xor "xoru64" :: (u64, u64) -> u64;
export fn not "notu64" :: u64 -> u64;
export fn nand "nandu64" :: (u64, u64) -> u64;
export fn nor "noru64" :: (u64, u64) -> u64;
export fn xnor "xnoru64" :: (u64, u64) -> u64;
export fn eq "equ64" :: (u64, u64) -> bool;
export fn neq "nequ64" :: (u64, u64) -> bool;
export fn lt "ltu64" :: (u64, u64) -> bool;
export fn lte "lteu64" :: (u64, u64) -> bool;
export fn gt "gtu64" :: (u64, u64) -> bool;
export fn gte "gteu64" :: (u64, u64) -> bool;
export fn shl "shlu64" :: (u64, u64) -> u64;
export fn shr "shru64" :: (u64, u64) -> u64;
export fn wrl "wrlu64" :: (u64, u64) -> u64;
export fn wrr "wrru64" :: (u64, u64) -> u64;

/// Float-related functions and function bindings
export fn f32 "i8tof32" :: i8 -> f32;
export fn f32 "i16tof32" :: i16 -> f32;
export fn f32 "i32tof32" :: i32 -> f32;
export fn f32 "i64tof32" :: i64 -> f32;
export fn f32 "u8tof32" :: u8 -> f32;
export fn f32 "u16tof32" :: u16 -> f32;
export fn f32 "u32tof32" :: u32 -> f32;
export fn f32 "u64tof32" :: u64 -> f32;
export fn f32(f: f32) -> f32 = f;
export fn f32 "f64tof32" :: f64 -> f32;
export fn f32 "stringtof32" :: string -> f32!;
export fn add "addf32" :: (f32, f32) -> f32;
export fn sub "subf32" :: (f32, f32) -> f32;
export fn mul "mulf32" :: (f32, f32) -> f32;
export fn div "divf32" :: (f32, f32) -> f32;
export fn sqrt "sqrtf32" :: f32 -> f32;
export fn pow "powf32" :: (f32, f32) -> f32;
export fn min "minf32" :: (f32, f32) -> f32;
export fn max "maxf32" :: (f32, f32) -> f32;
export fn neg "negf32" :: f32 -> f32;
export fn eq "eqf32" :: (f32, f32) -> bool;
export fn neq "neqf32" :: (f32, f32) -> bool;
export fn lt "ltf32" :: (f32, f32) -> bool;
export fn lte "ltef32" :: (f32, f32) -> bool;
export fn gt "gtf32" :: (f32, f32) -> bool;
export fn gte "gtef32" :: (f32, f32) -> bool;

export fn f64 "i8tof64" :: i8 -> f64;
export fn f64 "i16tof64" :: i16 -> f64;
export fn f64 "i32tof64" :: i32 -> f64;
export fn f64 "i64tof64" :: i64 -> f64;
export fn f64 "u8tof64" :: u8 -> f64;
export fn f64 "u16tof64" :: u16 -> f64;
export fn f64 "u32tof64" :: u32 -> f64;
export fn f64 "u64tof64" :: u64 -> f64;
export fn f64 "f32tof64" :: f32 -> f64;
export fn f64(f: f64) -> f64 = f;
export fn f64 "stringtof64" :: string -> f64!;
export fn add "addf64" :: (f64, f64) -> f64;
export fn sub "subf64" :: (f64, f64) -> f64;
export fn mul "mulf64" :: (f64, f64) -> f64;
export fn div "divf64" :: (f64, f64) -> f64;
export fn sqrt "sqrtf64" :: f64 -> f64;
export fn pow "powf64" :: (f64, f64) -> f64;
export fn min "minf64" :: (f64, f64) -> f64;
export fn max "maxf64" :: (f64, f64) -> f64;
export fn neg "negf64" :: f64 -> f64;
export fn eq "eqf64" :: (f64, f64) -> bool;
export fn neq "neqf64" :: (f64, f64) -> bool;
export fn lt "ltf64" :: (f64, f64) -> bool;
export fn lte "ltef64" :: (f64, f64) -> bool;
export fn gt "gtf64" :: (f64, f64) -> bool;
export fn gte "gtef64" :: (f64, f64) -> bool;

/// String related bindings
export fn string "i8tostring" :: i8 -> string;
export fn string "i16tostring" :: i16 -> string;
export fn string "i32tostring" :: i32 -> string;
export fn string "i64tostring" :: i64 -> string;
export fn string "u8tostring" :: u8 -> string;
export fn string "u16tostring" :: u16 -> string;
export fn string "u32tostring" :: u32 -> string;
export fn string "u64tostring" :: u64 -> string;
export fn string "f32tostring" :: f32 -> string;
export fn string "f64tostring" :: f64 -> string;
export fn string "booltostring" :: bool -> string;
export fn string(s: string) -> string = s;
export fn concat "concatstring" :: (string, string) -> string;
export fn repeat "repeatstring" :: (string, i64) -> string;
export fn replace "replacestring" :: (string, string, string) -> string;
export fn split "splitstring" :: (string, string) -> string[];
export fn len "lenstring" :: string -> i64;
export fn get "getstring" :: (string, i64) -> string!;
export fn trim "trimstring" :: string -> string;
export fn index "indexstring" :: (string, string) -> i64!;
export fn min "minstring" :: (string, string) -> string;
export fn max "maxstring" :: (string, string) -> string;
export fn eq "eqstring" :: (string, string) -> bool;
export fn neq "neqstring" :: (string, string) -> bool;
export fn lt "ltstring" :: (string, string) -> bool;
export fn lte "ltestring" :: (string, string) -> bool;
export fn gt "gtstring" :: (string, string) -> bool;
export fn gte "gtestring" :: (string, string) -> bool;
export fn join "joinstring" :: (string[], string) -> string;
// TODO: There's something odd with the Buffer symbolic syntax that needs fixing
export fn join{S}(a: Buffer{string, S}, s: string) -> string = {"bufferjoinstring" :: (Buffer{string, S}, string) -> string}(a, s);

/// Boolean related bindings
export fn bool "i8tobool" :: i8 -> bool;
export fn bool "i16tobool" :: i16 -> bool;
export fn bool "i32tobool" :: i32 -> bool;
export fn bool "i64tobool" :: i64 -> bool;
export fn bool "u8tobool" :: u8 -> bool;
export fn bool "u16tobool" :: u16 -> bool;
export fn bool "u32tobool" :: u32 -> bool;
export fn bool "u64tobool" :: u64 -> bool;
export fn bool "f32tobool" :: f32 -> bool;
export fn bool "f64tobool" :: f64 -> bool;
export fn bool "stringtobool" :: string -> bool;
export fn bool(b: bool) -> bool = b;
export fn and "andbool" :: (bool, bool) -> bool;
export fn or "orbool" :: (bool, bool) -> bool;
export fn xor "xorbool" :: (bool, bool) -> bool;
export fn not "notbool" :: bool -> bool;
export fn nand "nandbool" :: (bool, bool) -> bool;
export fn nor "norbool" :: (bool, bool) -> bool;
export fn xnor "xnorbool" :: (bool, bool) -> bool;
export fn eq "eqbool" :: (bool, bool) -> bool;
export fn neq "neqbool" :: (bool, bool) -> bool;
export fn if{T} "ifbool" :: (bool, () -> T, () -> T) -> T;
export fn if{T}(c: bool, t: () -> T) -> Maybe{T} = if(c, fn () -> Maybe{T} = Maybe{T}(t()), fn () -> Maybe{T} = Maybe{T}());
export fn if{T}(c: bool, t: T, f: T) -> T = if(c, fn () -> T = t, fn () -> T = f);
export fn if{T}(c: bool, t: T) -> Maybe{T} = if(c, fn () -> Maybe{T} = Maybe{T}(t), fn () -> Maybe{T} = Maybe{T}());

/// Array related bindings
export fn get{T} "getarray" :: (T[], i64) -> T?;
export fn len{T} "lenarray" :: T[] -> i64;
export fn push{T} "pusharray" :: (T[], T);
export fn pop{T} "poparray" :: T[] -> T?;
export fn map{T, U} "map_onearg" :: (T[], T -> U) -> U[];
export fn map{T, U} "map_twoarg" :: (T[], (T, i64) -> U) -> U[];
export fn parmap{T, U} "parmap_onearg" :: (T[], T -> U) -> U[];
export fn filter{T} "filter_onearg" :: (T[], T -> bool) -> T[];
export fn filter{T} "filter_twoarg" :: (T[], (T, i64) -> bool) -> T[];
export fn reduce{T} "reduce_sametype" :: (T[], (T, T) -> T) -> T?;
export fn reduce{T} "reduce_sametype_idx" :: (T[], (T, T, i64) -> T) -> T?;
export fn reduce{T, U} "reduce_difftype" :: (T[], U, (U, T) -> U) -> U;
export fn reduce{T, U} "reduce_difftype_idx" :: (T[], U, (U, T, i64) -> U) -> U;
export fn concat{T} "concat" :: (T[], T[]) -> T[];
export fn append{T} "append" :: (T[], T[]);
export fn filled{T} "filled" :: (T, i64) -> T[];
export fn has{T} "hasarray" :: (T[], T) -> bool;
export fn has{T} "hasfnarray" :: (T[], T -> bool) -> bool;
export fn find{T} "findarray" :: (T[], T -> bool) -> T?;
// TODO: The `if` syntactic sugar will make these `if` calls much nicer (though so would return
// type inference, to be honest)
export fn index{T}(a: Array{T}, v: T) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    out,
    if(val.eq(v), Maybe(idx), out)));
export fn index{T}(a: Array{T}, f: (T) -> bool) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    out,
    if(f(val), idx)));
export fn index{T}(a: Array{T}, f: (T, i64) -> bool) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    out,
    if(f(val, idx), idx)));
export fn every{T} "everyarray" :: (T[], T -> bool) -> bool;
export fn some{T} "somearray" :: (T[], T -> bool) -> bool;
export fn repeat{T} "repeatarray" :: (T[], i64) -> T[];
export fn store{T} "storearray" :: (T[], i64, T) -> void!;
export fn delete{T} "deletearray" :: (T[], i64) -> T!;

/// Buffer related bindings
export fn get{T, S} "getbuffer" :: (T[S], i64) -> T?;
export fn len{T, S}(T[S]) -> i64 = {S}();
// TODO: Still something weird with the buffer symbolic syntax, skipping it for map
export fn map{T, S, U} "mapbuffer_onearg" :: (Buffer{T, S}, T -> U) -> Buffer{U, S};
export fn map{T, S, U} "mapbuffer_twoarg" :: (Buffer{T, S}, (T, i64) -> U) -> Buffer{U, S};
export fn reduce{T, S} "reducebuffer_sametype" :: (T[S], (T, T) -> T) -> T?;
export fn reduce{T, S, U} "reducebuffer_difftype" :: (T[S], U, (U, T) -> U) -> U;
export fn has{T, S} "hasbuffer" :: (T[S], T) -> bool;
export fn has{T, S} "hasfnbuffer" :: (T[S], T -> bool) -> bool;
export fn find{T, S} "findbuffer" :: (T[S], T -> bool) -> T?;
export fn every{T, S} "everybuffer" :: (T[S], T -> bool) -> bool;
fn concatInner{T, S, N} "concatbuffer" :: (T[S + N], T[S], T[N]);
export fn concat{T, S, N}(a: Buffer{T, S}, b: Buffer{T, N}) -> Buffer{T, S + N} {
  // I can't bind directly into Rust because Rust can't add const integer type parameters together.
  // It's *theoretically* possible to generate a new Rust function in each case with the required
  // sizes, but it will be really difficult, so I'm implementing this for now with the intent to
  // eventually replace it.
  let o = {T[S + N]}(a[0].getOrExit);
  concatInner(o, a, b);
  return o;
}
// TODO: Be able to resolve explicit integer constant values as the integer type so it can be
// grabbed by the type inference system. For now, repeat for buffers outputs an array, instead.
export fn repeat{T, S} "repeatbuffertoarray" :: (T[S], i64) -> T[];
export fn store{T, S} "storebuffer" :: (T[S], i64, T) -> T!;

/// Dictionary-related bindings
export fn Dict{K, V} "newdict" :: () -> Dict{K, V};
export fn Dict{K, V}(k: K, v: V) -> Dict{K, V} {
  let out = Dict{K, V}();
  out.store(k, v);
  return out;
}
export fn Dict{K, V}(a: Array{(K, V)}) -> Dict{K, V} = a.reduce(Dict{K, V}(), fn (d: Dict{K, V}, v: (K, V)) -> Dict{K, V} {
  d.store(v.0, v.1);
  return d;
});
export fn store{K, V} "storedict" :: (Dict{K, V}, K, V);
export fn get{K, V} "getdict" :: (Dict{K, V}, K) -> V?;
export fn has{K, V} "hasdict" :: (Dict{K, V}, K) -> bool;
export fn len{K, V} "lendict" :: Dict{K, V} -> i64;
export fn keys{K, V} "keysdict" :: Dict{K, V} -> K[];
export fn vals{K, V} "valsdict" :: Dict{K, V} -> V[];
export fn Array{K, V} "arraydict" :: Dict{K, V} -> (K, V)[];
export fn concat{K, V} "concatdict" :: (Dict{K, V}, Dict{K, V}) -> Dict{K, V};

/// Set-related bindings
export fn Set{V} "newset" :: () -> Set{V};
export fn Set{V}(a: Array{V}) -> Set{V} = a.reduce(Set{V}(), fn (s: Set{V}, v: V) -> Set{V} {
  s.store(v);
  return s;
});
export fn Set{V}(v: V) -> Set{V} {
  let out = Set{V}();
  out.store(v);
  return out;
}
export fn store{V} "storeset" :: (Set{V}, V);
export fn has{V} "hasset" :: (Set{V}, V) -> bool;
export fn len{V} "lenset" :: Set{V} -> i64;
export fn Array{V} "arrayset" :: Set{V} -> V[];
export fn union{V} "unionset" :: (Set{V}, Set{V}) -> Set{V};
export fn or{V}(a: Set{V}, b: Set{V}) -> Set{V} = union(a, b);
export fn intersect{V} "intersectset" :: (Set{V}, Set{V}) -> Set{V};
export fn and{V}(a: Set{V}, b: Set{V}) -> Set{V} = intersect(a, b);
export fn difference{V} "differenceset" :: (Set{V}, Set{V}) -> Set{V};
export fn div{V}(a: Set{V}, b: Set{V}) -> Set{V} = difference(a, b);
export fn symmetricDifference{V} "symmetric_differenceset" :: (Set{V}, Set{V}) -> Set{V};
export fn xor{V}(a: Set{V}, b: Set{V}) -> Set{V} = symmetricDifference(a, b);
export fn product{V} "productset" :: (Set{V}, Set{V}) -> Set{(V, V)};
export fn mul{V}(a: Set{V}, b: Set{V}) -> Set{(V, V)} = product(a, b);

/// Tree implementation

// The Tree type houses all of the values attached to a tree in an array and two secondary arrays to
// hold the metadata on which value is the parent and which are children, if any. The parent value
// `void` if it has no parent and a positive integer otherwise.
export type Tree{T} =
  vals: Array{T},
  parents: Array{Maybe{i64}},
  children: Array{Array{i64}};

// The Node type simply holds the index to look into the tree for a particular value-parent-children
// triplet, where that index is reffered to as a node ID. This allows node-based code to be written
// while not actually having a recursive data structure that a traditional Node type would defined.
export type Node{T} =
  id: i64,
  tree: Tree{T};

export fn Tree{T}(rootVal: T) -> Tree{T} = Tree{T}(
  Array{T}(rootVal),
  Array{Maybe{i64}}(Maybe{i64}()),
  Array{Array{i64}}(Array{i64}()));
export fn Tree{T}(n: Node{T}) -> Tree{T} = n.tree;

// TODO: This is a more correct solution, but any Tree constructed by us will always have the root
// node be the first element of the array, so we're just doing that so we don't have a `Maybe` here
/*export fn rootNode{T}(t: Tree{T}) -> Maybe{Node{T}} {
  let rootIdx = t.parents.index(Maybe{i64}());
  return if(
    rootIdx.exists,
    fn () -> Node{T} = Node{T}(rootIdx.getOrExit, t)
  );
}*/
export fn rootNode{T}(t: Tree{T}) -> Node{T} = Node{T}(0, t);

export fn len{T}(t: Tree{T}) -> i64 = t.vals.len;

export fn Node{T}(t: Tree{T}, i: i64) -> Maybe{Node{T}} = if(
  t.len.gt(i),
  fn () -> Node{T} = Node{T}(i, t));

export fn parent{T}(n: Node{T}) -> Maybe{Node{T}} {
  let parentId = n.tree.parents[n.id];
  return if(parentId.exists,
    if(parentId.getOrExit.exists,
      fn () -> Node{T} = Node{T}(parentId.getOrExit.getOrExit, n.tree)),
    Maybe{Node{T}}());
}

export fn children{T}(n: Node{T}) -> Array{Node{T}} = if(
  n.tree.len.gt(n.id),
  fn () -> Array{Node{T}} {
    let childIds = n.tree.children[n.id].getOr(Array{i64}());
    return childIds
      .filter(fn (id: i64) -> bool = n.tree.parents[id].getOr(-1).eq(n.id))
      .map(fn (id: i64) -> Node{T} = Node{T}(id, n.tree));
  },
  fn () -> Array{Node{T}} = Array{Node{T}}());

export fn children{T}(t: Tree{T}) -> Array{Node{T}} = t.rootNode.children;

export fn addChild{T}(n: Node{T}, val: T) -> Node{T} {
  let idx = n.tree.len;
  let parentIdx = n.id;
  n.tree.vals.push(val);
  n.tree.parents.push(Maybe{i64}(parentIdx));
  n.tree.children.push(Array{i64}());
  return Node{T}(idx, n.tree);
}
export fn addChild{T}(n: Node{T}, t: Tree{T}) -> Node{T} {
  let idxOffset = n.tree.len;
  let idx = idxOffset.clone(); // TODO: Lower stage of compiler should be doing this
  let parentIdx = n.id;
  n.tree.vals.append(t.vals);
  n.tree.parents.append(t.parents.map(fn (pId: Maybe{i64}) -> Maybe{i64} = if(pId.exists,
    fn () -> Maybe{i64} = Maybe{i64}(pId.getOrExit + idxOffset),
    fn () -> Maybe{i64} = Maybe{i64}(idx))));
  n.tree.children.append(
    t.children.map(
      fn (ids: Array{i64}) -> Array{i64} = ids.map(
        fn (id: i64) -> i64 = id + idxOffset)));
  return Node{T}(idx, n.tree);
}
export fn addChild{T}(t: Tree{T}, val: T) -> Node{T} = t.rootNode.addChild(val);


// TODO: Implement `addChild` when the child is itself a `Node{T}`

// TODO: Implement `prune` to pull a node out of the tree and re-attach its children to its own
// parent.

// TODO: Implement `subtree` to create a new tree consisting of the specified node as its root and
// only its own children as the children of the tree.

export fn getOr{T}(n: Node{T}, default: T) -> T = n.tree.vals[n.id].getOr(default);

export fn Array{T}(t: Tree{T}) -> Array{Node{T}} = t.vals.map(
  fn (_: T, i: i64) -> Node{T} = Node{T}(t, i).getOrExit);

export fn map{T, U}(t: Tree{T}, mapper: (Node{T}) -> Node{U}) -> Tree{U} = Tree{U}(
  t.Array.map(mapper),
  t.parents.clone(),
  t.children.clone());
export fn map{T, U}(t: Tree{T}, mapper: (Node{T}, i64) -> Node{U}) -> Tree{U} = Tree{U}(
  t.Array.map(mapper),
  t.parents,
  t.children);

export fn every{T}(t: Tree{T}, f: (Node{T}) -> bool) -> bool = t.Array.every(f);

export fn some{T}(t: Tree{T}, f: (Node{T}) -> bool) -> bool = t.Array.some(f);

export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}) -> Node{T}) -> Node{T} = t.Array.reduce(f);
export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}, i64) -> Node{T}) -> Node{T} = t.Array.reduce(f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}) -> U) -> U = t.Array.reduce(i, f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}, i64) -> U) -> U = t.Array.reduce(i, f);

export fn find{T}(t: Tree{T}, f: (T) -> bool) -> Maybe{Node{T}} = t.Array.find(f);

/// Process exit-related bindings
export fn ExitCode "to_exit_code" :: u8 -> ExitCode;
export fn ExitCode(e: u16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u64) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i8) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i64) -> ExitCode = ExitCode(e.u8);
export fn getOrExit{T} "get_or_exit" :: T! -> T;
export fn getOrExit{T} "get_or_maybe_exit" :: T? -> T;

/// Thread-related bindings
export fn wait "wait" :: i64;

/// Time-related bindings
export fn now "now" :: () -> Instant;
export fn elapsed "elapsed":: Instant -> Duration;

/// Uuid-related bindings
export fn uuid "uuid::Uuid::new_v4" :: () -> uuid;
export fn string "uuidstring" :: uuid -> string;

/// GPU-related bindings

// The base bindings to create buffers of memory on the GPU, construct a plan for a compute shader,
// execute it, and read the buffer back to the CPU
export type BufferUsages = Binds{"wgpu::BufferUsages"};
export type GBuffer = Binds{"GBuffer"};
export type GPGPU = Binds{"GPGPU"};
export fn mapReadBuffer "map_read_buffer_type" :: () -> BufferUsages;
export fn storageBuffer "storage_buffer_type" :: () -> BufferUsages;
export fn GBuffer "create_buffer_init" :: (BufferUsages, i32[]) -> GBuffer;
export fn GBuffer "create_empty_buffer" :: (BufferUsages, i64) -> GBuffer;
export fn GBuffer(vals: i32[]) -> GBuffer = GBuffer(storageBuffer(), vals);
export fn GBuffer{T}(vals: T[]) -> GBuffer = GBuffer(storageBuffer(), vals.map(fn (v: T) -> i32 = v.i32));
export fn GBuffer(size: i64) -> GBuffer = GBuffer(storageBuffer(), size);
export fn len "bufferlen" :: GBuffer -> i64;
export fn id "buffer_id" :: GBuffer -> string;
export fn GPGPU "GPGPU_new" :: (string, Array{Array{GBuffer}}, i64[3]) -> GPGPU;
export fn GPGPU "GPGPU_new_easy" :: (string, GBuffer) -> GPGPU;
export fn run "gpu_run" :: GPGPU;
export fn read{T} "read_buffer" :: GBuffer -> T[];

// The WgpuType provides a mechanism to build up the logic for a compute shader with normal-looking
// Alan code, not requiring to think in two different languages at the same time. All of the GPU
// types hereafter are derivative of this type
export type WgpuType{N} =
  typeName: N,
  varName: string, // Key to the next field
  statements: Dict{string, string},
  buffers: Set{GBuffer};

// Scalar types and constructors
export type gu32 = WgpuType{"u32"};
export type gi32 = WgpuType{"i32"};
export type gf32 = WgpuType{"f32"};
export type gbool = WgpuType{"bool"};

// TODO: Better constraining on the input types allowed. It will still fail to compile, but the
// error message isn't great at the moment.
export fn build{N}(ret: N) -> GPGPU {
  // TODO: Don't assume all of the buffers involved here are storage buffers
  // Also TODO: Support other buffer types than i32
  let bufferArray = Array{GBuffer}().concat(ret.buffers.Array); // TODO: Shouldn't need this concat
  // let bufferArray = ret.buffers.Array;
  let wgslHeader = bufferArray.map(fn (gb: GBuffer, i: i64) -> string {
    return "@group(0)\n@binding("
      .concat(i.string)
      .concat(")\nvar<storage, read_write> ")
      .concat(gb.id)
      .concat(": array<i32>;\n");
  }).join("\n");
  let wgslFunctionHeader = "@compute\n@workgroup_size(1)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n";
  let wgslFunctionBody = ret.statements.Array.map(fn (kv: (string, string)) -> string {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () -> string = "", fn () -> string {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let wgsl = wgslHeader.concat(wgslFunctionHeader).concat(wgslFunctionBody).concat("}");
  let maxGlobalIdArray = ret
    .statements['@builtin(global_invocation_id) id: vec3u']
    .getOr('0,0,0')
    .split(',')
    .map(fn (s: string) -> i64 = s.i64.getOr(0));
  let maxGlobalId = {i64[3]}(
    maxGlobalIdArray[0].getOr(0),
    maxGlobalIdArray[1].getOr(0),
    maxGlobalIdArray[2].getOr(0)
  );
  let buffers = Array{Array{GBuffer}}();
  buffers.push(bufferArray);
  return GPGPU(wgsl, buffers, maxGlobalId);
}

fn gPrimitiveConvert{I, O}(i: I) -> O {
  let typename = {O.typeName}();
  let varName = typename.concat('_').concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(typename)
    .concat('(')
    .concat(i.varName)
    .concat(')');
  let statements = i.statements.clone().concat(Dict(varName, statement));
  let buffers = i.buffers.clone();
  return {O}(varName, statements, buffers);
}
export fn gu32(u: u32) -> gu32 = gu32(u.string, Dict{string, string}(), Set{GBuffer}());
export fn gu32(gi: gi32) -> gu32 = gPrimitiveConvert{gi32, gu32}(gi);
export fn gu32(gf: gf32) -> gu32 = gPrimitiveConvert{gf32, gu32}(gf);
export fn gu32(gb: gbool) -> gu32 = gPrimitiveConvert{gbool, gu32}(gb);
export fn gu32{T}(u: T) -> gu32 = gu32(u.u32);

export fn gi32(i: i32) -> gi32 = gi32(i.string, Dict{string, string}(), Set{GBuffer}());
export fn gi32(gu: gu32) -> gi32 = gPrimitiveConvert{gu32, gi32}(gu);
export fn gi32(gf: gf32) -> gi32 = gPrimitiveConvert{gf32, gi32}(gf);
export fn gi32(gb: gbool) -> gi32 = gPrimitiveConvert{gbool, gi32}(gb);
export fn gi32{T}(i: T) -> gi32 = gi32(i.i32);

export fn gf32(f: f32) -> gf32 = gf32(f.string, Dict{string, string}(), Set{GBuffer}());
export fn gf32(gu: gu32) -> gf32 = gPrimitiveConvert{gu32, gf32}(gu);
export fn gf32(gi: gi32) -> gf32 = gPrimitiveConvert{gi32, gf32}(gi);
export fn gf32(gb: gbool) -> gf32 = gPrimitiveConvert{gbool, gf32}(gb);
export fn gf32{T}(f: T) -> gf32 = gf32(f.f32);

export fn gbool(b: bool) -> gbool = gbool(b.string, Dict{string, string}(), Set{GBuffer}());
export fn gbool(gu: gu32) -> gbool = gPrimitiveConvert{gu32, gbool}(gu);
export fn gbool(gi: gi32) -> gbool = gPrimitiveConvert{gi32, gbool}(gi);
export fn gbool(gf: gf32) -> gbool = gPrimitiveConvert{gf32, gbool}(gf);
export fn gbool{T}(b: T) -> gbool = gbool(b.bool);

// Vector types and constructors
export type gvec2u = WgpuType{"vec2u"};
export type gvec2i = WgpuType{"vec2i"};
export type gvec2f = WgpuType{"vec2f"};
export type gvec2b = WgpuType{"vec2<bool>"};
export type gvec3u = WgpuType{"vec3u"};
export type gvec3i = WgpuType{"vec3i"};
export type gvec3f = WgpuType{"vec3f"};
export type gvec3b = WgpuType{"vec3<bool>"};
export type gvec4u = WgpuType{"vec4u"};
export type gvec4i = WgpuType{"vec4i"};
export type gvec4f = WgpuType{"vec4f"};
export type gvec4b = WgpuType{"vec4<bool>"};

fn gvec2Primitive{I, O}(a: I, b: I) -> O {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(statement, statements, buffers);
}

export fn gvec2u() -> gvec2u = gvec2u("vec2u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2u(a: gu32, b: gu32) -> gvec2u = gvec2Primitive{gu32, gvec2u}(a, b);
export fn gvec2u{T}(a: T, b: T) -> gvec2u = gvec2u(a.gu32, b.gu32);

export fn gvec2i() -> gvec2i = gvec2i("vec2i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2i(a: gi32, b: gi32) -> gvec2i = gvec2Primitive{gi32, gvec2i}(a, b);
export fn gvec2i{T}(a: T, b: T) -> gvec2i = gvec2i(a.gi32, b.gi32);

export fn gvec2f() -> gvec2f = gvec2f("vec2f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2f(a: gf32, b: gf32) -> gvec2f = gvec2Primitive{gf32, gvec2f}(a, b);
export fn gvec2f{T}(a: T, b: T) -> gvec2f = gvec2f(a.gf32, b.gf32);

export fn gvec2b() -> gvec2b = gvec2b("vec2<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2b(a: gbool, b: gbool) -> gvec2b = gvec2Primitive{gbool, gvec2b}(a, b);
export fn gvec2b{T}(a: T, b: T) -> gvec2b = gvec2b(a.gbool, b.gbool);

fn gvec3Primitive{I, O}(a: I, b: I, c: I) -> O {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return {O}(statement, statements, buffers);
}

export fn gvec3u() -> gvec3u = gvec3u("vec3u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3u(a: gu32, b: gu32, c: gu32) -> gvec3u = gvec3Primitive{gu32, gvec3u}(a, b, c);
export fn gvec3u{T}(a: T, b: T, c: T) -> gvec3u = gvec3u(a.gu32, b.gu32, c.gu32);

export fn gvec3i() -> gvec3i = gvec3i("vec3i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3i(a: gi32, b: gi32, c: gi32) -> gvec3i = gvec3Primitive{gi32, gvec3i}(a, b, c);
export fn gvec3i{T}(a: T, b: T, c: T) -> gvec3i = gvec3i(a.gi32, b.gi32, c.gi32);

export fn gvec3f() -> gvec3f = gvec3f("vec3f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3f(a: gf32, b: gf32, c: gf32) -> gvec3f = gvec3Primitive{gf32, gvec3f}(a, b, c);
export fn gvec3f{T}(a: T, b: T, c: T) -> gvec3f = gvec3f(a.gf32, b.gf32, c.gf32);

export fn gvec3b() -> gvec3b = gvec3b("vec3<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3b(a: gbool, b: gbool, c: gbool) -> gvec3b = gvec3Primitive{gbool, gvec3b}(a, b, c);
export fn gvec3b{T}(a: T, b: T, c: T) -> gvec3b = gvec3b(a.gbool, b.gbool, c.gbool);

fn gvec4Primitive{I, O}(a: I, b: I, c: I, d: I) -> O {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return {O}(statement, statements, buffers);
}

export fn gvec4u() -> gvec4u = gvec4u("vec4u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4u(a: gu32, b: gu32, c: gu32, d: gu32) -> gvec4u = gvec4Primitive{gu32, gvec4u}(
  a, b, c, d
);
export fn gvec4u{T}(a: T, b: T, c: T, d: T) -> gvec4u = gvec4u(a.gu32, b.gu32, c.gu32, d.gu32);

export fn gvec4i() -> gvec4i = gvec4i("vec4i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4i(a: gi32, b: gi32, c: gi32, d: gi32) -> gvec4i = gvec4Primitive{gi32, gvec4i}(
  a, b, c, d
);
export fn gvec4i{T}(a: T, b: T, c: T, d: T) -> gvec4i = gvec4i(a.gi32, b.gi32, c.gi32, d.gi32);

export fn gvec4f() -> gvec4f = gvec4f("vec4f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4f(a: gf32, b: gf32, c: gf32, d: gf32) -> gvec4f = gvec4Primitive{gf32, gvec4f}(
  a, b, c, d
);
export fn gvec4f{T}(a: T, b: T, c: T, d: T) -> gvec4f = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);

export fn gvec4b() -> gvec4b = gvec4b("vec4<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4b(a: gbool, b: gbool, c: gbool, d: gbool) -> gvec4b = gvec4Primitive{gbool, gvec4b}(
  a, b, c, d
);
export fn gvec4b{T}(a: T, b: T, c: T, d: T) -> gvec4b = gvec4b(a.gbool, b.gbool, c.gbool, d.gbool);

// The global_invocation_id; the entry value to a compute shader, and it's constructor, a
// specialized version of gvec3u that initializes a bit differently.
export fn gFor(x: u32, y: u32, z: u32) -> gvec3u {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',').concat(z.string));
  return gvec3u('id', statements, Set{GBuffer}());
}
export fn gFor{T}(x: T, y: T, z: T) -> gvec3u = gFor(x.u32, y.u32, z.u32);
export fn gFor{T}(x: T, y: T) -> gvec3u = gFor(x.u32, y.u32, 1.u32);
export fn gFor{T}(x: T) -> gu32 = gFor(x.u32, 1.u32, 1.u32).x;

// Matrix types
export type gmat2x2f = WgpuType{"mat2x2f"};
export type gmat2x3f = WgpuType{"mat2x3f"};
export type gmat2x4f = WgpuType{"mat2x4f"};
export type gmat3x2f = WgpuType{"mat3x2f"};
export type gmat3x3f = WgpuType{"mat3x3f"};
export type gmat3x4f = WgpuType{"mat3x4f"};
export type gmat4x2f = WgpuType{"mat4x2f"};
export type gmat4x3f = WgpuType{"mat4x3f"};
export type gmat4x4f = WgpuType{"mat4x4f"};

export fn gmat2x2f() -> gmat2x2f = gmat2x2f("mat2x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x2f(a: gvec2f, b: gvec2f) -> gmat2x2f {
  let statement = "mat2x2f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(statement, statements, buffers);
}
export fn gmat2x2f(a: gf32, b: gf32, c: gf32, d: gf32) -> gmat2x2f {
  let statement = "mat2x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat2x2f(statement, statements, buffers);
}

export fn gmat2x3f() -> gmat2x3f = gmat2x3f("mat2x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x3f(a: gvec3f, b: gvec3f) -> gmat2x3f {
  let statement = "mat2x3f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(statement, statements, buffers);
}
export fn gmat2x3f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) -> gmat2x3f {
  let statement = "mat2x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat2x3f(statement, statements, buffers);
}

export fn gmat2x4f() -> gmat2x4f = gmat2x4f("mat2x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x4f(a: gvec4f, b: gvec4f) -> gmat2x4f {
  let statement = "mat2x4f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(statement, statements, buffers);
}
export fn gmat2x4f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32) -> gmat2x4f {
  let statement = "mat2x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat2x4f(statement, statements, buffers);
}

export fn gmat3x2f() -> gmat3x2f = gmat3x2f("mat3x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x2f(a: gvec2f, b: gvec2f, c: gvec2f) -> gmat3x2f {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x2f(statement, statements, buffers);
}
export fn gmat3x2f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) -> gmat3x2f {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat3x2f(statement, statements, buffers);
}

export fn gmat3x3f() -> gmat3x3f = gmat3x3f("mat3x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x3f(a: gvec3f, b: gvec3f, c: gvec3f) -> gmat3x3f {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x3f(statement, statements, buffers);
}
export fn gmat3x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32
) -> gmat3x3f {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers);
  return gmat3x3f(statement, statements, buffers);
}

export fn gmat3x4f() -> gmat3x4f = gmat3x4f("mat3x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x4f(a: gvec4f, b: gvec4f, c: gvec4f) -> gmat3x4f {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x4f(statement, statements, buffers);
}
export fn gmat3x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) -> gmat3x4f {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat3x4f(statement, statements, buffers);
}

export fn gmat4x2f() -> gmat4x2f = gmat4x2f("mat4x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x2f(a: gvec2f, b: gvec2f, c: gvec2f, d: gvec2f) -> gmat4x2f {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x2f(statement, statements, buffers);
}
export fn gmat4x2f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32
) -> gmat4x2f {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat4x2f(statement, statements, buffers);
}

export fn gmat4x3f() -> gmat4x3f = gmat4x3f("mat4x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x3f(a: gvec3f, b: gvec3f, c: gvec3f, d: gvec3f) -> gmat4x3f {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x3f(statement, statements, buffers);
}
export fn gmat4x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) -> gmat4x3f {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat4x3f(statement, statements, buffers);
}

export fn gmat4x4f() -> gmat4x4f = gmat4x4f("mat4x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x4f(a: gvec4f, b: gvec4f, c: gvec4f, d: gvec4f) -> gmat4x4f {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x4f(statement, statements, buffers);
}
export fn gmat4x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32,
  m: gf32,
  n: gf32,
  o: gf32,
  p: gf32
) -> gmat4x4f {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(", ")
    .concat(m.varName)
    .concat(", ")
    .concat(n.varName)
    .concat(", ")
    .concat(o.varName)
    .concat(", ")
    .concat(p.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements)
    .concat(m.statements)
    .concat(n.statements)
    .concat(o.statements)
    .concat(p.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers)
    .union(m.buffers)
    .union(n.buffers)
    .union(o.buffers)
    .union(p.buffers);
  return gmat4x4f(statement, statements, buffers);
}

// TODO: Fixed-length buffers within wgsl

// TODO: How to handle structs?

// GPU Type accessors

export fn x(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2u) -> gu32 = v.x;
export fn j(v: gvec2u) -> gu32 = v.y;
export fn r(v: gvec2u) -> gu32 = v.x;
export fn g(v: gvec2u) -> gu32 = v.y;

fn gvec22u(v: gvec2u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2u) -> gvec2u = gvec22u(v, '.xy');
export fn yx(v: gvec2u) -> gvec2u = gvec22u(v, '.yx');
export fn ij(v: gvec2u) -> gvec2u = v.xy;
export fn ji(v: gvec2u) -> gvec2u = v.yx;
export fn rg(v: gvec2u) -> gvec2u = v.xy;
export fn gr(v: gvec2u) -> gvec2u = v.yx;

export fn x(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2i) -> gi32 = v.x;
export fn j(v: gvec2i) -> gi32 = v.y;
export fn r(v: gvec2i) -> gi32 = v.x;
export fn g(v: gvec2i) -> gi32 = v.y;

fn gvec22i(v: gvec2i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2i) -> gvec2i = gvec22i(v, '.xy');
export fn yx(v: gvec2i) -> gvec2i = gvec22i(v, '.yx');
export fn ij(v: gvec2i) -> gvec2i = v.xy;
export fn ji(v: gvec2i) -> gvec2i = v.yx;
export fn rg(v: gvec2i) -> gvec2i = v.xy;
export fn gr(v: gvec2i) -> gvec2i = v.yx;

export fn x(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2f) -> gf32 = v.x;
export fn j(v: gvec2f) -> gf32 = v.y;
export fn r(v: gvec2f) -> gf32 = v.x;
export fn g(v: gvec2f) -> gf32 = v.y;

fn gvec22f(v: gvec2f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2f) -> gvec2f = gvec22f(v, '.xy');
export fn yx(v: gvec2f) -> gvec2f = gvec22f(v, '.yx');
export fn ij(v: gvec2f) -> gvec2f = v.xy;
export fn ji(v: gvec2f) -> gvec2f = v.yx;
export fn rg(v: gvec2f) -> gvec2f = v.xy;
export fn gr(v: gvec2f) -> gvec2f = v.yx;

export fn x(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec2b) -> gbool = v.x;
export fn j(v: gvec2b) -> gbool = v.y;
export fn r(v: gvec2b) -> gbool = v.x;
export fn g(v: gvec2b) -> gbool = v.y;

fn gvec22b(v: gvec2b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2b) -> gvec2b = gvec22b(v, '.xy');
export fn yx(v: gvec2b) -> gvec2b = gvec22b(v, '.yx');
export fn ij(v: gvec2b) -> gvec2b = v.xy;
export fn ji(v: gvec2b) -> gvec2b = v.yx;
export fn rg(v: gvec2b) -> gvec2b = v.xy;
export fn gr(v: gvec2b) -> gvec2b = v.yx;

export fn x(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3u) -> gu32 = v.x;
export fn j(v: gvec3u) -> gu32 = v.y;
export fn k(v: gvec3u) -> gu32 = v.z;
export fn r(v: gvec3u) -> gu32 = v.x;
export fn g(v: gvec3u) -> gu32 = v.y;
export fn b(v: gvec3u) -> gu32 = v.z;

fn gvec32u(v: gvec3u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3u) -> gvec2u = gvec32u(v, '.xy');
export fn yx(v: gvec3u) -> gvec2u = gvec32u(v, '.yx');
export fn xz(v: gvec3u) -> gvec2u = gvec32u(v, '.xz');
export fn zx(v: gvec3u) -> gvec2u = gvec32u(v, '.zx');
export fn yz(v: gvec3u) -> gvec2u = gvec32u(v, '.yz');
export fn zy(v: gvec3u) -> gvec2u = gvec32u(v, '.zy');
export fn ij(v: gvec3u) -> gvec2u = v.xy;
export fn ji(v: gvec3u) -> gvec2u = v.yx;
export fn ik(v: gvec3u) -> gvec2u = v.xz;
export fn ki(v: gvec3u) -> gvec2u = v.zx;
export fn jk(v: gvec3u) -> gvec2u = v.yz;
export fn kj(v: gvec3u) -> gvec2u = v.zy;
export fn rg(v: gvec3u) -> gvec2u = v.xy;
export fn gr(v: gvec3u) -> gvec2u = v.yx;
export fn rb(v: gvec3u) -> gvec2u = v.xz;
export fn br(v: gvec3u) -> gvec2u = v.zx;
export fn gb(v: gvec3u) -> gvec2u = v.yz;
export fn bg(v: gvec3u) -> gvec2u = v.zy;

fn gvec33u(v: gvec3u, a: string) -> gvec3u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3u) -> gvec3u = gvec33u(v, '.xyz');
export fn xzy(v: gvec3u) -> gvec3u = gvec33u(v, '.xzy');
export fn yxz(v: gvec3u) -> gvec3u = gvec33u(v, '.yxz');
export fn yzx(v: gvec3u) -> gvec3u = gvec33u(v, '.yzx');
export fn zxy(v: gvec3u) -> gvec3u = gvec33u(v, '.zxy');
export fn zyx(v: gvec3u) -> gvec3u = gvec33u(v, '.zyx');
export fn ijk(v: gvec3u) -> gvec3u = v.xyz;
export fn ikj(v: gvec3u) -> gvec3u = v.xzy;
export fn jik(v: gvec3u) -> gvec3u = v.yxz;
export fn jki(v: gvec3u) -> gvec3u = v.yzx;
export fn kij(v: gvec3u) -> gvec3u = v.zxy;
export fn kji(v: gvec3u) -> gvec3u = v.zyx;
export fn rgb(v: gvec3u) -> gvec3u = v.xyz;
export fn rbg(v: gvec3u) -> gvec3u = v.xzy;
export fn grb(v: gvec3u) -> gvec3u = v.yxz;
export fn gbr(v: gvec3u) -> gvec3u = v.yzx;
export fn brg(v: gvec3u) -> gvec3u = v.zxy;
export fn bgr(v: gvec3u) -> gvec3u = v.zyx;

export fn x(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3i) -> gi32 = v.x;
export fn j(v: gvec3i) -> gi32 = v.y;
export fn k(v: gvec3i) -> gi32 = v.z;
export fn r(v: gvec3i) -> gi32 = v.x;
export fn g(v: gvec3i) -> gi32 = v.y;
export fn b(v: gvec3i) -> gi32 = v.z;

fn gvec32i(v: gvec3i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3i) -> gvec2i = gvec32i(v, '.xy');
export fn yx(v: gvec3i) -> gvec2i = gvec32i(v, '.yx');
export fn xz(v: gvec3i) -> gvec2i = gvec32i(v, '.xz');
export fn zx(v: gvec3i) -> gvec2i = gvec32i(v, '.zx');
export fn yz(v: gvec3i) -> gvec2i = gvec32i(v, '.yz');
export fn zy(v: gvec3i) -> gvec2i = gvec32i(v, '.zy');
export fn ij(v: gvec3i) -> gvec2i = v.xy;
export fn ji(v: gvec3i) -> gvec2i = v.yx;
export fn ik(v: gvec3i) -> gvec2i = v.xz;
export fn ki(v: gvec3i) -> gvec2i = v.zx;
export fn jk(v: gvec3i) -> gvec2i = v.yz;
export fn kj(v: gvec3i) -> gvec2i = v.zy;
export fn rg(v: gvec3i) -> gvec2i = v.xy;
export fn gr(v: gvec3i) -> gvec2i = v.yx;
export fn rb(v: gvec3i) -> gvec2i = v.xz;
export fn br(v: gvec3i) -> gvec2i = v.zx;
export fn gb(v: gvec3i) -> gvec2i = v.yz;
export fn bg(v: gvec3i) -> gvec2i = v.zy;

fn gvec33i(v: gvec3i, a: string) -> gvec3i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3i) -> gvec3i = gvec33i(v, '.xyz');
export fn xzy(v: gvec3i) -> gvec3i = gvec33i(v, '.xzy');
export fn yxz(v: gvec3i) -> gvec3i = gvec33i(v, '.yxz');
export fn yzx(v: gvec3i) -> gvec3i = gvec33i(v, '.yzx');
export fn zxy(v: gvec3i) -> gvec3i = gvec33i(v, '.zxy');
export fn zyx(v: gvec3i) -> gvec3i = gvec33i(v, '.zyx');
export fn ijk(v: gvec3i) -> gvec3i = v.xyz;
export fn ikj(v: gvec3i) -> gvec3i = v.xzy;
export fn jik(v: gvec3i) -> gvec3i = v.yxz;
export fn jki(v: gvec3i) -> gvec3i = v.yzx;
export fn kij(v: gvec3i) -> gvec3i = v.zxy;
export fn kji(v: gvec3i) -> gvec3i = v.zyx;
export fn rgb(v: gvec3i) -> gvec3i = v.xyz;
export fn rbg(v: gvec3i) -> gvec3i = v.xzy;
export fn grb(v: gvec3i) -> gvec3i = v.yxz;
export fn gbr(v: gvec3i) -> gvec3i = v.yzx;
export fn brg(v: gvec3i) -> gvec3i = v.zxy;
export fn bgr(v: gvec3i) -> gvec3i = v.zyx;

export fn x(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3f) -> gf32 = v.x;
export fn j(v: gvec3f) -> gf32 = v.y;
export fn k(v: gvec3f) -> gf32 = v.z;
export fn r(v: gvec3f) -> gf32 = v.x;
export fn g(v: gvec3f) -> gf32 = v.y;
export fn b(v: gvec3f) -> gf32 = v.z;

fn gvec32f(v: gvec3f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3f) -> gvec2f = gvec32f(v, '.xy');
export fn yx(v: gvec3f) -> gvec2f = gvec32f(v, '.yx');
export fn xz(v: gvec3f) -> gvec2f = gvec32f(v, '.xz');
export fn zx(v: gvec3f) -> gvec2f = gvec32f(v, '.zx');
export fn yz(v: gvec3f) -> gvec2f = gvec32f(v, '.yz');
export fn zy(v: gvec3f) -> gvec2f = gvec32f(v, '.zy');
export fn ij(v: gvec3f) -> gvec2f = v.xy;
export fn ji(v: gvec3f) -> gvec2f = v.yx;
export fn ik(v: gvec3f) -> gvec2f = v.xz;
export fn ki(v: gvec3f) -> gvec2f = v.zx;
export fn jk(v: gvec3f) -> gvec2f = v.yz;
export fn kj(v: gvec3f) -> gvec2f = v.zy;
export fn rg(v: gvec3f) -> gvec2f = v.xy;
export fn gr(v: gvec3f) -> gvec2f = v.yx;
export fn rb(v: gvec3f) -> gvec2f = v.xz;
export fn br(v: gvec3f) -> gvec2f = v.zx;
export fn gb(v: gvec3f) -> gvec2f = v.yz;
export fn bg(v: gvec3f) -> gvec2f = v.zy;

fn gvec33f(v: gvec3f, a: string) -> gvec3f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3f) -> gvec3f = gvec33f(v, '.xyz');
export fn xzy(v: gvec3f) -> gvec3f = gvec33f(v, '.xzy');
export fn yxz(v: gvec3f) -> gvec3f = gvec33f(v, '.yxz');
export fn yzx(v: gvec3f) -> gvec3f = gvec33f(v, '.yzx');
export fn zxy(v: gvec3f) -> gvec3f = gvec33f(v, '.zxy');
export fn zyx(v: gvec3f) -> gvec3f = gvec33f(v, '.zyx');
export fn ijk(v: gvec3f) -> gvec3f = v.xyz;
export fn ikj(v: gvec3f) -> gvec3f = v.xzy;
export fn jik(v: gvec3f) -> gvec3f = v.yxz;
export fn jki(v: gvec3f) -> gvec3f = v.yzx;
export fn kij(v: gvec3f) -> gvec3f = v.zxy;
export fn kji(v: gvec3f) -> gvec3f = v.zyx;
export fn rgb(v: gvec3f) -> gvec3f = v.xyz;
export fn rbg(v: gvec3f) -> gvec3f = v.xzy;
export fn grb(v: gvec3f) -> gvec3f = v.yxz;
export fn gbr(v: gvec3f) -> gvec3f = v.yzx;
export fn brg(v: gvec3f) -> gvec3f = v.zxy;
export fn bgr(v: gvec3f) -> gvec3f = v.zyx;

export fn x(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec3b) -> gbool = v.x;
export fn j(v: gvec3b) -> gbool = v.y;
export fn k(v: gvec3b) -> gbool = v.z;
export fn r(v: gvec3b) -> gbool = v.x;
export fn g(v: gvec3b) -> gbool = v.y;
export fn b(v: gvec3b) -> gbool = v.z;

fn gvec32b(v: gvec3b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3b) -> gvec2b = gvec32b(v, '.xy');
export fn yx(v: gvec3b) -> gvec2b = gvec32b(v, '.yx');
export fn xz(v: gvec3b) -> gvec2b = gvec32b(v, '.xz');
export fn zx(v: gvec3b) -> gvec2b = gvec32b(v, '.zx');
export fn yz(v: gvec3b) -> gvec2b = gvec32b(v, '.yz');
export fn zy(v: gvec3b) -> gvec2b = gvec32b(v, '.zy');
export fn ij(v: gvec3b) -> gvec2b = v.xy;
export fn ji(v: gvec3b) -> gvec2b = v.yx;
export fn ik(v: gvec3b) -> gvec2b = v.xz;
export fn ki(v: gvec3b) -> gvec2b = v.zx;
export fn jk(v: gvec3b) -> gvec2b = v.yz;
export fn kj(v: gvec3b) -> gvec2b = v.zy;
export fn rg(v: gvec3b) -> gvec2b = v.xy;
export fn gr(v: gvec3b) -> gvec2b = v.yx;
export fn rb(v: gvec3b) -> gvec2b = v.xz;
export fn br(v: gvec3b) -> gvec2b = v.zx;
export fn gb(v: gvec3b) -> gvec2b = v.yz;
export fn bg(v: gvec3b) -> gvec2b = v.zy;

fn gvec33b(v: gvec3b, a: string) -> gvec3b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3b) -> gvec3b = gvec33b(v, '.xyz');
export fn xzy(v: gvec3b) -> gvec3b = gvec33b(v, '.xzy');
export fn yxz(v: gvec3b) -> gvec3b = gvec33b(v, '.yxz');
export fn yzx(v: gvec3b) -> gvec3b = gvec33b(v, '.yzx');
export fn zxy(v: gvec3b) -> gvec3b = gvec33b(v, '.zxy');
export fn zyx(v: gvec3b) -> gvec3b = gvec33b(v, '.zyx');
export fn ijk(v: gvec3b) -> gvec3b = v.xyz;
export fn ikj(v: gvec3b) -> gvec3b = v.xzy;
export fn jik(v: gvec3b) -> gvec3b = v.yxz;
export fn jki(v: gvec3b) -> gvec3b = v.yzx;
export fn kij(v: gvec3b) -> gvec3b = v.zxy;
export fn kji(v: gvec3b) -> gvec3b = v.zyx;
export fn rgb(v: gvec3b) -> gvec3b = v.xyz;
export fn rbg(v: gvec3b) -> gvec3b = v.xzy;
export fn grb(v: gvec3b) -> gvec3b = v.yxz;
export fn gbr(v: gvec3b) -> gvec3b = v.yzx;
export fn brg(v: gvec3b) -> gvec3b = v.zxy;
export fn bgr(v: gvec3b) -> gvec3b = v.zyx;

export fn x(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.w');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4u) -> gu32 = v.x;
export fn j(v: gvec4u) -> gu32 = v.y;
export fn k(v: gvec4u) -> gu32 = v.z;
export fn l(v: gvec4u) -> gu32 = v.w;
export fn r(v: gvec4u) -> gu32 = v.x;
export fn g(v: gvec4u) -> gu32 = v.y;
export fn b(v: gvec4u) -> gu32 = v.z;
export fn a(v: gvec4u) -> gu32 = v.w;

fn gvec42u(v: gvec4u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4u) -> gvec2u = gvec42u(v, '.xy');
export fn yx(v: gvec4u) -> gvec2u = gvec42u(v, '.yx');
export fn xz(v: gvec4u) -> gvec2u = gvec42u(v, '.xz');
export fn zx(v: gvec4u) -> gvec2u = gvec42u(v, '.zx');
export fn xw(v: gvec4u) -> gvec2u = gvec42u(v, '.xw');
export fn wx(v: gvec4u) -> gvec2u = gvec42u(v, '.wx');
export fn yz(v: gvec4u) -> gvec2u = gvec42u(v, '.yz');
export fn zy(v: gvec4u) -> gvec2u = gvec42u(v, '.zy');
export fn yw(v: gvec4u) -> gvec2u = gvec42u(v, '.yw');
export fn wy(v: gvec4u) -> gvec2u = gvec42u(v, '.wy');
export fn zw(v: gvec4u) -> gvec2u = gvec42u(v, '.zw');
export fn wz(v: gvec4u) -> gvec2u = gvec42u(v, '.wz');
export fn ij(v: gvec4u) -> gvec2u = v.xy;
export fn ji(v: gvec4u) -> gvec2u = v.yx;
export fn ik(v: gvec4u) -> gvec2u = v.xz;
export fn ki(v: gvec4u) -> gvec2u = v.zx;
export fn il(v: gvec4u) -> gvec2u = v.xw;
export fn li(v: gvec4u) -> gvec2u = v.wx;
export fn jk(v: gvec4u) -> gvec2u = v.yz;
export fn kj(v: gvec4u) -> gvec2u = v.zy;
export fn jl(v: gvec4u) -> gvec2u = v.yw;
export fn lj(v: gvec4u) -> gvec2u = v.wy;
export fn kl(v: gvec4u) -> gvec2u = v.zw;
export fn lk(v: gvec4u) -> gvec2u = v.wz;
export fn rg(v: gvec4u) -> gvec2u = v.xy;
export fn gr(v: gvec4u) -> gvec2u = v.yx;
export fn rb(v: gvec4u) -> gvec2u = v.xz;
export fn br(v: gvec4u) -> gvec2u = v.zx;
export fn ra(v: gvec4u) -> gvec2u = v.xw;
export fn ar(v: gvec4u) -> gvec2u = v.wx;
export fn gb(v: gvec4u) -> gvec2u = v.yz;
export fn bg(v: gvec4u) -> gvec2u = v.zy;
export fn ga(v: gvec4u) -> gvec2u = v.yw;
export fn ag(v: gvec4u) -> gvec2u = v.wy;
export fn ba(v: gvec4u) -> gvec2u = v.zw;
export fn ab(v: gvec4u) -> gvec2u = v.wz;

fn gvec43u(v: gvec4u, a: string) -> gvec3u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4u) -> gvec3u = gvec43u(v, '.xyz'); // 123
export fn xyw(v: gvec4u) -> gvec3u = gvec43u(v, '.xyw'); // 124
export fn xzy(v: gvec4u) -> gvec3u = gvec43u(v, '.xzy'); // 132
export fn xzw(v: gvec4u) -> gvec3u = gvec43u(v, '.xzw'); // 134
export fn xwy(v: gvec4u) -> gvec3u = gvec43u(v, '.xwy'); // 142
export fn xwz(v: gvec4u) -> gvec3u = gvec43u(v, '.xwz'); // 143
export fn yxz(v: gvec4u) -> gvec3u = gvec43u(v, '.yxz'); // 213
export fn yxw(v: gvec4u) -> gvec3u = gvec43u(v, '.yxw'); // 214
export fn yzx(v: gvec4u) -> gvec3u = gvec43u(v, '.yzx'); // 231
export fn yzw(v: gvec4u) -> gvec3u = gvec43u(v, '.yzw'); // 234
export fn ywx(v: gvec4u) -> gvec3u = gvec43u(v, '.ywx'); // 241
export fn ywz(v: gvec4u) -> gvec3u = gvec43u(v, '.ywz'); // 243
export fn zxy(v: gvec4u) -> gvec3u = gvec43u(v, '.zxy'); // 312
export fn zxw(v: gvec4u) -> gvec3u = gvec43u(v, '.zxw'); // 314
export fn zyx(v: gvec4u) -> gvec3u = gvec43u(v, '.zyx'); // 321
export fn zyw(v: gvec4u) -> gvec3u = gvec43u(v, '.zyw'); // 324
export fn zwx(v: gvec4u) -> gvec3u = gvec43u(v, '.zwx'); // 341
export fn zwy(v: gvec4u) -> gvec3u = gvec43u(v, '.zwy'); // 342
export fn wxy(v: gvec4u) -> gvec3u = gvec43u(v, '.wxy'); // 412
export fn wxz(v: gvec4u) -> gvec3u = gvec43u(v, '.wxz'); // 413
export fn wyx(v: gvec4u) -> gvec3u = gvec43u(v, '.wyx'); // 421
export fn wyz(v: gvec4u) -> gvec3u = gvec43u(v, '.wyz'); // 423
export fn wzx(v: gvec4u) -> gvec3u = gvec43u(v, '.wzx'); // 431
export fn wzy(v: gvec4u) -> gvec3u = gvec43u(v, '.wzy'); // 432
export fn ijk(v: gvec4u) -> gvec3u = v.xyz;
export fn ijl(v: gvec4u) -> gvec3u = v.xyw;
export fn ikj(v: gvec4u) -> gvec3u = v.xzy;
export fn ikl(v: gvec4u) -> gvec3u = v.xzw;
export fn ilj(v: gvec4u) -> gvec3u = v.xwy;
export fn ilk(v: gvec4u) -> gvec3u = v.xwz;
export fn jik(v: gvec4u) -> gvec3u = v.yxz;
export fn jil(v: gvec4u) -> gvec3u = v.yxw;
export fn jki(v: gvec4u) -> gvec3u = v.yzx;
export fn jkl(v: gvec4u) -> gvec3u = v.yzw;
export fn jli(v: gvec4u) -> gvec3u = v.ywx;
export fn jlk(v: gvec4u) -> gvec3u = v.ywz;
export fn kij(v: gvec4u) -> gvec3u = v.zxy;
export fn kil(v: gvec4u) -> gvec3u = v.zxw;
export fn kji(v: gvec4u) -> gvec3u = v.zyx;
export fn kjl(v: gvec4u) -> gvec3u = v.zyw;
export fn kli(v: gvec4u) -> gvec3u = v.zwx;
export fn klj(v: gvec4u) -> gvec3u = v.zwy;
export fn lij(v: gvec4u) -> gvec3u = v.wxy;
export fn lik(v: gvec4u) -> gvec3u = v.wxz;
export fn lji(v: gvec4u) -> gvec3u = v.wyx;
export fn ljk(v: gvec4u) -> gvec3u = v.wyz;
export fn lki(v: gvec4u) -> gvec3u = v.wzx;
export fn lkj(v: gvec4u) -> gvec3u = v.wzy;
export fn rgb(v: gvec4u) -> gvec3u = v.xyz;
export fn rga(v: gvec4u) -> gvec3u = v.xyw;
export fn rbg(v: gvec4u) -> gvec3u = v.xzy;
export fn rba(v: gvec4u) -> gvec3u = v.xzw;
export fn rag(v: gvec4u) -> gvec3u = v.xwy;
export fn rab(v: gvec4u) -> gvec3u = v.xwz;
export fn grb(v: gvec4u) -> gvec3u = v.yxz;
export fn gra(v: gvec4u) -> gvec3u = v.yxw;
export fn gbr(v: gvec4u) -> gvec3u = v.yzx;
export fn gba(v: gvec4u) -> gvec3u = v.yzw;
export fn gar(v: gvec4u) -> gvec3u = v.ywx;
export fn gab(v: gvec4u) -> gvec3u = v.ywz;
export fn brg(v: gvec4u) -> gvec3u = v.zxy;
export fn bra(v: gvec4u) -> gvec3u = v.zxw;
export fn bgr(v: gvec4u) -> gvec3u = v.zyx;
export fn bga(v: gvec4u) -> gvec3u = v.zyw;
export fn bar(v: gvec4u) -> gvec3u = v.zwx;
export fn bag(v: gvec4u) -> gvec3u = v.zwy;
export fn arb(v: gvec4u) -> gvec3u = v.wxy;
export fn arg(v: gvec4u) -> gvec3u = v.wxz;
export fn abr(v: gvec4u) -> gvec3u = v.wyx;
export fn abg(v: gvec4u) -> gvec3u = v.wyz;
export fn agr(v: gvec4u) -> gvec3u = v.wzx;
export fn agb(v: gvec4u) -> gvec3u = v.wzy;

fn gvec44u(v: gvec4u, a: string) -> gvec4u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4u(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4u) -> gvec4u = gvec44u(v, '.xyzw'); // 1234
export fn xywz(v: gvec4u) -> gvec4u = gvec44u(v, '.xywz'); // 1243
export fn xzyw(v: gvec4u) -> gvec4u = gvec44u(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4u) -> gvec4u = gvec44u(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4u) -> gvec4u = gvec44u(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4u) -> gvec4u = gvec44u(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4u) -> gvec4u = gvec44u(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4u) -> gvec4u = gvec44u(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4u) -> gvec4u = gvec44u(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4u) -> gvec4u = gvec44u(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4u) -> gvec4u = gvec44u(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4u) -> gvec4u = gvec44u(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4u) -> gvec4u = gvec44u(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4u) -> gvec4u = gvec44u(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4u) -> gvec4u = gvec44u(v, '.zyxw'); // 3214
export fn zywx(v: gvec4u) -> gvec4u = gvec44u(v, '.zywx'); // 3241
export fn zwxy(v: gvec4u) -> gvec4u = gvec44u(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4u) -> gvec4u = gvec44u(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4u) -> gvec4u = gvec44u(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4u) -> gvec4u = gvec44u(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4u) -> gvec4u = gvec44u(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4u) -> gvec4u = gvec44u(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4u) -> gvec4u = gvec44u(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4u) -> gvec4u = gvec44u(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4u) -> gvec4u = v.xyzw;
export fn ijlk(v: gvec4u) -> gvec4u = v.xywz;
export fn ikjl(v: gvec4u) -> gvec4u = v.xzyw;
export fn iklj(v: gvec4u) -> gvec4u = v.xzwy;
export fn iljk(v: gvec4u) -> gvec4u = v.xwyz;
export fn ilkj(v: gvec4u) -> gvec4u = v.xwzy;
export fn jikl(v: gvec4u) -> gvec4u = v.yxzw;
export fn jilk(v: gvec4u) -> gvec4u = v.yxwz;
export fn jkil(v: gvec4u) -> gvec4u = v.yzxw;
export fn jkli(v: gvec4u) -> gvec4u = v.yzwx;
export fn jlik(v: gvec4u) -> gvec4u = v.ywxz;
export fn jlki(v: gvec4u) -> gvec4u = v.ywzx;
export fn kijl(v: gvec4u) -> gvec4u = v.zxyw;
export fn kilj(v: gvec4u) -> gvec4u = v.zxwy;
export fn kjil(v: gvec4u) -> gvec4u = v.zyxw;
export fn kjli(v: gvec4u) -> gvec4u = v.zywx;
export fn klij(v: gvec4u) -> gvec4u = v.zwxy;
export fn klji(v: gvec4u) -> gvec4u = v.zwyx;
export fn lijk(v: gvec4u) -> gvec4u = v.wxyz;
export fn likj(v: gvec4u) -> gvec4u = v.wxzy;
export fn ljik(v: gvec4u) -> gvec4u = v.wyxz;
export fn ljki(v: gvec4u) -> gvec4u = v.wyzx;
export fn lkij(v: gvec4u) -> gvec4u = v.wzxy;
export fn lkji(v: gvec4u) -> gvec4u = v.wzyx;
export fn rgba(v: gvec4u) -> gvec4u = v.xyzw;
export fn rgab(v: gvec4u) -> gvec4u = v.xywz;
export fn rbga(v: gvec4u) -> gvec4u = v.xzyw;
export fn rbag(v: gvec4u) -> gvec4u = v.xzwy;
export fn ragb(v: gvec4u) -> gvec4u = v.xwyz;
export fn rabg(v: gvec4u) -> gvec4u = v.xwzy;
export fn grba(v: gvec4u) -> gvec4u = v.yxzw;
export fn grab(v: gvec4u) -> gvec4u = v.yxwz;
export fn gbra(v: gvec4u) -> gvec4u = v.yzxw;
export fn gbar(v: gvec4u) -> gvec4u = v.yzwx;
export fn garb(v: gvec4u) -> gvec4u = v.ywxz;
export fn gabr(v: gvec4u) -> gvec4u = v.ywzx;
export fn argb(v: gvec4u) -> gvec4u = v.wxyz;
export fn arbg(v: gvec4u) -> gvec4u = v.wxzy;
export fn agrb(v: gvec4u) -> gvec4u = v.wyxz;
export fn agbr(v: gvec4u) -> gvec4u = v.wyzx;
export fn abrg(v: gvec4u) -> gvec4u = v.wzxy;
export fn abgr(v: gvec4u) -> gvec4u = v.wzyx;

export fn x(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.w');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4i) -> gi32 = v.x;
export fn j(v: gvec4i) -> gi32 = v.y;
export fn k(v: gvec4i) -> gi32 = v.z;
export fn l(v: gvec4i) -> gi32 = v.w;
export fn r(v: gvec4i) -> gi32 = v.x;
export fn g(v: gvec4i) -> gi32 = v.y;
export fn b(v: gvec4i) -> gi32 = v.z;
export fn a(v: gvec4i) -> gi32 = v.w;

fn gvec42i(v: gvec4i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4i) -> gvec2i = gvec42i(v, '.xy');
export fn yx(v: gvec4i) -> gvec2i = gvec42i(v, '.yx');
export fn xz(v: gvec4i) -> gvec2i = gvec42i(v, '.xz');
export fn zx(v: gvec4i) -> gvec2i = gvec42i(v, '.zx');
export fn xw(v: gvec4i) -> gvec2i = gvec42i(v, '.xw');
export fn wx(v: gvec4i) -> gvec2i = gvec42i(v, '.wx');
export fn yz(v: gvec4i) -> gvec2i = gvec42i(v, '.yz');
export fn zy(v: gvec4i) -> gvec2i = gvec42i(v, '.zy');
export fn yw(v: gvec4i) -> gvec2i = gvec42i(v, '.yw');
export fn wy(v: gvec4i) -> gvec2i = gvec42i(v, '.wy');
export fn zw(v: gvec4i) -> gvec2i = gvec42i(v, '.zw');
export fn wz(v: gvec4i) -> gvec2i = gvec42i(v, '.wz');
export fn ij(v: gvec4i) -> gvec2i = v.xy;
export fn ji(v: gvec4i) -> gvec2i = v.yx;
export fn ik(v: gvec4i) -> gvec2i = v.xz;
export fn ki(v: gvec4i) -> gvec2i = v.zx;
export fn il(v: gvec4i) -> gvec2i = v.xw;
export fn li(v: gvec4i) -> gvec2i = v.wx;
export fn jk(v: gvec4i) -> gvec2i = v.yz;
export fn kj(v: gvec4i) -> gvec2i = v.zy;
export fn jl(v: gvec4i) -> gvec2i = v.yw;
export fn lj(v: gvec4i) -> gvec2i = v.wy;
export fn kl(v: gvec4i) -> gvec2i = v.zw;
export fn lk(v: gvec4i) -> gvec2i = v.wz;
export fn rg(v: gvec4i) -> gvec2i = v.xy;
export fn gr(v: gvec4i) -> gvec2i = v.yx;
export fn rb(v: gvec4i) -> gvec2i = v.xz;
export fn br(v: gvec4i) -> gvec2i = v.zx;
export fn ra(v: gvec4i) -> gvec2i = v.xw;
export fn ar(v: gvec4i) -> gvec2i = v.wx;
export fn gb(v: gvec4i) -> gvec2i = v.yz;
export fn bg(v: gvec4i) -> gvec2i = v.zy;
export fn ga(v: gvec4i) -> gvec2i = v.yw;
export fn ag(v: gvec4i) -> gvec2i = v.wy;
export fn ba(v: gvec4i) -> gvec2i = v.zw;
export fn ab(v: gvec4i) -> gvec2i = v.wz;

fn gvec43i(v: gvec4i, a: string) -> gvec3i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4i) -> gvec3i = gvec43i(v, '.xyz'); // 123
export fn xyw(v: gvec4i) -> gvec3i = gvec43i(v, '.xyw'); // 124
export fn xzy(v: gvec4i) -> gvec3i = gvec43i(v, '.xzy'); // 132
export fn xzw(v: gvec4i) -> gvec3i = gvec43i(v, '.xzw'); // 134
export fn xwy(v: gvec4i) -> gvec3i = gvec43i(v, '.xwy'); // 142
export fn xwz(v: gvec4i) -> gvec3i = gvec43i(v, '.xwz'); // 143
export fn yxz(v: gvec4i) -> gvec3i = gvec43i(v, '.yxz'); // 213
export fn yxw(v: gvec4i) -> gvec3i = gvec43i(v, '.yxw'); // 214
export fn yzx(v: gvec4i) -> gvec3i = gvec43i(v, '.yzx'); // 231
export fn yzw(v: gvec4i) -> gvec3i = gvec43i(v, '.yzw'); // 234
export fn ywx(v: gvec4i) -> gvec3i = gvec43i(v, '.ywx'); // 241
export fn ywz(v: gvec4i) -> gvec3i = gvec43i(v, '.ywz'); // 243
export fn zxy(v: gvec4i) -> gvec3i = gvec43i(v, '.zxy'); // 312
export fn zxw(v: gvec4i) -> gvec3i = gvec43i(v, '.zxw'); // 314
export fn zyx(v: gvec4i) -> gvec3i = gvec43i(v, '.zyx'); // 321
export fn zyw(v: gvec4i) -> gvec3i = gvec43i(v, '.zyw'); // 324
export fn zwx(v: gvec4i) -> gvec3i = gvec43i(v, '.zwx'); // 341
export fn zwy(v: gvec4i) -> gvec3i = gvec43i(v, '.zwy'); // 342
export fn wxy(v: gvec4i) -> gvec3i = gvec43i(v, '.wxy'); // 412
export fn wxz(v: gvec4i) -> gvec3i = gvec43i(v, '.wxz'); // 413
export fn wyx(v: gvec4i) -> gvec3i = gvec43i(v, '.wyx'); // 421
export fn wyz(v: gvec4i) -> gvec3i = gvec43i(v, '.wyz'); // 423
export fn wzx(v: gvec4i) -> gvec3i = gvec43i(v, '.wzx'); // 431
export fn wzy(v: gvec4i) -> gvec3i = gvec43i(v, '.wzy'); // 432
export fn ijk(v: gvec4i) -> gvec3i = v.xyz;
export fn ijl(v: gvec4i) -> gvec3i = v.xyw;
export fn ikj(v: gvec4i) -> gvec3i = v.xzy;
export fn ikl(v: gvec4i) -> gvec3i = v.xzw;
export fn ilj(v: gvec4i) -> gvec3i = v.xwy;
export fn ilk(v: gvec4i) -> gvec3i = v.xwz;
export fn jik(v: gvec4i) -> gvec3i = v.yxz;
export fn jil(v: gvec4i) -> gvec3i = v.yxw;
export fn jki(v: gvec4i) -> gvec3i = v.yzx;
export fn jkl(v: gvec4i) -> gvec3i = v.yzw;
export fn jli(v: gvec4i) -> gvec3i = v.ywx;
export fn jlk(v: gvec4i) -> gvec3i = v.ywz;
export fn kij(v: gvec4i) -> gvec3i = v.zxy;
export fn kil(v: gvec4i) -> gvec3i = v.zxw;
export fn kji(v: gvec4i) -> gvec3i = v.zyx;
export fn kjl(v: gvec4i) -> gvec3i = v.zyw;
export fn kli(v: gvec4i) -> gvec3i = v.zwx;
export fn klj(v: gvec4i) -> gvec3i = v.zwy;
export fn lij(v: gvec4i) -> gvec3i = v.wxy;
export fn lik(v: gvec4i) -> gvec3i = v.wxz;
export fn lji(v: gvec4i) -> gvec3i = v.wyx;
export fn ljk(v: gvec4i) -> gvec3i = v.wyz;
export fn lki(v: gvec4i) -> gvec3i = v.wzx;
export fn lkj(v: gvec4i) -> gvec3i = v.wzy;
export fn rgb(v: gvec4i) -> gvec3i = v.xyz;
export fn rga(v: gvec4i) -> gvec3i = v.xyw;
export fn rbg(v: gvec4i) -> gvec3i = v.xzy;
export fn rba(v: gvec4i) -> gvec3i = v.xzw;
export fn rag(v: gvec4i) -> gvec3i = v.xwy;
export fn rab(v: gvec4i) -> gvec3i = v.xwz;
export fn grb(v: gvec4i) -> gvec3i = v.yxz;
export fn gra(v: gvec4i) -> gvec3i = v.yxw;
export fn gbr(v: gvec4i) -> gvec3i = v.yzx;
export fn gba(v: gvec4i) -> gvec3i = v.yzw;
export fn gar(v: gvec4i) -> gvec3i = v.ywx;
export fn gab(v: gvec4i) -> gvec3i = v.ywz;
export fn brg(v: gvec4i) -> gvec3i = v.zxy;
export fn bra(v: gvec4i) -> gvec3i = v.zxw;
export fn bgr(v: gvec4i) -> gvec3i = v.zyx;
export fn bga(v: gvec4i) -> gvec3i = v.zyw;
export fn bar(v: gvec4i) -> gvec3i = v.zwx;
export fn bag(v: gvec4i) -> gvec3i = v.zwy;
export fn arb(v: gvec4i) -> gvec3i = v.wxy;
export fn arg(v: gvec4i) -> gvec3i = v.wxz;
export fn abr(v: gvec4i) -> gvec3i = v.wyx;
export fn abg(v: gvec4i) -> gvec3i = v.wyz;
export fn agr(v: gvec4i) -> gvec3i = v.wzx;
export fn agb(v: gvec4i) -> gvec3i = v.wzy;

fn gvec44i(v: gvec4i, a: string) -> gvec4i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4i(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4i) -> gvec4i = gvec44i(v, '.xyzw'); // 1234
export fn xywz(v: gvec4i) -> gvec4i = gvec44i(v, '.xywz'); // 1243
export fn xzyw(v: gvec4i) -> gvec4i = gvec44i(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4i) -> gvec4i = gvec44i(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4i) -> gvec4i = gvec44i(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4i) -> gvec4i = gvec44i(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4i) -> gvec4i = gvec44i(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4i) -> gvec4i = gvec44i(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4i) -> gvec4i = gvec44i(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4i) -> gvec4i = gvec44i(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4i) -> gvec4i = gvec44i(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4i) -> gvec4i = gvec44i(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4i) -> gvec4i = gvec44i(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4i) -> gvec4i = gvec44i(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4i) -> gvec4i = gvec44i(v, '.zyxw'); // 3214
export fn zywx(v: gvec4i) -> gvec4i = gvec44i(v, '.zywx'); // 3241
export fn zwxy(v: gvec4i) -> gvec4i = gvec44i(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4i) -> gvec4i = gvec44i(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4i) -> gvec4i = gvec44i(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4i) -> gvec4i = gvec44i(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4i) -> gvec4i = gvec44i(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4i) -> gvec4i = gvec44i(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4i) -> gvec4i = gvec44i(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4i) -> gvec4i = gvec44i(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4i) -> gvec4i = v.xyzw;
export fn ijlk(v: gvec4i) -> gvec4i = v.xywz;
export fn ikjl(v: gvec4i) -> gvec4i = v.xzyw;
export fn iklj(v: gvec4i) -> gvec4i = v.xzwy;
export fn iljk(v: gvec4i) -> gvec4i = v.xwyz;
export fn ilkj(v: gvec4i) -> gvec4i = v.xwzy;
export fn jikl(v: gvec4i) -> gvec4i = v.yxzw;
export fn jilk(v: gvec4i) -> gvec4i = v.yxwz;
export fn jkil(v: gvec4i) -> gvec4i = v.yzxw;
export fn jkli(v: gvec4i) -> gvec4i = v.yzwx;
export fn jlik(v: gvec4i) -> gvec4i = v.ywxz;
export fn jlki(v: gvec4i) -> gvec4i = v.ywzx;
export fn kijl(v: gvec4i) -> gvec4i = v.zxyw;
export fn kilj(v: gvec4i) -> gvec4i = v.zxwy;
export fn kjil(v: gvec4i) -> gvec4i = v.zyxw;
export fn kjli(v: gvec4i) -> gvec4i = v.zywx;
export fn klij(v: gvec4i) -> gvec4i = v.zwxy;
export fn klji(v: gvec4i) -> gvec4i = v.zwyx;
export fn lijk(v: gvec4i) -> gvec4i = v.wxyz;
export fn likj(v: gvec4i) -> gvec4i = v.wxzy;
export fn ljik(v: gvec4i) -> gvec4i = v.wyxz;
export fn ljki(v: gvec4i) -> gvec4i = v.wyzx;
export fn lkij(v: gvec4i) -> gvec4i = v.wzxy;
export fn lkji(v: gvec4i) -> gvec4i = v.wzyx;
export fn rgba(v: gvec4i) -> gvec4i = v.xyzw;
export fn rgab(v: gvec4i) -> gvec4i = v.xywz;
export fn rbga(v: gvec4i) -> gvec4i = v.xzyw;
export fn rbag(v: gvec4i) -> gvec4i = v.xzwy;
export fn ragb(v: gvec4i) -> gvec4i = v.xwyz;
export fn rabg(v: gvec4i) -> gvec4i = v.xwzy;
export fn grba(v: gvec4i) -> gvec4i = v.yxzw;
export fn grab(v: gvec4i) -> gvec4i = v.yxwz;
export fn gbra(v: gvec4i) -> gvec4i = v.yzxw;
export fn gbar(v: gvec4i) -> gvec4i = v.yzwx;
export fn garb(v: gvec4i) -> gvec4i = v.ywxz;
export fn gabr(v: gvec4i) -> gvec4i = v.ywzx;
export fn argb(v: gvec4i) -> gvec4i = v.wxyz;
export fn arbg(v: gvec4i) -> gvec4i = v.wxzy;
export fn agrb(v: gvec4i) -> gvec4i = v.wyxz;
export fn agbr(v: gvec4i) -> gvec4i = v.wyzx;
export fn abrg(v: gvec4i) -> gvec4i = v.wzxy;
export fn abgr(v: gvec4i) -> gvec4i = v.wzyx;

export fn x(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.w');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4f) -> gf32 = v.x;
export fn j(v: gvec4f) -> gf32 = v.y;
export fn k(v: gvec4f) -> gf32 = v.z;
export fn l(v: gvec4f) -> gf32 = v.w;
export fn r(v: gvec4f) -> gf32 = v.x;
export fn g(v: gvec4f) -> gf32 = v.y;
export fn b(v: gvec4f) -> gf32 = v.z;
export fn a(v: gvec4f) -> gf32 = v.w;

fn gvec42f(v: gvec4f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4f) -> gvec2f = gvec42f(v, '.xy');
export fn yx(v: gvec4f) -> gvec2f = gvec42f(v, '.yx');
export fn xz(v: gvec4f) -> gvec2f = gvec42f(v, '.xz');
export fn zx(v: gvec4f) -> gvec2f = gvec42f(v, '.zx');
export fn xw(v: gvec4f) -> gvec2f = gvec42f(v, '.xw');
export fn wx(v: gvec4f) -> gvec2f = gvec42f(v, '.wx');
export fn yz(v: gvec4f) -> gvec2f = gvec42f(v, '.yz');
export fn zy(v: gvec4f) -> gvec2f = gvec42f(v, '.zy');
export fn yw(v: gvec4f) -> gvec2f = gvec42f(v, '.yw');
export fn wy(v: gvec4f) -> gvec2f = gvec42f(v, '.wy');
export fn zw(v: gvec4f) -> gvec2f = gvec42f(v, '.zw');
export fn wz(v: gvec4f) -> gvec2f = gvec42f(v, '.wz');
export fn ij(v: gvec4f) -> gvec2f = v.xy;
export fn ji(v: gvec4f) -> gvec2f = v.yx;
export fn ik(v: gvec4f) -> gvec2f = v.xz;
export fn ki(v: gvec4f) -> gvec2f = v.zx;
export fn il(v: gvec4f) -> gvec2f = v.xw;
export fn li(v: gvec4f) -> gvec2f = v.wx;
export fn jk(v: gvec4f) -> gvec2f = v.yz;
export fn kj(v: gvec4f) -> gvec2f = v.zy;
export fn jl(v: gvec4f) -> gvec2f = v.yw;
export fn lj(v: gvec4f) -> gvec2f = v.wy;
export fn kl(v: gvec4f) -> gvec2f = v.zw;
export fn lk(v: gvec4f) -> gvec2f = v.wz;
export fn rg(v: gvec4f) -> gvec2f = v.xy;
export fn gr(v: gvec4f) -> gvec2f = v.yx;
export fn rb(v: gvec4f) -> gvec2f = v.xz;
export fn br(v: gvec4f) -> gvec2f = v.zx;
export fn ra(v: gvec4f) -> gvec2f = v.xw;
export fn ar(v: gvec4f) -> gvec2f = v.wx;
export fn gb(v: gvec4f) -> gvec2f = v.yz;
export fn bg(v: gvec4f) -> gvec2f = v.zy;
export fn ga(v: gvec4f) -> gvec2f = v.yw;
export fn ag(v: gvec4f) -> gvec2f = v.wy;
export fn ba(v: gvec4f) -> gvec2f = v.zw;
export fn ab(v: gvec4f) -> gvec2f = v.wz;

fn gvec43f(v: gvec4f, a: string) -> gvec3f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4f) -> gvec3f = gvec43f(v, '.xyz'); // 123
export fn xyw(v: gvec4f) -> gvec3f = gvec43f(v, '.xyw'); // 124
export fn xzy(v: gvec4f) -> gvec3f = gvec43f(v, '.xzy'); // 132
export fn xzw(v: gvec4f) -> gvec3f = gvec43f(v, '.xzw'); // 134
export fn xwy(v: gvec4f) -> gvec3f = gvec43f(v, '.xwy'); // 142
export fn xwz(v: gvec4f) -> gvec3f = gvec43f(v, '.xwz'); // 143
export fn yxz(v: gvec4f) -> gvec3f = gvec43f(v, '.yxz'); // 213
export fn yxw(v: gvec4f) -> gvec3f = gvec43f(v, '.yxw'); // 214
export fn yzx(v: gvec4f) -> gvec3f = gvec43f(v, '.yzx'); // 231
export fn yzw(v: gvec4f) -> gvec3f = gvec43f(v, '.yzw'); // 234
export fn ywx(v: gvec4f) -> gvec3f = gvec43f(v, '.ywx'); // 241
export fn ywz(v: gvec4f) -> gvec3f = gvec43f(v, '.ywz'); // 243
export fn zxy(v: gvec4f) -> gvec3f = gvec43f(v, '.zxy'); // 312
export fn zxw(v: gvec4f) -> gvec3f = gvec43f(v, '.zxw'); // 314
export fn zyx(v: gvec4f) -> gvec3f = gvec43f(v, '.zyx'); // 321
export fn zyw(v: gvec4f) -> gvec3f = gvec43f(v, '.zyw'); // 324
export fn zwx(v: gvec4f) -> gvec3f = gvec43f(v, '.zwx'); // 341
export fn zwy(v: gvec4f) -> gvec3f = gvec43f(v, '.zwy'); // 342
export fn wxy(v: gvec4f) -> gvec3f = gvec43f(v, '.wxy'); // 412
export fn wxz(v: gvec4f) -> gvec3f = gvec43f(v, '.wxz'); // 413
export fn wyx(v: gvec4f) -> gvec3f = gvec43f(v, '.wyx'); // 421
export fn wyz(v: gvec4f) -> gvec3f = gvec43f(v, '.wyz'); // 423
export fn wzx(v: gvec4f) -> gvec3f = gvec43f(v, '.wzx'); // 431
export fn wzy(v: gvec4f) -> gvec3f = gvec43f(v, '.wzy'); // 432
export fn ijk(v: gvec4f) -> gvec3f = v.xyz;
export fn ijl(v: gvec4f) -> gvec3f = v.xyw;
export fn ikj(v: gvec4f) -> gvec3f = v.xzy;
export fn ikl(v: gvec4f) -> gvec3f = v.xzw;
export fn ilj(v: gvec4f) -> gvec3f = v.xwy;
export fn ilk(v: gvec4f) -> gvec3f = v.xwz;
export fn jik(v: gvec4f) -> gvec3f = v.yxz;
export fn jil(v: gvec4f) -> gvec3f = v.yxw;
export fn jki(v: gvec4f) -> gvec3f = v.yzx;
export fn jkl(v: gvec4f) -> gvec3f = v.yzw;
export fn jli(v: gvec4f) -> gvec3f = v.ywx;
export fn jlk(v: gvec4f) -> gvec3f = v.ywz;
export fn kij(v: gvec4f) -> gvec3f = v.zxy;
export fn kil(v: gvec4f) -> gvec3f = v.zxw;
export fn kji(v: gvec4f) -> gvec3f = v.zyx;
export fn kjl(v: gvec4f) -> gvec3f = v.zyw;
export fn kli(v: gvec4f) -> gvec3f = v.zwx;
export fn klj(v: gvec4f) -> gvec3f = v.zwy;
export fn lij(v: gvec4f) -> gvec3f = v.wxy;
export fn lik(v: gvec4f) -> gvec3f = v.wxz;
export fn lji(v: gvec4f) -> gvec3f = v.wyx;
export fn ljk(v: gvec4f) -> gvec3f = v.wyz;
export fn lki(v: gvec4f) -> gvec3f = v.wzx;
export fn lkj(v: gvec4f) -> gvec3f = v.wzy;
export fn rgb(v: gvec4f) -> gvec3f = v.xyz;
export fn rga(v: gvec4f) -> gvec3f = v.xyw;
export fn rbg(v: gvec4f) -> gvec3f = v.xzy;
export fn rba(v: gvec4f) -> gvec3f = v.xzw;
export fn rag(v: gvec4f) -> gvec3f = v.xwy;
export fn rab(v: gvec4f) -> gvec3f = v.xwz;
export fn grb(v: gvec4f) -> gvec3f = v.yxz;
export fn gra(v: gvec4f) -> gvec3f = v.yxw;
export fn gbr(v: gvec4f) -> gvec3f = v.yzx;
export fn gba(v: gvec4f) -> gvec3f = v.yzw;
export fn gar(v: gvec4f) -> gvec3f = v.ywx;
export fn gab(v: gvec4f) -> gvec3f = v.ywz;
export fn brg(v: gvec4f) -> gvec3f = v.zxy;
export fn bra(v: gvec4f) -> gvec3f = v.zxw;
export fn bgr(v: gvec4f) -> gvec3f = v.zyx;
export fn bga(v: gvec4f) -> gvec3f = v.zyw;
export fn bar(v: gvec4f) -> gvec3f = v.zwx;
export fn bag(v: gvec4f) -> gvec3f = v.zwy;
export fn arb(v: gvec4f) -> gvec3f = v.wxy;
export fn arg(v: gvec4f) -> gvec3f = v.wxz;
export fn abr(v: gvec4f) -> gvec3f = v.wyx;
export fn abg(v: gvec4f) -> gvec3f = v.wyz;
export fn agr(v: gvec4f) -> gvec3f = v.wzx;
export fn agb(v: gvec4f) -> gvec3f = v.wzy;

fn gvec44f(v: gvec4f, a: string) -> gvec4f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4f(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4f) -> gvec4f = gvec44f(v, '.xyzw'); // 1234
export fn xywz(v: gvec4f) -> gvec4f = gvec44f(v, '.xywz'); // 1243
export fn xzyw(v: gvec4f) -> gvec4f = gvec44f(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4f) -> gvec4f = gvec44f(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4f) -> gvec4f = gvec44f(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4f) -> gvec4f = gvec44f(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4f) -> gvec4f = gvec44f(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4f) -> gvec4f = gvec44f(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4f) -> gvec4f = gvec44f(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4f) -> gvec4f = gvec44f(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4f) -> gvec4f = gvec44f(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4f) -> gvec4f = gvec44f(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4f) -> gvec4f = gvec44f(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4f) -> gvec4f = gvec44f(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4f) -> gvec4f = gvec44f(v, '.zyxw'); // 3214
export fn zywx(v: gvec4f) -> gvec4f = gvec44f(v, '.zywx'); // 3241
export fn zwxy(v: gvec4f) -> gvec4f = gvec44f(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4f) -> gvec4f = gvec44f(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4f) -> gvec4f = gvec44f(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4f) -> gvec4f = gvec44f(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4f) -> gvec4f = gvec44f(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4f) -> gvec4f = gvec44f(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4f) -> gvec4f = gvec44f(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4f) -> gvec4f = gvec44f(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4f) -> gvec4f = v.xyzw;
export fn ijlk(v: gvec4f) -> gvec4f = v.xywz;
export fn ikjl(v: gvec4f) -> gvec4f = v.xzyw;
export fn iklj(v: gvec4f) -> gvec4f = v.xzwy;
export fn iljk(v: gvec4f) -> gvec4f = v.xwyz;
export fn ilkj(v: gvec4f) -> gvec4f = v.xwzy;
export fn jikl(v: gvec4f) -> gvec4f = v.yxzw;
export fn jilk(v: gvec4f) -> gvec4f = v.yxwz;
export fn jkil(v: gvec4f) -> gvec4f = v.yzxw;
export fn jkli(v: gvec4f) -> gvec4f = v.yzwx;
export fn jlik(v: gvec4f) -> gvec4f = v.ywxz;
export fn jlki(v: gvec4f) -> gvec4f = v.ywzx;
export fn kijl(v: gvec4f) -> gvec4f = v.zxyw;
export fn kilj(v: gvec4f) -> gvec4f = v.zxwy;
export fn kjil(v: gvec4f) -> gvec4f = v.zyxw;
export fn kjli(v: gvec4f) -> gvec4f = v.zywx;
export fn klij(v: gvec4f) -> gvec4f = v.zwxy;
export fn klji(v: gvec4f) -> gvec4f = v.zwyx;
export fn lijk(v: gvec4f) -> gvec4f = v.wxyz;
export fn likj(v: gvec4f) -> gvec4f = v.wxzy;
export fn ljik(v: gvec4f) -> gvec4f = v.wyxz;
export fn ljki(v: gvec4f) -> gvec4f = v.wyzx;
export fn lkij(v: gvec4f) -> gvec4f = v.wzxy;
export fn lkji(v: gvec4f) -> gvec4f = v.wzyx;
export fn rgba(v: gvec4f) -> gvec4f = v.xyzw;
export fn rgab(v: gvec4f) -> gvec4f = v.xywz;
export fn rbga(v: gvec4f) -> gvec4f = v.xzyw;
export fn rbag(v: gvec4f) -> gvec4f = v.xzwy;
export fn ragb(v: gvec4f) -> gvec4f = v.xwyz;
export fn rabg(v: gvec4f) -> gvec4f = v.xwzy;
export fn grba(v: gvec4f) -> gvec4f = v.yxzw;
export fn grab(v: gvec4f) -> gvec4f = v.yxwz;
export fn gbra(v: gvec4f) -> gvec4f = v.yzxw;
export fn gbar(v: gvec4f) -> gvec4f = v.yzwx;
export fn garb(v: gvec4f) -> gvec4f = v.ywxz;
export fn gabr(v: gvec4f) -> gvec4f = v.ywzx;
export fn argb(v: gvec4f) -> gvec4f = v.wxyz;
export fn arbg(v: gvec4f) -> gvec4f = v.wxzy;
export fn agrb(v: gvec4f) -> gvec4f = v.wyxz;
export fn agbr(v: gvec4f) -> gvec4f = v.wyzx;
export fn abrg(v: gvec4f) -> gvec4f = v.wzxy;
export fn abgr(v: gvec4f) -> gvec4f = v.wzyx;

export fn x(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn w(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.w');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec4b) -> gbool = v.x;
export fn j(v: gvec4b) -> gbool = v.y;
export fn k(v: gvec4b) -> gbool = v.z;
export fn l(v: gvec4b) -> gbool = v.w;
export fn r(v: gvec4b) -> gbool = v.x;
export fn g(v: gvec4b) -> gbool = v.y;
export fn b(v: gvec4b) -> gbool = v.z;
export fn a(v: gvec4b) -> gbool = v.w;

fn gvec42b(v: gvec4b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4b) -> gvec2b = gvec42b(v, '.xy');
export fn yx(v: gvec4b) -> gvec2b = gvec42b(v, '.yx');
export fn xz(v: gvec4b) -> gvec2b = gvec42b(v, '.xz');
export fn zx(v: gvec4b) -> gvec2b = gvec42b(v, '.zx');
export fn xw(v: gvec4b) -> gvec2b = gvec42b(v, '.xw');
export fn wx(v: gvec4b) -> gvec2b = gvec42b(v, '.wx');
export fn yz(v: gvec4b) -> gvec2b = gvec42b(v, '.yz');
export fn zy(v: gvec4b) -> gvec2b = gvec42b(v, '.zy');
export fn yw(v: gvec4b) -> gvec2b = gvec42b(v, '.yw');
export fn wy(v: gvec4b) -> gvec2b = gvec42b(v, '.wy');
export fn zw(v: gvec4b) -> gvec2b = gvec42b(v, '.zw');
export fn wz(v: gvec4b) -> gvec2b = gvec42b(v, '.wz');
export fn ij(v: gvec4b) -> gvec2b = v.xy;
export fn ji(v: gvec4b) -> gvec2b = v.yx;
export fn ik(v: gvec4b) -> gvec2b = v.xz;
export fn ki(v: gvec4b) -> gvec2b = v.zx;
export fn il(v: gvec4b) -> gvec2b = v.xw;
export fn li(v: gvec4b) -> gvec2b = v.wx;
export fn jk(v: gvec4b) -> gvec2b = v.yz;
export fn kj(v: gvec4b) -> gvec2b = v.zy;
export fn jl(v: gvec4b) -> gvec2b = v.yw;
export fn lj(v: gvec4b) -> gvec2b = v.wy;
export fn kl(v: gvec4b) -> gvec2b = v.zw;
export fn lk(v: gvec4b) -> gvec2b = v.wz;
export fn rg(v: gvec4b) -> gvec2b = v.xy;
export fn gr(v: gvec4b) -> gvec2b = v.yx;
export fn rb(v: gvec4b) -> gvec2b = v.xz;
export fn br(v: gvec4b) -> gvec2b = v.zx;
export fn ra(v: gvec4b) -> gvec2b = v.xw;
export fn ar(v: gvec4b) -> gvec2b = v.wx;
export fn gb(v: gvec4b) -> gvec2b = v.yz;
export fn bg(v: gvec4b) -> gvec2b = v.zy;
export fn ga(v: gvec4b) -> gvec2b = v.yw;
export fn ag(v: gvec4b) -> gvec2b = v.wy;
export fn ba(v: gvec4b) -> gvec2b = v.zw;
export fn ab(v: gvec4b) -> gvec2b = v.wz;

fn gvec43b(v: gvec4b, a: string) -> gvec3b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4b) -> gvec3b = gvec43b(v, '.xyz'); // 123
export fn xyw(v: gvec4b) -> gvec3b = gvec43b(v, '.xyw'); // 124
export fn xzy(v: gvec4b) -> gvec3b = gvec43b(v, '.xzy'); // 132
export fn xzw(v: gvec4b) -> gvec3b = gvec43b(v, '.xzw'); // 134
export fn xwy(v: gvec4b) -> gvec3b = gvec43b(v, '.xwy'); // 142
export fn xwz(v: gvec4b) -> gvec3b = gvec43b(v, '.xwz'); // 143
export fn yxz(v: gvec4b) -> gvec3b = gvec43b(v, '.yxz'); // 213
export fn yxw(v: gvec4b) -> gvec3b = gvec43b(v, '.yxw'); // 214
export fn yzx(v: gvec4b) -> gvec3b = gvec43b(v, '.yzx'); // 231
export fn yzw(v: gvec4b) -> gvec3b = gvec43b(v, '.yzw'); // 234
export fn ywx(v: gvec4b) -> gvec3b = gvec43b(v, '.ywx'); // 241
export fn ywz(v: gvec4b) -> gvec3b = gvec43b(v, '.ywz'); // 243
export fn zxy(v: gvec4b) -> gvec3b = gvec43b(v, '.zxy'); // 312
export fn zxw(v: gvec4b) -> gvec3b = gvec43b(v, '.zxw'); // 314
export fn zyx(v: gvec4b) -> gvec3b = gvec43b(v, '.zyx'); // 321
export fn zyw(v: gvec4b) -> gvec3b = gvec43b(v, '.zyw'); // 324
export fn zwx(v: gvec4b) -> gvec3b = gvec43b(v, '.zwx'); // 341
export fn zwy(v: gvec4b) -> gvec3b = gvec43b(v, '.zwy'); // 342
export fn wxy(v: gvec4b) -> gvec3b = gvec43b(v, '.wxy'); // 412
export fn wxz(v: gvec4b) -> gvec3b = gvec43b(v, '.wxz'); // 413
export fn wyx(v: gvec4b) -> gvec3b = gvec43b(v, '.wyx'); // 421
export fn wyz(v: gvec4b) -> gvec3b = gvec43b(v, '.wyz'); // 423
export fn wzx(v: gvec4b) -> gvec3b = gvec43b(v, '.wzx'); // 431
export fn wzy(v: gvec4b) -> gvec3b = gvec43b(v, '.wzy'); // 432
export fn ijk(v: gvec4b) -> gvec3b = v.xyz;
export fn ijl(v: gvec4b) -> gvec3b = v.xyw;
export fn ikj(v: gvec4b) -> gvec3b = v.xzy;
export fn ikl(v: gvec4b) -> gvec3b = v.xzw;
export fn ilj(v: gvec4b) -> gvec3b = v.xwy;
export fn ilk(v: gvec4b) -> gvec3b = v.xwz;
export fn jik(v: gvec4b) -> gvec3b = v.yxz;
export fn jil(v: gvec4b) -> gvec3b = v.yxw;
export fn jki(v: gvec4b) -> gvec3b = v.yzx;
export fn jkl(v: gvec4b) -> gvec3b = v.yzw;
export fn jli(v: gvec4b) -> gvec3b = v.ywx;
export fn jlk(v: gvec4b) -> gvec3b = v.ywz;
export fn kij(v: gvec4b) -> gvec3b = v.zxy;
export fn kil(v: gvec4b) -> gvec3b = v.zxw;
export fn kji(v: gvec4b) -> gvec3b = v.zyx;
export fn kjl(v: gvec4b) -> gvec3b = v.zyw;
export fn kli(v: gvec4b) -> gvec3b = v.zwx;
export fn klj(v: gvec4b) -> gvec3b = v.zwy;
export fn lij(v: gvec4b) -> gvec3b = v.wxy;
export fn lik(v: gvec4b) -> gvec3b = v.wxz;
export fn lji(v: gvec4b) -> gvec3b = v.wyx;
export fn ljk(v: gvec4b) -> gvec3b = v.wyz;
export fn lki(v: gvec4b) -> gvec3b = v.wzx;
export fn lkj(v: gvec4b) -> gvec3b = v.wzy;
export fn rgb(v: gvec4b) -> gvec3b = v.xyz;
export fn rga(v: gvec4b) -> gvec3b = v.xyw;
export fn rbg(v: gvec4b) -> gvec3b = v.xzy;
export fn rba(v: gvec4b) -> gvec3b = v.xzw;
export fn rag(v: gvec4b) -> gvec3b = v.xwy;
export fn rab(v: gvec4b) -> gvec3b = v.xwz;
export fn grb(v: gvec4b) -> gvec3b = v.yxz;
export fn gra(v: gvec4b) -> gvec3b = v.yxw;
export fn gbr(v: gvec4b) -> gvec3b = v.yzx;
export fn gba(v: gvec4b) -> gvec3b = v.yzw;
export fn gar(v: gvec4b) -> gvec3b = v.ywx;
export fn gab(v: gvec4b) -> gvec3b = v.ywz;
export fn brg(v: gvec4b) -> gvec3b = v.zxy;
export fn bra(v: gvec4b) -> gvec3b = v.zxw;
export fn bgr(v: gvec4b) -> gvec3b = v.zyx;
export fn bga(v: gvec4b) -> gvec3b = v.zyw;
export fn bar(v: gvec4b) -> gvec3b = v.zwx;
export fn bag(v: gvec4b) -> gvec3b = v.zwy;
export fn arb(v: gvec4b) -> gvec3b = v.wxy;
export fn arg(v: gvec4b) -> gvec3b = v.wxz;
export fn abr(v: gvec4b) -> gvec3b = v.wyx;
export fn abg(v: gvec4b) -> gvec3b = v.wyz;
export fn agr(v: gvec4b) -> gvec3b = v.wzx;
export fn agb(v: gvec4b) -> gvec3b = v.wzy;

fn gvec44b(v: gvec4b, a: string) -> gvec4b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4b(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4b) -> gvec4b = gvec44b(v, '.xyzw'); // 1234
export fn xywz(v: gvec4b) -> gvec4b = gvec44b(v, '.xywz'); // 1243
export fn xzyw(v: gvec4b) -> gvec4b = gvec44b(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4b) -> gvec4b = gvec44b(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4b) -> gvec4b = gvec44b(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4b) -> gvec4b = gvec44b(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4b) -> gvec4b = gvec44b(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4b) -> gvec4b = gvec44b(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4b) -> gvec4b = gvec44b(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4b) -> gvec4b = gvec44b(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4b) -> gvec4b = gvec44b(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4b) -> gvec4b = gvec44b(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4b) -> gvec4b = gvec44b(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4b) -> gvec4b = gvec44b(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4b) -> gvec4b = gvec44b(v, '.zyxw'); // 3214
export fn zywx(v: gvec4b) -> gvec4b = gvec44b(v, '.zywx'); // 3241
export fn zwxy(v: gvec4b) -> gvec4b = gvec44b(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4b) -> gvec4b = gvec44b(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4b) -> gvec4b = gvec44b(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4b) -> gvec4b = gvec44b(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4b) -> gvec4b = gvec44b(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4b) -> gvec4b = gvec44b(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4b) -> gvec4b = gvec44b(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4b) -> gvec4b = gvec44b(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4b) -> gvec4b = v.xyzw;
export fn ijlk(v: gvec4b) -> gvec4b = v.xywz;
export fn ikjl(v: gvec4b) -> gvec4b = v.xzyw;
export fn iklj(v: gvec4b) -> gvec4b = v.xzwy;
export fn iljk(v: gvec4b) -> gvec4b = v.xwyz;
export fn ilkj(v: gvec4b) -> gvec4b = v.xwzy;
export fn jikl(v: gvec4b) -> gvec4b = v.yxzw;
export fn jilk(v: gvec4b) -> gvec4b = v.yxwz;
export fn jkil(v: gvec4b) -> gvec4b = v.yzxw;
export fn jkli(v: gvec4b) -> gvec4b = v.yzwx;
export fn jlik(v: gvec4b) -> gvec4b = v.ywxz;
export fn jlki(v: gvec4b) -> gvec4b = v.ywzx;
export fn kijl(v: gvec4b) -> gvec4b = v.zxyw;
export fn kilj(v: gvec4b) -> gvec4b = v.zxwy;
export fn kjil(v: gvec4b) -> gvec4b = v.zyxw;
export fn kjli(v: gvec4b) -> gvec4b = v.zywx;
export fn klij(v: gvec4b) -> gvec4b = v.zwxy;
export fn klji(v: gvec4b) -> gvec4b = v.zwyx;
export fn lijk(v: gvec4b) -> gvec4b = v.wxyz;
export fn likj(v: gvec4b) -> gvec4b = v.wxzy;
export fn ljik(v: gvec4b) -> gvec4b = v.wyxz;
export fn ljki(v: gvec4b) -> gvec4b = v.wyzx;
export fn lkij(v: gvec4b) -> gvec4b = v.wzxy;
export fn lkji(v: gvec4b) -> gvec4b = v.wzyx;
export fn rgba(v: gvec4b) -> gvec4b = v.xyzw;
export fn rgab(v: gvec4b) -> gvec4b = v.xywz;
export fn rbga(v: gvec4b) -> gvec4b = v.xzyw;
export fn rbag(v: gvec4b) -> gvec4b = v.xzwy;
export fn ragb(v: gvec4b) -> gvec4b = v.xwyz;
export fn rabg(v: gvec4b) -> gvec4b = v.xwzy;
export fn grba(v: gvec4b) -> gvec4b = v.yxzw;
export fn grab(v: gvec4b) -> gvec4b = v.yxwz;
export fn gbra(v: gvec4b) -> gvec4b = v.yzxw;
export fn gbar(v: gvec4b) -> gvec4b = v.yzwx;
export fn garb(v: gvec4b) -> gvec4b = v.ywxz;
export fn gabr(v: gvec4b) -> gvec4b = v.ywzx;
export fn brga(v: gvec4b) -> gvec4b = v.zxyw;
export fn brag(v: gvec4b) -> gvec4b = v.zxwy;
export fn bgra(v: gvec4b) -> gvec4b = v.zyxw;
export fn bgar(v: gvec4b) -> gvec4b = v.zywx;
export fn barg(v: gvec4b) -> gvec4b = v.zwxy;
export fn bagr(v: gvec4b) -> gvec4b = v.zwyx;
export fn argb(v: gvec4b) -> gvec4b = v.wxyz;
export fn arbg(v: gvec4b) -> gvec4b = v.wxzy;
export fn agrb(v: gvec4b) -> gvec4b = v.wyxz;
export fn agbr(v: gvec4b) -> gvec4b = v.wyzx;
export fn abrg(v: gvec4b) -> gvec4b = v.wzxy;
export fn abgr(v: gvec4b) -> gvec4b = v.wzyx;

// TODO: Improve GBuffer to support other buffer types
export fn get(gb: GBuffer, i: gu32) -> gi32 {
  let statement = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(gb));
  return gi32(statement, i.statements, buffers);
}

export fn store(a: gi32, b: gi32) -> gi32 {
    let statement = a.varName.concat(" = ").concat(b.varName);
    let statements = a.statements.concat(b.statements).concat(Dict(statement, statement));
    let buffers = a.buffers.union(b.buffers);
    return gi32(statement, statements, buffers);
}

// GPU Math

export fn neg(v: gi32) -> gi32 {
  let varName = '(-'.concat(v.varName).concat(')');
  return gi32(varName, v.statements, v.buffers);
}
export fn neg(v: gf32) -> gf32 {
  let varName = '(-'.concat(v.varName).concat(')');
  return gf32(varName, v.statements, v.buffers);
}
export fn neg(v: gvec2i) -> gvec2i {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec2i(varName, v.statements, v.buffers);
}
export fn neg(v: gvec2f) -> gvec2f {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec2f(varName, v.statements, v.buffers);
}
export fn neg(v: gvec3i) -> gvec3i {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec3i(varName, v.statements, v.buffers);
}
export fn neg(v: gvec3f) -> gvec3f {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec3f(varName, v.statements, v.buffers);
}
export fn neg(v: gvec4i) -> gvec3i {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec4i(varName, v.statements, v.buffers);
}
export fn neg(v: gvec4f) -> gvec3f {
  let varName = '(-'.concat(v.varName).concat(')');
  return gvec4f(varName, v.statements, v.buffers);
}

export fn add(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn add{T}(a: gu32, b: T) -> gu32 = add(a, b.gu32);
export fn add{T}(a: T, b: gu32) -> gu32 = add(a.gu32, b);

export fn add(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn add{T}(a: gi32, b: T) -> gi32 = add(a, b.gi32);
export fn add{T}(a: T, b: gi32) -> gi32 = add(a.gi32, b);

export fn add(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn add{T}(a: gf32, b: T) -> gf32 = add(a, b.gf32);
export fn add{T}(a: T, b: gf32) -> gf32 = add(a.gf32, b);

export fn add(a: gvec2u, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn add(a: gvec2u, b: gu32) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn add(a: gu32, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}

export fn add(a: gvec2i, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn add(a: gvec2i, b: gi32) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn add(a: gi32, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}

export fn add(a: gvec2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn add(a: gvec2f, b: gf32) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn add(a: gf32, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}

export fn add(a: gvec3u, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn add(a: gvec3u, b: gu32) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn add(a: gu32, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}

export fn add(a: gvec3i, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn add(a: gvec3i, b: gi32) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn add(a: gi32, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}

export fn add(a: gvec3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn add(a: gvec3f, b: gf32) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn add(a: gf32, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}

export fn add(a: gvec4u, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn add(a: gvec4u, b: gu32) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn add(a: gu32, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}

export fn add(a: gvec4i, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn add(a: gvec4i, b: gi32) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn add(a: gi32, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}

export fn add(a: gvec4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn add(a: gvec4f, b: gf32) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn add(a: gf32, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}

export fn add(a: gmat2x2f, b: gmat2x2f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn add(a: gmat2x3f, b: gmat2x3f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn add(a: gmat2x4f, b: gmat2x4f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn add(a: gmat3x2f, b: gmat3x2f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn add(a: gmat3x3f, b: gmat3x3f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn add(a: gmat3x4f, b: gmat3x4f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn add(a: gmat4x2f, b: gmat4x2f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}
export fn add(a: gmat4x3f, b: gmat4x3f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}
export fn add(a: gmat4x4f, b: gmat4x4f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}

export fn sub(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn sub{T}(a: gu32, b: T) -> gu32 = sub(a, b.gu32);
export fn sub{T}(a: T, b: gu32) -> gu32 = sub(a.gu32, b);

export fn sub(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn sub{T}(a: gi32, b: T) -> gi32 = sub(a, b.gi32);
export fn sub{T}(a: T, b: gi32) -> gi32 = sub(a.gi32, b);

export fn sub(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn sub{T}(a: gf32, b: T) -> gf32 = sub(a, b.gf32);
export fn sub{T}(a: T, b: gf32) -> gf32 = sub(a.gf32, b);

export fn sub(a: gvec2u, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn sub(a: gvec2u, b: gu32) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn sub(a: gu32, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}

export fn sub(a: gvec2i, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn sub(a: gvec2i, b: gi32) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn sub(a: gi32, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}

export fn sub(a: gvec2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn sub(a: gvec2f, b: gf32) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn sub(a: gf32, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}

export fn sub(a: gvec3u, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn sub(a: gvec3u, b: gu32) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn sub(a: gu32, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}

export fn sub(a: gvec3i, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn sub(a: gvec3i, b: gi32) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn sub(a: gi32, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}

export fn sub(a: gvec3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn sub(a: gvec3f, b: gf32) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn sub(a: gf32, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}

export fn sub(a: gvec4u, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn sub(a: gvec4u, b: gu32) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn sub(a: gu32, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}

export fn sub(a: gvec4i, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn sub(a: gvec4i, b: gi32) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn sub(a: gi32, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}

export fn sub(a: gvec4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn sub(a: gvec4f, b: gf32) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn sub(a: gf32, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}

export fn sub(a: gmat2x2f, b: gmat2x2f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn sub(a: gmat2x3f, b: gmat2x3f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn sub(a: gmat2x4f, b: gmat2x4f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn sub(a: gmat3x2f, b: gmat3x2f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn sub(a: gmat3x3f, b: gmat3x3f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn sub(a: gmat3x4f, b: gmat3x4f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn sub(a: gmat4x2f, b: gmat4x2f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}
export fn sub(a: gmat4x3f, b: gmat4x3f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}
export fn sub(a: gmat4x4f, b: gmat4x4f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}

export fn mul(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn mul{T}(a: gu32, b: T) -> gu32 = mul(a, b.gu32);
export fn mul{T}(a: T, b: gu32) -> gu32 = mul(a.gu32, b);

export fn mul(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn mul{T}(a: gi32, b: T) -> gi32 = mul(a, b.gi32);
export fn mul{T}(a: T, b: gi32) -> gi32 = mul(a.gi32, b);

export fn mul(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn mul{T}(a: gf32, b: T) -> gf32 = mul(a, b.gf32);
export fn mul{T}(a: T, b: gf32) -> gf32 = mul(a.gf32, b);

export fn mul(a: gvec2u, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn mul(a: gvec2u, b: gu32) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn mul(a: gu32, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}

export fn mul(a: gvec2i, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn mul(a: gvec2i, b: gi32) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn mul(a: gi32, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}

export fn mul(a: gvec2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gvec2f, b: gf32) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}

export fn mul(a: gvec3u, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn mul(a: gvec3u, b: gu32) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn mul(a: gu32, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}

export fn mul(a: gvec3i, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn mul(a: gvec3i, b: gi32) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn mul(a: gi32, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}

export fn mul(a: gvec3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gvec3f, b: gf32) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}

export fn mul(a: gvec4u, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn mul(a: gvec4u, b: gu32) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn mul(a: gu32, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}

export fn mul(a: gvec4i, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn mul(a: gvec4i, b: gi32) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn mul(a: gi32, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}

export fn mul(a: gvec4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gvec4f, b: gf32) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}

export fn mul(a: gmat2x2f, b: gf32) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat2x2f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn mul(a: gmat2x2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gvec2f, b: gmat2x2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gmat2x2f, b: gmat2x2f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn mul(a: gmat2x2f, b: gmat3x2f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn mul(a: gmat2x2f, b: gmat4x2f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}

export fn mul(a: gmat2x3f, b: gf32) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat2x3f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn mul(a: gmat2x3f, b: gvec2f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gvec3f, b: gmat2x3f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gmat2x3f, b: gmat2x2f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn mul(a: gmat2x3f, b: gmat3x2f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn mul(a: gmat2x3f, b: gmat4x2f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}

export fn mul(a: gmat2x4f, b: gf32) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat2x4f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat2x4f, b: gvec2f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gvec4f, b: gmat2x4f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat2x4f, b: gmat2x2f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat2x4f, b: gmat3x2f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat2x4f, b: gmat4x2f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}

export fn mul(a: gmat3x2f, b: gf32) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat3x2f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn mul(a: gmat3x2f, b: gvec3f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gvec2f, b: gmat3x2f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gmat3x2f, b: gmat2x3f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn mul(a: gmat3x2f, b: gmat3x3f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn mul(a: gmat3x2f, b: gmat4x3f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}

export fn mul(a: gmat3x3f, b: gf32) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat3x3f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn mul(a: gmat3x3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gvec3f, b: gmat3x3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gmat3x3f, b: gmat2x3f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn mul(a: gmat3x3f, b: gmat3x3f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn mul(a: gmat3x3f, b: gmat4x3f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}

export fn mul(a: gmat3x4f, b: gf32) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat3x4f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn mul(a: gmat3x4f, b: gvec3f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gvec4f, b: gmat3x4f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gmat3x4f, b: gmat2x3f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat3x4f, b: gmat3x3f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn mul(a: gmat3x4f, b: gmat4x3f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}

export fn mul(a: gmat4x2f, b: gf32) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat4x2f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}
export fn mul(a: gmat4x2f, b: gvec4f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mul(a: gvec2f, b: gmat4x2f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}
export fn mul(a: gmat4x2f, b: gmat2x4f) -> gmat2x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(varName, statements, buffers);
}
export fn mul(a: gmat4x2f, b: gmat3x4f) -> gmat3x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x2f(varName, statements, buffers);
}
export fn mul(a: gmat4x2f, b: gmat4x4f) -> gmat4x2f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x2f(varName, statements, buffers);
}

export fn mul(a: gmat4x3f, b: gf32) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat4x3f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}
export fn mul(a: gmat4x3f, b: gvec4f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mul(a: gvec3f, b: gmat4x3f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gmat4x3f, b: gmat2x4f) -> gmat2x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(varName, statements, buffers);
}
export fn mul(a: gmat4x3f, b: gmat3x4f) -> gmat3x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x3f(varName, statements, buffers);
}
export fn mul(a: gmat4x3f, b: gmat4x4f) -> gmat4x3f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x3f(varName, statements, buffers);
}

export fn mul(a: gmat4x4f, b: gf32) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}
export fn mul(a: gf32, b: gmat4x4f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}
export fn mul(a: gmat4x4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gvec4f, b: gmat4x4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mul(a: gmat4x4f, b: gmat2x4f) -> gmat2x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(varName, statements, buffers);
}
export fn mul(a: gmat4x4f, b: gmat3x4f) -> gmat3x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat3x4f(varName, statements, buffers);
}
export fn mul(a: gmat4x4f, b: gmat4x4f) -> gmat4x4f {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat4x4f(varName, statements, buffers);
}

export fn div(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn div{T}(a: gu32, b: T) -> gu32 = div(a, b.gu32);
export fn div{T}(a: T, b: gu32) -> gu32 = div(a.gu32, b);

export fn div(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn div{T}(a: gi32, b: T) -> gi32 = div(a, b.gi32);
export fn div{T}(a: T, b: gi32) -> gi32 = div(a.gi32, b);

export fn div(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn div{T}(a: gf32, b: T) -> gf32 = div(a, b.gf32);
export fn div{T}(a: T, b: gf32) -> gf32 = div(a.gf32, b);

export fn div(a: gvec2u, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn div(a: gvec2u, b: gu32) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn div(a: gu32, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}

export fn div(a: gvec2i, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn div(a: gvec2i, b: gi32) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn div(a: gi32, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}

export fn div(a: gvec2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn div(a: gvec2f, b: gf32) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn div(a: gf32, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}

export fn div(a: gvec3u, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn div(a: gvec3u, b: gu32) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn div(a: gu32, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}

export fn div(a: gvec3i, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn div(a: gvec3i, b: gi32) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn div(a: gi32, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}

export fn div(a: gvec3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn div(a: gvec3f, b: gf32) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn div(a: gf32, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}

export fn div(a: gvec4u, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn div(a: gvec4u, b: gu32) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn div(a: gu32, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}

export fn div(a: gvec4i, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn div(a: gvec4i, b: gi32) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn div(a: gi32, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}

export fn div(a: gvec4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn div(a: gvec4f, b: gf32) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn div(a: gf32, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}

export fn mod(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn mod{T}(a: gu32, b: T) -> gu32 = mod(a, b.gu32);
export fn mod{T}(a: T, b: gu32) -> gu32 = mod(a.gu32, b);

export fn mod(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn mod{T}(a: gi32, b: T) -> gi32 = mod(a, b.gi32);
export fn mod{T}(a: T, b: gi32) -> gi32 = mod(a.gi32, b);

export fn mod(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn mod{T}(a: gf32, b: T) -> gf32 = mod(a, b.gf32);
export fn mod{T}(a: T, b: gf32) -> gf32 = mod(a.gf32, b);

export fn mod(a: gvec2u, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn mod(a: gvec2u, b: gu32) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}
export fn mod(a: gu32, b: gvec2u) -> gvec2u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(varName, statements, buffers);
}

export fn mod(a: gvec2i, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn mod(a: gvec2i, b: gi32) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}
export fn mod(a: gi32, b: gvec2i) -> gvec2i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(varName, statements, buffers);
}

export fn mod(a: gvec2f, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mod(a: gvec2f, b: gf32) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}
export fn mod(a: gf32, b: gvec2f) -> gvec2f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(varName, statements, buffers);
}

export fn mod(a: gvec3u, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn mod(a: gvec3u, b: gu32) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}
export fn mod(a: gu32, b: gvec3u) -> gvec3u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3u(varName, statements, buffers);
}

export fn mod(a: gvec3i, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn mod(a: gvec3i, b: gi32) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}
export fn mod(a: gi32, b: gvec3i) -> gvec3i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3i(varName, statements, buffers);
}

export fn mod(a: gvec3f, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mod(a: gvec3f, b: gf32) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}
export fn mod(a: gf32, b: gvec3f) -> gvec3f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec3f(varName, statements, buffers);
}

export fn mod(a: gvec4u, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn mod(a: gvec4u, b: gu32) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}
export fn mod(a: gu32, b: gvec4u) -> gvec4u {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4u(varName, statements, buffers);
}

export fn mod(a: gvec4i, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn mod(a: gvec4i, b: gi32) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}
export fn mod(a: gi32, b: gvec4i) -> gvec4i {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4i(varName, statements, buffers);
}

export fn mod(a: gvec4f, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mod(a: gvec4f, b: gf32) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}
export fn mod(a: gf32, b: gvec4f) -> gvec4f {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec4f(varName, statements, buffers);
}

// GPU Comparison methods

fn geq{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' == ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn eq(a: gu32, b: gu32) -> gbool = geq{gu32, gbool}(a, b);
export fn eq{T}(a: gu32, b: T) -> gbool = geq{gu32, gbool}(a, b.gu32);
export fn eq{T}(a: T, b: gu32) -> gbool = geq{gu32, gbool}(a.gu32, b);
export fn eq(a: gi32, b: gi32) -> gbool = geq{gi32, gbool}(a, b);
export fn eq{T}(a: gi32, b: T) -> gbool = geq{gi32, gbool}(a, b.gi32);
export fn eq{T}(a: T, b: gi32) -> gbool = geq{gi32, gbool}(a.gi32, b);
export fn eq(a: gf32, b: gf32) -> gbool = geq{gf32, gbool}(a, b);
export fn eq{T}(a: gf32, b: T) -> gbool = geq{gf32, gbool}(a, b.gf32);
export fn eq{T}(a: T, b: gf32) -> gbool = geq{gf32, gbool}(a.gf32, b);
export fn eq(a: gbool, b: gbool) -> gbool = geq{gbool, gbool}(a, b);
export fn eq{T}(a: gbool, b: T) -> gbool = geq{gbool, gbool}(a, b.gbool);
export fn eq{T}(a: T, b: gbool) -> gbool = geq{gbool, gbool}(a.gbool, b);
export fn eq(a: gvec2u, b: gvec2u) -> gvec2b = geq{gvec2u, gvec2b}(a, b);
export fn eq(a: gvec2i, b: gvec2i) -> gvec2b = geq{gvec2i, gvec2b}(a, b);
export fn eq(a: gvec2f, b: gvec2f) -> gvec2b = geq{gvec2f, gvec2b}(a, b);
export fn eq(a: gvec2b, b: gvec2b) -> gvec2b = geq{gvec2b, gvec2b}(a, b);
export fn eq(a: gvec3u, b: gvec3u) -> gvec3b = geq{gvec3u, gvec3b}(a, b);
export fn eq(a: gvec3i, b: gvec3i) -> gvec3b = geq{gvec3i, gvec3b}(a, b);
export fn eq(a: gvec3f, b: gvec3f) -> gvec3b = geq{gvec3f, gvec3b}(a, b);
export fn eq(a: gvec3b, b: gvec3b) -> gvec3b = geq{gvec3b, gvec3b}(a, b);
export fn eq(a: gvec4u, b: gvec4u) -> gvec4b = geq{gvec4u, gvec4b}(a, b);
export fn eq(a: gvec4i, b: gvec4i) -> gvec4b = geq{gvec4i, gvec4b}(a, b);
export fn eq(a: gvec4f, b: gvec4f) -> gvec4b = geq{gvec4f, gvec4b}(a, b);
export fn eq(a: gvec4b, b: gvec4b) -> gvec4b = geq{gvec4b, gvec4b}(a, b);

fn gneq{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' != ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn neq(a: gu32, b: gu32) -> gbool = gneq{gu32, gbool}(a, b);
export fn neq{T}(a: gu32, b: T) -> gbool = gneq{gu32, gbool}(a, b.gu32);
export fn neq{T}(a: T, b: gu32) -> gbool = gneq{gu32, gbool}(a.gu32, b);
export fn neq(a: gi32, b: gi32) -> gbool = gneq{gi32, gbool}(a, b);
export fn neq{T}(a: gi32, b: T) -> gbool = gneq{gi32, gbool}(a, b.gi32);
export fn neq{T}(a: T, b: gi32) -> gbool = gneq{gi32, gbool}(a.gi32, b);
export fn neq(a: gf32, b: gf32) -> gbool = gneq{gf32, gbool}(a, b);
export fn neq{T}(a: gf32, b: T) -> gbool = gneq{gf32, gbool}(a, b.gf32);
export fn neq{T}(a: T, b: gf32) -> gbool = gneq{gf32, gbool}(a.gf32, b);
export fn neq(a: gbool, b: gbool) -> gbool = gneq{gbool, gbool}(a, b);
export fn neq{T}(a: gbool, b: T) -> gbool = gneq{gbool, gbool}(a, b.gbool);
export fn neq{T}(a: T, b: gbool) -> gbool = gneq{gbool, gbool}(a.gbool, b);
export fn neq(a: gvec2u, b: gvec2u) -> gvec2b = gneq{gvec2u, gvec2b}(a, b);
export fn neq(a: gvec2i, b: gvec2i) -> gvec2b = gneq{gvec2i, gvec2b}(a, b);
export fn neq(a: gvec2f, b: gvec2f) -> gvec2b = gneq{gvec2f, gvec2b}(a, b);
export fn neq(a: gvec2b, b: gvec2b) -> gvec2b = gneq{gvec2b, gvec2b}(a, b);
export fn neq(a: gvec3u, b: gvec3u) -> gvec3b = gneq{gvec3u, gvec3b}(a, b);
export fn neq(a: gvec3i, b: gvec3i) -> gvec3b = gneq{gvec3i, gvec3b}(a, b);
export fn neq(a: gvec3f, b: gvec3f) -> gvec3b = gneq{gvec3f, gvec3b}(a, b);
export fn neq(a: gvec3b, b: gvec3b) -> gvec3b = gneq{gvec3b, gvec3b}(a, b);
export fn neq(a: gvec4u, b: gvec4u) -> gvec4b = gneq{gvec4u, gvec4b}(a, b);
export fn neq(a: gvec4i, b: gvec4i) -> gvec4b = gneq{gvec4i, gvec4b}(a, b);
export fn neq(a: gvec4f, b: gvec4f) -> gvec4b = gneq{gvec4f, gvec4b}(a, b);
export fn neq(a: gvec4b, b: gvec4b) -> gvec4b = gneq{gvec4b, gvec4b}(a, b);

fn glt{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' < ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn lt(a: gu32, b: gu32) -> gbool = glt{gu32, gbool}(a, b);
export fn lt{T}(a: gu32, b: T) -> gbool = glt{gu32, gbool}(a, b.gu32);
export fn lt{T}(a: T, b: gu32) -> gbool = glt{gu32, gbool}(a.gu32, b);
export fn lt(a: gi32, b: gi32) -> gbool = glt{gi32, gbool}(a, b);
export fn lt{T}(a: gi32, b: T) -> gbool = glt{gi32, gbool}(a, b.gi32);
export fn lt{T}(a: T, b: gi32) -> gbool = glt{gi32, gbool}(a.gi32, b);
export fn lt(a: gf32, b: gf32) -> gbool = glt{gf32, gbool}(a, b);
export fn lt{T}(a: gf32, b: T) -> gbool = glt{gf32, gbool}(a, b.gf32);
export fn lt{T}(a: T, b: gf32) -> gbool = glt{gf32, gbool}(a.gf32, b);
export fn lt(a: gvec2u, b: gvec2u) -> gvec2b = glt{gvec2u, gvec2b}(a, b);
export fn lt(a: gvec2i, b: gvec2i) -> gvec2b = glt{gvec2i, gvec2b}(a, b);
export fn lt(a: gvec2f, b: gvec2f) -> gvec2b = glt{gvec2f, gvec2b}(a, b);
export fn lt(a: gvec3u, b: gvec3u) -> gvec3b = glt{gvec3u, gvec3b}(a, b);
export fn lt(a: gvec3i, b: gvec3i) -> gvec3b = glt{gvec3i, gvec3b}(a, b);
export fn lt(a: gvec3f, b: gvec3f) -> gvec3b = glt{gvec3f, gvec3b}(a, b);
export fn lt(a: gvec4u, b: gvec4u) -> gvec4b = glt{gvec4u, gvec4b}(a, b);
export fn lt(a: gvec4i, b: gvec4i) -> gvec4b = glt{gvec4i, gvec4b}(a, b);
export fn lt(a: gvec4f, b: gvec4f) -> gvec4b = glt{gvec4f, gvec4b}(a, b);

fn glte{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' <= ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn lte(a: gu32, b: gu32) -> gbool = glte{gu32, gbool}(a, b);
export fn lte{T}(a: gu32, b: T) -> gbool = glte{gu32, gbool}(a, b.gu32);
export fn lte{T}(a: T, b: gu32) -> gbool = glte{gu32, gbool}(a.gu32, b);
export fn lte(a: gi32, b: gi32) -> gbool = glte{gi32, gbool}(a, b);
export fn lte{T}(a: gi32, b: T) -> gbool = glte{gi32, gbool}(a, b.gi32);
export fn lte{T}(a: T, b: gi32) -> gbool = glte{gi32, gbool}(a.gi32, b);
export fn lte(a: gf32, b: gf32) -> gbool = glte{gf32, gbool}(a, b);
export fn lte{T}(a: gf32, b: T) -> gbool = glte{gf32, gbool}(a, b.gf32);
export fn lte{T}(a: T, b: gf32) -> gbool = glte{gf32, gbool}(a.gf32, b);
export fn lte(a: gvec2u, b: gvec2u) -> gvec2b = glte{gvec2u, gvec2b}(a, b);
export fn lte(a: gvec2i, b: gvec2i) -> gvec2b = glte{gvec2i, gvec2b}(a, b);
export fn lte(a: gvec2f, b: gvec2f) -> gvec2b = glte{gvec2f, gvec2b}(a, b);
export fn lte(a: gvec3u, b: gvec3u) -> gvec3b = glte{gvec3u, gvec3b}(a, b);
export fn lte(a: gvec3i, b: gvec3i) -> gvec3b = glte{gvec3i, gvec3b}(a, b);
export fn lte(a: gvec3f, b: gvec3f) -> gvec3b = glte{gvec3f, gvec3b}(a, b);
export fn lte(a: gvec4u, b: gvec4u) -> gvec4b = glte{gvec4u, gvec4b}(a, b);
export fn lte(a: gvec4i, b: gvec4i) -> gvec4b = glte{gvec4i, gvec4b}(a, b);
export fn lte(a: gvec4f, b: gvec4f) -> gvec4b = glte{gvec4f, gvec4b}(a, b);

fn ggt{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' < ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn gt(a: gu32, b: gu32) -> gbool = ggt{gu32, gbool}(a, b);
export fn gt{T}(a: gu32, b: T) -> gbool = ggt{gu32, gbool}(a, b.gu32);
export fn gt{T}(a: T, b: gu32) -> gbool = ggt{gu32, gbool}(a.gu32, b);
export fn gt(a: gi32, b: gi32) -> gbool = ggt{gi32, gbool}(a, b);
export fn gt{T}(a: gi32, b: T) -> gbool = ggt{gi32, gbool}(a, b.gi32);
export fn gt{T}(a: T, b: gi32) -> gbool = ggt{gi32, gbool}(a.gi32, b);
export fn gt(a: gf32, b: gf32) -> gbool = ggt{gf32, gbool}(a, b);
export fn gt{T}(a: gf32, b: T) -> gbool = ggt{gf32, gbool}(a, b.gf32);
export fn gt{T}(a: T, b: gf32) -> gbool = ggt{gf32, gbool}(a.gf32, b);
export fn gt(a: gvec2u, b: gvec2u) -> gvec2b = ggt{gvec2u, gvec2b}(a, b);
export fn gt(a: gvec2i, b: gvec2i) -> gvec2b = ggt{gvec2i, gvec2b}(a, b);
export fn gt(a: gvec2f, b: gvec2f) -> gvec2b = ggt{gvec2f, gvec2b}(a, b);
export fn gt(a: gvec3u, b: gvec3u) -> gvec3b = ggt{gvec3u, gvec3b}(a, b);
export fn gt(a: gvec3i, b: gvec3i) -> gvec3b = ggt{gvec3i, gvec3b}(a, b);
export fn gt(a: gvec3f, b: gvec3f) -> gvec3b = ggt{gvec3f, gvec3b}(a, b);
export fn gt(a: gvec4u, b: gvec4u) -> gvec4b = ggt{gvec4u, gvec4b}(a, b);
export fn gt(a: gvec4i, b: gvec4i) -> gvec4b = ggt{gvec4i, gvec4b}(a, b);
export fn gt(a: gvec4f, b: gvec4f) -> gvec4b = ggt{gvec4f, gvec4b}(a, b);

fn ggte{I, O}(a: I, b: I) -> O {
  let varName = '('.concat(a.varName).concat(' <= ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn gte(a: gu32, b: gu32) -> gbool = ggte{gu32, gbool}(a, b);
export fn gte{T}(a: gu32, b: T) -> gbool = ggte{gu32, gbool}(a, b.gu32);
export fn gte{T}(a: T, b: gu32) -> gbool = ggte{gu32, gbool}(a.gu32, b);
export fn gte(a: gi32, b: gi32) -> gbool = ggte{gi32, gbool}(a, b);
export fn gte{T}(a: gi32, b: T) -> gbool = ggte{gi32, gbool}(a, b.gi32);
export fn gte{T}(a: T, b: gi32) -> gbool = ggte{gi32, gbool}(a.gi32, b);
export fn gte(a: gf32, b: gf32) -> gbool = ggte{gf32, gbool}(a, b);
export fn gte{T}(a: gf32, b: T) -> gbool = ggte{gf32, gbool}(a, b.gf32);
export fn gte{T}(a: T, b: gf32) -> gbool = ggte{gf32, gbool}(a.gf32, b);
export fn gte(a: gvec2u, b: gvec2u) -> gvec2b = ggte{gvec2u, gvec2b}(a, b);
export fn gte(a: gvec2i, b: gvec2i) -> gvec2b = ggte{gvec2i, gvec2b}(a, b);
export fn gte(a: gvec2f, b: gvec2f) -> gvec2b = ggte{gvec2f, gvec2b}(a, b);
export fn gte(a: gvec3u, b: gvec3u) -> gvec3b = ggte{gvec3u, gvec3b}(a, b);
export fn gte(a: gvec3i, b: gvec3i) -> gvec3b = ggte{gvec3i, gvec3b}(a, b);
export fn gte(a: gvec3f, b: gvec3f) -> gvec3b = ggte{gvec3f, gvec3b}(a, b);
export fn gte(a: gvec4u, b: gvec4u) -> gvec4b = ggte{gvec4u, gvec4b}(a, b);
export fn gte(a: gvec4i, b: gvec4i) -> gvec4b = ggte{gvec4i, gvec4b}(a, b);
export fn gte(a: gvec4f, b: gvec4f) -> gvec4b = ggte{gvec4f, gvec4b}(a, b);

fn if{T}(c: gbool, t: T, f: T) -> T {
  let varName = "if_".concat(uuid().string.replace('-', '_'));
  let tBody = t.statements.Array.map(fn (kv: (string, string)) -> string {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () -> string = "", fn () -> string {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let fBody = f.statements.Array.map(fn (kv: (string, string)) -> string {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () -> string = "", fn () -> string {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let statement = "var "
    .concat(varName)
    .concat(": ")
    .concat(t.typeName)
    .concat("; if ")
    .concat(c.varName)
    .concat(" { ")
    .concat(tBody)
    .concat('; ')
    .concat(varName)
    .concat(' = ')
    .concat(t.varName)
    .concat("; } else { ")
    .concat(fBody)
    .concat('; ')
    .concat(varName)
    .concat(' = ')
    .concat(f.varName)
    .concat('; }');
  let statements = c.statements.concat(Dict(varName, statement));
  let buffers = c.buffers.union(t.buffers).union(f.buffers);
  return {T}(varName, statements, buffers);
}
fn if{T}(c: gbool, t: () -> T, f: () -> T) -> T = if(c, t(), f());
fn if{T}(c: gbool, t: T, f: T) -> T {
  let varName = "select("
    .concat(f.varName)
    .concat(', ')
    .concat(t.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = f.statements.concat(t.statements).concat(c.statements);
  let buffers = f.buffers.union(t.buffers).union(c.buffers);
  return {T}(varName, statements, buffers);
}

// GPU Boolean and Bitwise methods

fn gnot{I}(a: I) -> I {
  let varName = '(!'.concat(a.varName).concat(')');
  let statements = a.statements.clone();
  let buffers = a.buffers.clone();
  return {I}(varName, statements, buffers);
}
export fn not(a: gu32) -> gu32 = gnot(a);
export fn not(a: gi32) -> gi32 = gnot(a);
export fn not(a: gbool) -> gbool = gnot(a);
export fn not(a: gvec2u) -> gvec2u = gnot(a);
export fn not(a: gvec2i) -> gvec2i = gnot(a);
export fn not(a: gvec2b) -> gvec2b = gnot(a);
export fn not(a: gvec3u) -> gvec3u = gnot(a);
export fn not(a: gvec3i) -> gvec3i = gnot(a);
export fn not(a: gvec3b) -> gvec3b = gnot(a);
export fn not(a: gvec4u) -> gvec4u = gnot(a);
export fn not(a: gvec4i) -> gvec4i = gnot(a);
export fn not(a: gvec4b) -> gvec4b = gnot(a);

fn gor{I}(a: I, b: I) -> I {
  let varName = '('.concat(a.varName).concat(' | ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn or(a: gu32, b: gu32) -> gu32 = gor(a, b);
export fn or{T}(a: gu32, b: T) -> gu32 = gor(a, b.gu32);
export fn or{T}(a: T, b: gu32) -> gu32 = gor(a.gu32, b);
export fn or(a: gi32, b: gi32) -> gi32 = gor(a, b);
export fn or{T}(a: gi32, b: T) -> gi32 = gor(a, b.gi32);
export fn or{T}(a: T, b: gi32) -> gi32 = gor(a.gi32, b);
export fn or(a: gbool, b: gbool) -> gbool = gor(a, b);
export fn or{T}(a: gbool, b: T) -> gbool = gor(a, b.gbool);
export fn or{T}(a: T, b: gbool) -> gbool = gor(a.gbool, b);
export fn or(a: gvec2u, b: gvec2u) -> gvec2u = gor(a, b);
export fn or(a: gvec2i, b: gvec2i) -> gvec2i = gor(a, b);
export fn or(a: gvec2b, b: gvec2b) -> gvec2b = gor(a, b);
export fn or(a: gvec3u, b: gvec3u) -> gvec3u = gor(a, b);
export fn or(a: gvec3i, b: gvec3i) -> gvec3i = gor(a, b);
export fn or(a: gvec3b, b: gvec3b) -> gvec3b = gor(a, b);
export fn or(a: gvec4u, b: gvec4u) -> gvec4u = gor(a, b);
export fn or(a: gvec4i, b: gvec4i) -> gvec4i = gor(a, b);
export fn or(a: gvec4b, b: gvec4b) -> gvec4b = gor(a, b);

fn gand{I}(a: I, b: I) -> I {
  let varName = '('.concat(a.varName).concat(' & ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn and(a: gu32, b: gu32) -> gu32 = gand(a, b);
export fn and{T}(a: gu32, b: T) -> gu32 = gand(a, b.gu32);
export fn and{T}(a: T, b: gu32) -> gu32 = gand(a.gu32, b);
export fn and(a: gi32, b: gi32) -> gi32 = gand(a, b);
export fn and{T}(a: gi32, b: T) -> gi32 = gand(a, b.gi32);
export fn and{T}(a: T, b: gi32) -> gi32 = gand(a.gi32, b);
export fn and(a: gbool, b: gbool) -> gbool = gand(a, b);
export fn and{T}(a: gbool, b: T) -> gbool = gand(a, b.gbool);
export fn and{T}(a: T, b: gbool) -> gbool = gand(a.gbool, b);
export fn and(a: gvec2u, b: gvec2u) -> gvec2u = gand(a, b);
export fn and(a: gvec2i, b: gvec2i) -> gvec2i = gand(a, b);
export fn and(a: gvec2b, b: gvec2b) -> gvec2b = gand(a, b);
export fn and(a: gvec3u, b: gvec3u) -> gvec3u = gand(a, b);
export fn and(a: gvec3i, b: gvec3i) -> gvec3i = gand(a, b);
export fn and(a: gvec3b, b: gvec3b) -> gvec3b = gand(a, b);
export fn and(a: gvec4u, b: gvec4u) -> gvec4u = gand(a, b);
export fn and(a: gvec4i, b: gvec4i) -> gvec4i = gand(a, b);
export fn and(a: gvec4b, b: gvec4b) -> gvec4b = gand(a, b);

// There's no xor for bools in wgsl. Do I patch that over or leave it as an exercise to the reader?
fn gxor{I}(a: I, b: I) -> I {
  let varName = '('.concat(a.varName).concat(' ^ ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn and(a: gu32, b: gu32) -> gu32 = gand(a, b);
export fn and{T}(a: gu32, b: T) -> gu32 = gand(a, b.gu32);
export fn and{T}(a: T, b: gu32) -> gu32 = gand(a.gu32, b);
export fn and(a: gi32, b: gi32) -> gi32 = gand(a, b);
export fn and{T}(a: gi32, b: T) -> gi32 = gand(a, b.gi32);
export fn and{T}(a: T, b: gi32) -> gi32 = gand(a.gi32, b);
export fn and(a: gvec2u, b: gvec2u) -> gvec2u = gand(a, b);
export fn and(a: gvec2i, b: gvec2i) -> gvec2i = gand(a, b);
export fn and(a: gvec3u, b: gvec3u) -> gvec3u = gand(a, b);
export fn and(a: gvec3i, b: gvec3i) -> gvec3i = gand(a, b);
export fn and(a: gvec4u, b: gvec4u) -> gvec4u = gand(a, b);
export fn and(a: gvec4i, b: gvec4i) -> gvec4i = gand(a, b);

fn gshl{I}(a: I, b: I) -> I {
  let varName = '('.concat(a.varName).concat(' << ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn shl(a: gu32, b: gu32) -> gu32 = gshl(a, b);
export fn shl{T}(a: gu32, b: T) -> gu32 = gshl(a, b.gu32);
export fn shl{T}(a: T, b: gu32) -> gu32 = gshl(a.gu32, b);
export fn shl(a: gi32, b: gi32) -> gi32 = gshl(a, b);
export fn shl{T}(a: gi32, b: T) -> gi32 = gshl(a, b.gi32);
export fn shl{T}(a: T, b: gi32) -> gi32 = gshl(a.gi32, b);
export fn shl(a: gvec2u, b: gvec2u) -> gvec2u = gshl(a, b);
export fn shl(a: gvec2i, b: gvec2i) -> gvec2i = gshl(a, b);
export fn shl(a: gvec3u, b: gvec3u) -> gvec3u = gshl(a, b);
export fn shl(a: gvec3i, b: gvec3i) -> gvec3i = gshl(a, b);
export fn shl(a: gvec4u, b: gvec4u) -> gvec4u = gshl(a, b);
export fn shl(a: gvec4i, b: gvec4i) -> gvec4i = gshl(a, b);

fn gshr{I}(a: I, b: I) -> I {
  let varName = '('.concat(a.varName).concat(' >> ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn shr(a: gu32, b: gu32) -> gu32 = gshr(a, b);
export fn shr{T}(a: gu32, b: T) -> gu32 = gshr(a, b.gu32);
export fn shr{T}(a: T, b: gu32) -> gu32 = gshr(a.gu32, b);
export fn shr(a: gi32, b: gi32) -> gi32 = gshr(a, b);
export fn shr{T}(a: gi32, b: T) -> gi32 = gshr(a, b.gi32);
export fn shr{T}(a: T, b: gi32) -> gi32 = gshr(a.gi32, b);
export fn shr(a: gvec2u, b: gvec2u) -> gvec2u = gshr(a, b);
export fn shr(a: gvec2i, b: gvec2i) -> gvec2i = gshr(a, b);
export fn shr(a: gvec3u, b: gvec3u) -> gvec3u = gshr(a, b);
export fn shr(a: gvec3i, b: gvec3i) -> gvec3i = gshr(a, b);
export fn shr(a: gvec4u, b: gvec4u) -> gvec4u = gshr(a, b);
export fn shr(a: gvec4i, b: gvec4i) -> gvec4i = gshr(a, b);

// Bitcasting methods (TODO: Is there a better naming scheme possible?)

fn gbitcast{I, O}(v: I) -> O {
  let varName = 'bitcast<'.concat({O.typeName}()).concat('>(').concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return {O}(varName, statements, buffers);
}
export fn asU32(v: gu32) -> gu32 = v;
export fn asU32(v: gi32) -> gu32 = gbitcast{gi32, gu32}(v);
export fn asU32(v: gf32) -> gu32 = gbitcast{gf32, gu32}(v);
export fn asI32(v: gu32) -> gi32 = gbitcast{gu32, gi32}(v);
export fn asI32(v: gi32) -> gi32 = v;
export fn asI32(v: gf32) -> gi32 = gbitcast{gf32, gi32}(v);
export fn asF32(v: gu32) -> gf32 = gbitcast{gu32, gf32}(v);
export fn asF32(v: gi32) -> gi32 = gbitcast{gi32, gf32}(v);
export fn asF32(v: gf32) -> gf32 = v;
export fn asVec2u(v: gvec2u) -> gvec2u = v;
export fn asVec2u(v: gvec2i) -> gvec2u = gbitcast{gvec2i, gvec2u}(v);
export fn asVec2u(v: gvec2f) -> gvec2u = gbitcast{gvec2f, gvec2u}(v);
export fn asVec2i(v: gvec2u) -> gvec2i = gbitcast{gvec2u, gvec2i}(v);
export fn asVec2i(v: gvec2i) -> gvec2i = v;
export fn asVec2i(v: gvec2f) -> gvec2i = gbitcast{gvec2f, gvec2i}(v);
export fn asVec2f(v: gvec2u) -> gvec2f = gbitcast{gvec2u, gvec2f}(v);
export fn asVec2f(v: gvec2i) -> gvec2f = gbitcast{gvec2i, gvec2f}(v);
export fn asVec2f(v: gvec2f) -> gvec2f = v;
export fn asVec3u(v: gvec3u) -> gvec3u = v;
export fn asVec3u(v: gvec3i) -> gvec3u = gbitcast{gvec3i, gvec3u}(v);
export fn asVec3u(v: gvec3f) -> gvec3u = gbitcast{gvec3f, gvec3u}(v);
export fn asVec3i(v: gvec3u) -> gvec3i = gbitcast{gvec3u, gvec3i}(v);
export fn asVec3i(v: gvec3i) -> gvec3i = v;
export fn asVec3i(v: gvec3f) -> gvec3i = gbitcast{gvec3f, gvec3i}(v);
export fn asVec3f(v: gvec3u) -> gvec3f = gbitcast{gvec3u, gvec3f}(v);
export fn asVec3f(v: gvec3i) -> gvec3f = gbitcast{gvec3i, gvec3f}(v);
export fn asVec3f(v: gvec3f) -> gvec3f = v;
export fn asVec4u(v: gvec4u) -> gvec4u = v;
export fn asVec4u(v: gvec4i) -> gvec4u = gbitcast{gvec4i, gvec4u}(v);
export fn asVec4u(v: gvec4f) -> gvec4u = gbitcast{gvec4f, gvec4u}(v);
export fn asVec4i(v: gvec4u) -> gvec4i = gbitcast{gvec4u, gvec4i}(v);
export fn asVec4i(v: gvec4i) -> gvec4i = v;
export fn asVec4i(v: gvec4f) -> gvec4i = gbitcast{gvec4f, gvec4i}(v);
export fn asVec4f(v: gvec4u) -> gvec4f = gbitcast{gvec4u, gvec4f}(v);
export fn asVec4f(v: gvec4i) -> gvec4f = gbitcast{gvec4i, gvec4f}(v);
export fn asVec4f(v: gvec4f) -> gvec4f = v;

// GPU Vector functions

fn gevery{I}(v: I) -> gbool {
  let varName = 'all('.concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return gbool(varName, statements, buffers);
}
export fn every(v: gvec2b) -> gbool = gevery(v);
export fn every(v: gvec3b) -> gbool = gevery(v);
export fn every(v: gvec4b) -> gbool = gevery(v);

fn gsome{I}(v: I) -> gbool {
  let varName = 'any('.concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return gbool(varName, statements, buffers);
}
export fn some(v: gvec2b) -> gbool = gsome(v);
export fn some(v: gvec3b) -> gbool = gsome(v);
export fn some(v: gvec4b) -> gbool = gsome(v);

fn piecewiseIf{C, T}(c: C, t: T, f: T) -> T {
  let varName = "select("
    .concat(f.varName)
    .concat(', ')
    .concat(t.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = f.statements.concat(t.statements).concat(c.statements);
  let buffers = f.buffers.union(t.buffers).union(c.buffers);
  return {T}(varName, statements, buffers);
}
export fn if(c: gvec2b, t: gvec2u, f: gvec2u) -> gvec2u = piecewiseIf{gvec2b, gvec2u}(c, t, f);
export fn if(c: gvec2b, t: gvec2i, f: gvec2i) -> gvec2i = piecewiseIf{gvec2b, gvec2i}(c, t, f);
export fn if(c: gvec2b, t: gvec2f, f: gvec2f) -> gvec2f = piecewiseIf{gvec2b, gvec2f}(c, t, f);
export fn if(c: gvec2b, t: gvec2b, f: gvec2b) -> gvec2b = piecewiseIf{gvec2b, gvec2b}(c, t, f);
export fn if(c: gvec3b, t: gvec3u, f: gvec3u) -> gvec3u = piecewiseIf{gvec3b, gvec3u}(c, t, f);
export fn if(c: gvec3b, t: gvec3i, f: gvec3i) -> gvec3i = piecewiseIf{gvec3b, gvec3i}(c, t, f);
export fn if(c: gvec3b, t: gvec3f, f: gvec3f) -> gvec3f = piecewiseIf{gvec3b, gvec3f}(c, t, f);
export fn if(c: gvec3b, t: gvec3b, f: gvec3b) -> gvec3b = piecewiseIf{gvec3b, gvec3b}(c, t, f);
export fn if(c: gvec4b, t: gvec4u, f: gvec4u) -> gvec4u = piecewiseIf{gvec4b, gvec4u}(c, t, f);
export fn if(c: gvec4b, t: gvec4i, f: gvec4i) -> gvec4i = piecewiseIf{gvec4b, gvec4i}(c, t, f);
export fn if(c: gvec4b, t: gvec4f, f: gvec4f) -> gvec4f = piecewiseIf{gvec4b, gvec4f}(c, t, f);
export fn if(c: gvec4b, t: gvec4b, f: gvec4b) -> gvec4b = piecewiseIf{gvec4b, gvec4b}(c, t, f);

// GBuffer methods

// TODO: Support more than i32 for GBuffer
export fn map(gb: GBuffer, f: (gi32) -> gi32) -> GBuffer {
  let idx = gFor(gb.len);
  let val = gb[idx];
  let out = GBuffer(gb.len.mul(4));
  let compute = out[idx].store(f(val));
  compute.build.run;
  return out;
}
export fn map(gb: GBuffer, f: (gi32, gu32) -> gi32) -> GBuffer {
  let idx = gFor(gb.len);
  let val = gb[idx];
  let out = GBuffer(gb.len.mul(4));
  let compute = out[idx].store(f(val, idx));
  compute.build.run;
  return out;
}


/// Stdout/stderr-related bindings
// TODO: Rework this to just print anything that can be converted to `string` via interfaces
export fn print "print_duration" :: Duration;
export fn print{T} "println_result" :: T!;
export fn print{T} "println_maybe" :: T?;
export fn print{T} "print_vec" :: T[];
export fn print{T, N} "print_buffer" :: T[N];
export fn print{T} "print_vec_result" :: Array{T!};
export fn print "println_void" :: void;
export fn print{T} "println" :: T;
export fn eprint{T} "eprintln_result" :: T!;
export fn eprint{T} "eprintln_maybe" :: T?;
export fn eprint{T} "eprintln" :: T;

// TODO: Function resolution is effectively backwards at the moment. This is the fallback `getOr`,
// but it needs to be defined last instead of first.
export fn getOr{T, U}(v: U, d: T) -> T = {T}(v).getOr(d);

/// Built-in operator definitions
export infix add as + precedence 3;
export infix sub as - precedence 3;
export prefix neg as - precedence 6;
export infix mul as * precedence 4;
export infix div as / precedence 4;
export infix mod as % precedence 4;
// export infix template as % precedence 4;
export infix pow as ** precedence 5;
export infix and as & precedence 4;
export infix and as && precedence 4;
export infix or as | precedence 3;
export infix or as || precedence 3;
export infix xor as ^ precedence 3;
export prefix not as ! precedence 5;
export infix nand as !& precedence 4;
export infix nor as !| precedence 3;
export infix xnor as !^ precedence 3;
export infix eq as == precedence 1;
export infix neq as != precedence 1;
export infix lt as < precedence 1;
export infix lte as <= precedence 1;
export infix gt as > precedence 1;
export infix gte as >= precedence 1;
export prefix len as # precedence 1; // TODO: Is this useful?
export infix shl as << precedence 2;
export infix shr as >> precedence 2;
export infix wrl as <<< precedence 2;
export infix wrr as >>> precedence 2;
export infix store as = precedence 0;
