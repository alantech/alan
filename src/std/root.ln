/**
 * The Alan root scope. The functions and types it binds from Rust are either part of the standard
 * library, or are defined in the sibling root.rs file
 **/

/// Type system setup

// Declaration of the types the compiler-time type system is built on
export ctype Type; // Any kind of concrete type
export ctype Generic; // Any type that is a generic type (not yet realized into a concrete type)
export ctype Binds{T}; // A direct reference into the platform language's type system equivalen to a concrete type
export ctype BindsGeneric{T, N}; // A direct reference into the platform language's generic type system
export ctype Int; // An integer used *to define a type*, like the length of a fixed array
export ctype Float; // A float used to define a type. I have no idea why you'd want this, yet
export ctype Bool; // A bool used to define a type. Heavily used for conditional compilation
export ctype String; // A string used to define a type. Useful for conditional inclusion of files/code
export ctype Group{G}; // A grouping of type statements `()`. Useful to allow for tuples of tuples
export ctype Function{I, O}; // A function type, indicating the input and output of the function
export ctype Tuple{A, B}; // A tuple of two (or more) types in a single compound type
export ctype Field{L, V}; // Labeling a type with a property name. Useful to turn tuples into structs
export ctype Either{A, B}; // An either type, allowing the value to be from *one* of the specified types, kinda like Rust enums
export ctype AnyOf{A, B}; // The AnyOf type is kinda like a Tuple, in that all sub-types are present, but it only *resolves* into one of these types above it. Useful for choosing the "best" integer, or a particular function by name.
export ctype Buffer{T, S}; // A buffer type, a pre-allocated, fixed-length array of the specified type the specified amount
export ctype Array{T}; // An array type, a variable-length array of the specified type the specified amount. This would usually be an stdlib type built in the language itself, but we're just going to re-use the one in the platform language

// The following `ctype`s don't represent data but instead represent transforms that convert into one of the many ctypes above. (I did not expect to need so many of them.)
export ctype Fail{M}; // A special type that if ever encountered at compile time causes the compilation to fail with the specified error message. Useful with conditional types
export ctype Add{A, B}; // Combines the Int or Float types together at compile time into a new Int or Float. Fails if an Int and Float are mixed.
export ctype Sub{A, B}; // Same, but subtracts them
export ctype Mul{A, B}; // Multiplication
export ctype Div{A, B}; // Division
export ctype Mod{A, B}; // Modulus (remainder)
export ctype Pow{A, B}; // Exponentiation/Power
export ctype Min{A, B}; // Minimum value of the two
export ctype Max{A, B}; // Maximum value of the two
export ctype Neg{A}; // Negate the value
export ctype Len{A}; // Returns the length of the input type in terms of the number of elements it contains, which is most useful for Buffers, Tuples, and Either, causes a compiler failure for Arrays, and returns 1 for everything else
export ctype Size{T}; // Returns the size in bytes of the type in question, if possible, causing a compiler failure otherwise.
export ctype FileStr{F}; // Read a file and return a string constant, useful for including large strings from a separate, nearby file, or fails if it doesn't exist
export ctype Env{K}; // Read an environment variable at compile time and return a string of the value. Returns an empty string if the key doesn't exist. Intended to be used with...
export ctype EnvExists{K}; // Returns a boolean if the environment variable key exists at compile time, and...
export ctype If{C, A, B}; // A conditional type, if C is true, resolves to A, otherwise to B. There's also a simpler version...
export ctype If{C, T}; // That expects a two-type tuple and extracts the first tuple type for true and the second for false, which can be bound to symbolic syntax
export ctype Env{K, D}; // Finally, since the majority of the time this is what you'd want, this variant of `Env` takes a default value to use when the key does not exist, making this another conditional type
export ctype And{A, B}; // Performs a boolean or bitwise AND on the inputs, depending on type
export ctype Or{A, B}; // Performs a boolean or bitwise OR on the inputs
export ctype Xor{A, B}; // Performs a boolean or bitwise XOR on the inputs
export ctype Not{B}; // Inverts the boolean provided
export ctype Nand{A, B}; // Performs a boolean or bitwise NAND on the inputs
export ctype Nor{A, B}; // Performs a boolean or bitwise NOR on the inputs
export ctype Xnor{A, B}; // Performs a boolean or bitwise XNOR on the inputs (same as EQ for booleans)
export ctype Eq{A, B}; // Returns true if the two types are the same (or are the same int, float, bool, or string), false otherwise
export ctype Neq{A, B}; // Returns true if the two types are difference
export ctype Lt{A, B}; // Returns true if A is less than B (and are an int or float)
export ctype Lte{A, B}; // Returns true if A is less than or equal to B
export ctype Gt{A, B}; // Returns true if A is greater than B
export ctype Gte{A, B}; // Returns true if A is greater than or equal to B

// Defining derived types
export type void = ();
export type Error = Binds{"AlanError"};
export type Fallible{T} = Either{T, Error};
export type Maybe{T} = Either{T, ()};
export type Test = Eq{Env{"ALAN_TARGET"}, "test"};
export type Release = Eq{Env{"ALAN_TARGET"}, "release"};
export type Debug = Eq{Env{"ALAN_TARGET"}, "debug"};

// Defining the operators in the type system
export type infix Function as -> precedence 3; // I -> O, where I is the input and O is the output. With Tuples and Fields you can reconstruct arguments for functions.
export type infix Tuple as , precedence 0; // A, B, C, ... The tuple type combines with other tuple types to become a larger tuple type. To have a tuple of tuples, you need to `Group` the inner tuple, eg `(a, b), c`
export type infix Field as : precedence 1; // Foo: Bar, let's you specify a property access label for the type, useful for syntactic sugar on a tuple type and the Either type (eventually).
export type infix Either as | precedence 0; // A | B, the type has a singular value from only one of the types at once. `Result` is just `Either{T, Error}` and `Option` is just `Either{T, ()}` (or `Either{T, void}`, however we want to represent it, also might go with `Fallible` and `Maybe` instead of `Result` and `Option` as those feel more descriptive of what they are.
export type infix AnyOf as & precedence 0; // A & B, which can be passed to a function that takes A or B as necessary.
export type infix Buffer as [ precedence 1; // Technically allows `Foo[3` by itself to be valid syntax, but...
export type postfix Group as ] precedence 1; // Technically not necessary, but allows for `Foo[3]` to do the "right thing" and become a buffer of size 3, with a singular useless Group being wrapped around it (and then unwrapped on type generation). The only "bad" thing here is `Group` gets special behavior, matching the `(...)` syntax, so there's two ways to invoke a Group via symbols.
export type postfix Array as [] precedence 4; // Allows `Foo[]` to do the right thing
export type postfix Maybe as ? precedence 4; // Allows `Foo?` for nullable types. Should this have a precedence of 5?
export type postfix Fallible as ! precedence 4; // Allows `Foo!` for fallible types. Same question on the precedence.
export type infix Add as + precedence 2;
export type infix Sub as - precedence 2;
export type infix Mul as * precedence 3;
export type infix Div as / precedence 3;
export type infix Mod as % precedence 3;
export type infix Pow as ** precedence 4;
export type infix If as ?? precedence 1; // C puts this kind of thing as a very high precedence. I'm not sure if I want to follow it. I feel like that would force grouping parens everywhere.
export type infix And as && precedence 3;
export type infix Or as || precedence 2;
export type infix Xor as ^ precedence 2;
export type prefix Not as ! precedence 4; // TODO: Do we want `!` to mean `Not` or `Result` depending on where it's placed syntactically? Seems easily ambiguous
export type infix Nand as !& precedence 3;
export type infix Nor as !| precedence 2;
export type infix Xnor as !^ precedence 2;
export type infix Eq as == precedence 1;
export type infix Neq as != precedence 1;
export type infix Lt as < precedence 1;
export type infix Lte as <= precedence 1;
export type infix Gt as > precedence 1;
export type infix Gte as >= precedence 1;

// Binding the integer types
export type i8 = Binds{"i8"};
export type i16 = Binds{"i16"};
export type i32 = Binds{"i32"};
export type i64 = Binds{"i64"};
export type u8 = Binds{"u8"};
export type u16 = Binds{"u16"};
export type u32 = Binds{"u32"};
export type u64 = Binds{"u64"};

// Binding the float types
export type f32 = Binds{"f32"};
export type f64 = Binds{"f64"};

// Binding the string types
export type string = Binds{"String"};

// Binding the boolean types
export type bool = Binds{"bool"};

// Binding the exit code type
export type ExitCode = Binds{"std::process::ExitCode"};

// Binding the time types
export type Instant = Binds{"std::time::Instant"};
export type Duration = Binds{"std::time::Duration"};

// Binding the uuid type
export type uuid = Binds{"uuid::Uuid"};

// Binding the Dict and Set types
export type Dict{K, V} = BindsGeneric{"OrderedHashMap", K, V};
export type Set{V} = BindsGeneric{"std::collections::HashSet", V};

/// Functions for (potentially) every type
export fn clone{T}(v: T) -> T binds clone;
// TODO: The "proper" way to hash this consistently for all types is to decompose the input type
// into the various primitive types of Alan and then have hashing rules for each of them, which
// may themselves decompose, etc. This might be doable in Alan code on top of specialized hashing
// functions in Rust (as partially implemented here) or it might be better done as a special `hash`
// function created by the compiler for the specific type *if* ever actually used, walking the
// CType tree to determine the correct code to run. In either case, this is "good enough" for now.
export fn hash{T}(v: Array{T}) -> i64 binds hasharray;
export fn hash(v: string) -> i64 binds hashstring;
export fn hash{T}(v: T) -> i64 binds hash;
export fn void{T}(v: T) -> void {}
export fn void() -> void {}
export fn store{T}(a: T, b: T) -> T binds storeswap;

/// Fallible, Maybe, and Either functions
export fn getOr{T}(v: Maybe{T}, d: T) -> T binds maybe_get_or;
export fn getOr{T}(v: Fallible{T}, d: T) -> T binds fallible_get_or;
export fn Error{T}(m: string) -> Fallible{T} binds fallible_error;
export fn Error(m: string) -> Error binds bare_error;
export fn exists{T}(v: Maybe{T}) -> bool binds maybe_exists;

/// Signed Integer-related functions and function bindings
export fn i8(i: i8) -> i8 = i;
export fn i8(i: i16) -> i8 binds i16toi8;
export fn i8(i: i32) -> i8 binds i32toi8;
export fn i8(i: i64) -> i8 binds i64toi8;
export fn i8(i: u8) -> i8 binds u8toi8;
export fn i8(i: u16) -> i8 binds u16toi8;
export fn i8(i: u32) -> i8 binds u32toi8;
export fn i8(i: u64) -> i8 binds u64toi8;
export fn i8(f: f32) -> i8 binds f32toi8;
export fn i8(f: f64) -> i8 binds f64toi8;
export fn i8(s: string) -> Fallible{i8} binds stringtoi8;
export fn add(a: i8, b: i8) -> i8 binds addi8;
export fn sub(a: i8, b: i8) -> i8 binds subi8;
export fn mul(a: i8, b: i8) -> i8 binds muli8;
export fn div(a: i8, b: i8) -> i8 binds divi8;
export fn mod(a: i8, b: i8) -> i8 binds modi8;
export fn pow(a: i8, b: i8) -> i8 binds powi8;
export fn min(a: i8, b: i8) -> i8 binds mini8;
export fn max(a: i8, b: i8) -> i8 binds maxi8;
export fn neg(a: i8) -> i8 binds negi8;
export fn and(a: i8, b: i8) -> i8 binds andi8;
export fn or(a: i8, b: i8) -> i8 binds ori8;
export fn xor(a: i8, b: i8) -> i8 binds xori8;
export fn not(a: i8) -> i8 binds noti8;
export fn nand(a: i8, b: i8) -> i8 binds nandi8;
export fn nor(a: i8, b: i8) -> i8 binds nori8;
export fn xnor(a: i8, b: i8) -> i8 binds xnori8;
export fn eq(a: i8, b: i8) -> bool binds eqi8;
export fn neq(a: i8, b: i8) -> bool binds neqi8;
export fn lt(a: i8, b: i8) -> bool binds lti8;
export fn lte(a: i8, b: i8) -> bool binds ltei8;
export fn gt(a: i8, b: i8) -> bool binds gti8;
export fn gte(a: i8, b: i8) -> bool binds gtei8;
export fn shl(a: i8, b: i8) -> i8 binds shli8;
export fn shr(a: i8, b: i8) -> i8 binds shri8;
export fn wrl(a: i8, b: i8) -> i8 binds wrli8;
export fn wrr(a: i8, b: i8) -> i8 binds wrri8;

export fn i16(i: i8) -> i16 binds i8toi16;
export fn i16(i: i16) -> i16 = i;
export fn i16(i: i32) -> i16 binds i32toi16;
export fn i16(i: i64) -> i16 binds i64toi16;
export fn i16(i: u8) -> i16 binds u8toi16;
export fn i16(i: u16) -> i16 binds u16toi16;
export fn i16(i: u32) -> i16 binds u32toi16;
export fn i16(i: u64) -> i16 binds u64toi16;
export fn i16(f: f32) -> i16 binds f32toi16;
export fn i16(f: f64) -> i16 binds f64toi16;
export fn i16(s: string) -> Fallible{i16} binds stringtoi16;
export fn add(a: i16, b: i16) -> i16 binds addi16;
export fn sub(a: i16, b: i16) -> i16 binds subi16;
export fn mul(a: i16, b: i16) -> i16 binds muli16;
export fn div(a: i16, b: i16) -> i16 binds divi16;
export fn mod(a: i16, b: i16) -> i16 binds modi16;
export fn pow(a: i16, b: i16) -> i16 binds powi16;
export fn min(a: i16, b: i16) -> i16 binds mini16;
export fn max(a: i16, b: i16) -> i16 binds maxi16;
export fn neg(a: i16) -> i16 binds negi16;
export fn and(a: i16, b: i16) -> i16 binds andi16;
export fn or(a: i16, b: i16) -> i16 binds ori16;
export fn xor(a: i16, b: i16) -> i16 binds xori16;
export fn not(a: i16) -> i16 binds noti16;
export fn nand(a: i16, b: i16) -> i16 binds nandi16;
export fn nor(a: i16, b: i16) -> i16 binds nori16;
export fn xnor(a: i16, b: i16) -> i16 binds xnori16;
export fn eq(a: i16, b: i16) -> bool binds eqi16;
export fn neq(a: i16, b: i16) -> bool binds neqi16;
export fn lt(a: i16, b: i16) -> bool binds lti16;
export fn lte(a: i16, b: i16) -> bool binds ltei16;
export fn gt(a: i16, b: i16) -> bool binds gti16;
export fn gte(a: i16, b: i16) -> bool binds gtei16;
export fn shl(a: i16, b: i16) -> i16 binds shli16;
export fn shr(a: i16, b: i16) -> i16 binds shri16;
export fn wrl(a: i16, b: i16) -> i16 binds wrli16;
export fn wrr(a: i16, b: i16) -> i16 binds wrri16;

export fn i32(i: i8) -> i32 binds i8toi32;
export fn i32(i: i16) -> i32 binds i16toi32;
export fn i32(i: i32) -> i32 = i;
export fn i32(i: i64) -> i32 binds i64toi32;
export fn i32(i: u8) -> i32 binds u8toi32;
export fn i32(i: u16) -> i32 binds u16toi32;
export fn i32(i: u32) -> i32 binds u32toi32;
export fn i32(i: u64) -> i32 binds u64toi32;
export fn i32(f: f32) -> i32 binds f32toi32;
export fn i32(f: f64) -> i32 binds f64toi32;
export fn i32(s: string) -> Fallible{i32} binds stringtoi32;
export fn add(a: i32, b: i32) -> i32 binds addi32;
export fn sub(a: i32, b: i32) -> i32 binds subi32;
export fn mul(a: i32, b: i32) -> i32 binds muli32;
export fn div(a: i32, b: i32) -> i32 binds divi32;
export fn mod(a: i32, b: i32) -> i32 binds modi32;
export fn pow(a: i32, b: i32) -> i32 binds powi32;
export fn min(a: i32, b: i32) -> i32 binds mini32;
export fn max(a: i32, b: i32) -> i32 binds maxi32;
export fn neg(a: i32) -> i32 binds negi32;
export fn and(a: i32, b: i32) -> i32 binds andi32;
export fn or(a: i32, b: i32) -> i32 binds ori32;
export fn xor(a: i32, b: i32) -> i32 binds xori32;
export fn not(a: i32) -> i32 binds noti32;
export fn nand(a: i32, b: i32) -> i32 binds nandi32;
export fn nor(a: i32, b: i32) -> i32 binds nori32;
export fn xnor(a: i32, b: i32) -> i32 binds xnori32;
export fn eq(a: i32, b: i32) -> bool binds eqi32;
export fn neq(a: i32, b: i32) -> bool binds neqi32;
export fn lt(a: i32, b: i32) -> bool binds lti32;
export fn lte(a: i32, b: i32) -> bool binds ltei32;
export fn gt(a: i32, b: i32) -> bool binds gti32;
export fn gte(a: i32, b: i32) -> bool binds gtei32;
export fn shl(a: i32, b: i32) -> i32 binds shli32;
export fn shr(a: i32, b: i32) -> i32 binds shri32;
export fn wrl(a: i32, b: i32) -> i32 binds wrli32;
export fn wrr(a: i32, b: i32) -> i32 binds wrri32;

export fn i64(i: i8) -> i64 binds i8toi64;
export fn i64(i: i16) -> i64 binds i16toi64;
export fn i64(i: i32) -> i64 binds i32toi64;
export fn i64(i: i64) -> i64 = i;
export fn i64(i: u8) -> i64 binds u8toi64;
export fn i64(i: u16) -> i64 binds u16toi64;
export fn i64(i: u32) -> i64 binds u32toi64;
export fn i64(i: u64) -> i64 binds u64toi64;
export fn i64(f: f32) -> i64 binds f32toi64;
export fn i64(f: f64) -> i64 binds f64toi64;
export fn i64(s: string) -> Fallible{i64} binds stringtoi64;
export fn add(a: i64, b: i64) -> i64 binds addi64;
export fn sub(a: i64, b: i64) -> i64 binds subi64;
export fn mul(a: i64, b: i64) -> i64 binds muli64;
export fn div(a: i64, b: i64) -> i64 binds divi64;
export fn mod(a: i64, b: i64) -> i64 binds modi64;
export fn pow(a: i64, b: i64) -> i64 binds powi64;
export fn min(a: i64, b: i64) -> i64 binds mini64;
export fn max(a: i64, b: i64) -> i64 binds maxi64;
export fn neg(a: i64) -> i64 binds negi64;
export fn and(a: i64, b: i64) -> i64 binds andi64;
export fn or(a: i64, b: i64) -> i64 binds ori64;
export fn xor(a: i64, b: i64) -> i64 binds xori64;
export fn not(a: i64) -> i64 binds noti64;
export fn nand(a: i64, b: i64) -> i64 binds nandi64;
export fn nor(a: i64, b: i64) -> i64 binds nori64;
export fn xnor(a: i64, b: i64) -> i64 binds xnori64;
export fn eq(a: i64, b: i64) -> bool binds eqi64;
export fn neq(a: i64, b: i64) -> bool binds neqi64;
export fn lt(a: i64, b: i64) -> bool binds lti64;
export fn lte(a: i64, b: i64) -> bool binds ltei64;
export fn gt(a: i64, b: i64) -> bool binds gti64;
export fn gte(a: i64, b: i64) -> bool binds gtei64;
export fn shl(a: i64, b: i64) -> i64 binds shli64;
export fn shr(a: i64, b: i64) -> i64 binds shri64;
export fn wrl(a: i64, b: i64) -> i64 binds wrli64;
export fn wrr(a: i64, b: i64) -> i64 binds wrri64;

/// Unsigned Integer-related functions and function bindings
export fn u8(i: i8) -> u8 binds i8tou8;
export fn u8(i: i16) -> u8 binds i16tou8;
export fn u8(i: i32) -> u8 binds i32tou8;
export fn u8(i: i64) -> u8 binds i64tou8;
export fn u8(i: u8) -> u8 = i;
export fn u8(i: u16) -> u8 binds u16tou8;
export fn u8(i: u32) -> u8 binds u32tou8;
export fn u8(i: u64) -> u8 binds u64tou8;
export fn u8(f: f32) -> u8 binds f32tou8;
export fn u8(f: f64) -> u8 binds f64tou8;
export fn u8(s: string) -> Fallible{u8} binds stringtou8;
export fn add(a: u8, b: u8) -> u8 binds addu8;
export fn sub(a: u8, b: u8) -> u8 binds subu8;
export fn mul(a: u8, b: u8) -> u8 binds mulu8;
export fn div(a: u8, b: u8) -> u8 binds divu8;
export fn mod(a: u8, b: u8) -> u8 binds modu8;
export fn pow(a: u8, b: u8) -> u8 binds powu8;
export fn min(a: u8, b: u8) -> u8 binds minu8;
export fn max(a: u8, b: u8) -> u8 binds maxu8;
export fn and(a: u8, b: u8) -> u8 binds andu8;
export fn or(a: u8, b: u8) -> u8 binds oru8;
export fn xor(a: u8, b: u8) -> u8 binds xoru8;
export fn not(a: u8) -> u8 binds notu8;
export fn nand(a: u8, b: u8) -> u8 binds nandu8;
export fn nor(a: u8, b: u8) -> u8 binds noru8;
export fn xnor(a: u8, b: u8) -> u8 binds xnoru8;
export fn eq(a: u8, b: u8) -> bool binds equ8;
export fn neq(a: u8, b: u8) -> bool binds nequ8;
export fn lt(a: u8, b: u8) -> bool binds ltu8;
export fn lte(a: u8, b: u8) -> bool binds lteu8;
export fn gt(a: u8, b: u8) -> bool binds gtu8;
export fn gte(a: u8, b: u8) -> bool binds gteu8;
export fn shl(a: u8, b: u8) -> u8 binds shlu8;
export fn shr(a: u8, b: u8) -> u8 binds shru8;
export fn wrl(a: u8, b: u8) -> u8 binds wrlu8;
export fn wrr(a: u8, b: u8) -> u8 binds wrru8;

export fn u16(i: i8) -> u16 binds i8tou16;
export fn u16(i: i16) -> u16 binds i16tou16;
export fn u16(i: i32) -> u16 binds i32tou16;
export fn u16(i: i64) -> u16 binds i64tou16;
export fn u16(i: u8) -> u16 binds u8tou16;
export fn u16(i: u16) -> u16 = i;
export fn u16(i: u32) -> u16 binds u32tou16;
export fn u16(i: u64) -> u16 binds u64tou16;
export fn u16(f: f32) -> u16 binds f32tou16;
export fn u16(f: f64) -> u16 binds f64tou16;
export fn u16(s: string) -> Fallible{u16} binds stringtou16;
export fn add(a: u16, b: u16) -> u16 binds addu16;
export fn sub(a: u16, b: u16) -> u16 binds subu16;
export fn mul(a: u16, b: u16) -> u16 binds mulu16;
export fn div(a: u16, b: u16) -> u16 binds divu16;
export fn mod(a: u16, b: u16) -> u16 binds modu16;
export fn pow(a: u16, b: u16) -> u16 binds powu16;
export fn min(a: u16, b: u16) -> u16 binds minu16;
export fn max(a: u16, b: u16) -> u16 binds maxu16;
export fn and(a: u16, b: u16) -> u16 binds andu16;
export fn or(a: u16, b: u16) -> u16 binds oru16;
export fn xor(a: u16, b: u16) -> u16 binds xoru16;
export fn not(a: u16) -> u16 binds notu16;
export fn nand(a: u16, b: u16) -> u16 binds nandu16;
export fn nor(a: u16, b: u16) -> u16 binds noru16;
export fn xnor(a: u16, b: u16) -> u16 binds xnoru16;
export fn eq(a: u16, b: u16) -> bool binds equ16;
export fn neq(a: u16, b: u16) -> bool binds nequ16;
export fn lt(a: u16, b: u16) -> bool binds ltu16;
export fn lte(a: u16, b: u16) -> bool binds lteu16;
export fn gt(a: u16, b: u16) -> bool binds gtu16;
export fn gte(a: u16, b: u16) -> bool binds gteu16;
export fn shl(a: u16, b: u16) -> u16 binds shlu16;
export fn shr(a: u16, b: u16) -> u16 binds shru16;
export fn wrl(a: u16, b: u16) -> u16 binds wrlu16;
export fn wrr(a: u16, b: u16) -> u16 binds wrru16;

export fn u32(i: i8) -> u32 binds i8tou32;
export fn u32(i: i16) -> u32 binds i16tou32;
export fn u32(i: i32) -> u32 binds i32tou32;
export fn u32(i: i64) -> u32 binds i64tou32;
export fn u32(i: u8) -> u32 binds u8tou32;
export fn u32(i: u16) -> u32 binds u16tou32;
export fn u32(i: u32) -> u32 = i;
export fn u32(i: u64) -> u32 binds u64tou32;
export fn u32(f: f32) -> u32 binds f32tou32;
export fn u32(f: f64) -> u32 binds f64tou32;
export fn u32(s: string) -> Fallible{u32} binds stringtou32;
export fn add(a: u32, b: u32) -> u32 binds addu32;
export fn sub(a: u32, b: u32) -> u32 binds subu32;
export fn mul(a: u32, b: u32) -> u32 binds mulu32;
export fn div(a: u32, b: u32) -> u32 binds divu32;
export fn mod(a: u32, b: u32) -> u32 binds modu32;
export fn pow(a: u32, b: u32) -> u32 binds powu32;
export fn min(a: u32, b: u32) -> u32 binds minu32;
export fn max(a: u32, b: u32) -> u32 binds maxu32;
export fn and(a: u32, b: u32) -> u32 binds andu32;
export fn or(a: u32, b: u32) -> u32 binds oru32;
export fn xor(a: u32, b: u32) -> u32 binds xoru32;
export fn not(a: u32) -> u32 binds notu32;
export fn nand(a: u32, b: u32) -> u32 binds nandu32;
export fn nor(a: u32, b: u32) -> u32 binds noru32;
export fn xnor(a: u32, b: u32) -> u32 binds xnoru32;
export fn eq(a: u32, b: u32) -> bool binds equ32;
export fn neq(a: u32, b: u32) -> bool binds nequ32;
export fn lt(a: u32, b: u32) -> bool binds ltu32;
export fn lte(a: u32, b: u32) -> bool binds lteu32;
export fn gt(a: u32, b: u32) -> bool binds gtu32;
export fn gte(a: u32, b: u32) -> bool binds gteu32;
export fn shl(a: u32, b: u32) -> u32 binds shlu32;
export fn shr(a: u32, b: u32) -> u32 binds shru32;
export fn wrl(a: u32, b: u32) -> u32 binds wrlu32;
export fn wrr(a: u32, b: u32) -> u32 binds wrru32;

export fn u64(i: i8) -> u64 binds i8tou64;
export fn u64(i: i16) -> u64 binds i16tou64;
export fn u64(i: i32) -> u64 binds i32tou64;
export fn u64(i: i64) -> u64 binds i64tou64;
export fn u64(i: u8) -> u64 binds u8tou64;
export fn u64(i: u16) -> u64 binds u16tou64;
export fn u64(i: u32) -> u64 binds u32tou64;
export fn u64(i: u64) -> u64 = i;
export fn u64(f: f32) -> u64 binds f32tou64;
export fn u64(f: f64) -> u64 binds f64tou64;
export fn u64(s: string) -> Fallible{u64} binds stringtou64;
export fn add(a: u64, b: u64) -> u64 binds addu64;
export fn sub(a: u64, b: u64) -> u64 binds subu64;
export fn mul(a: u64, b: u64) -> u64 binds mulu64;
export fn div(a: u64, b: u64) -> u64 binds divu64;
export fn mod(a: u64, b: u64) -> u64 binds modu64;
export fn pow(a: u64, b: u64) -> u64 binds powu64;
export fn min(a: u64, b: u64) -> u64 binds minu64;
export fn max(a: u64, b: u64) -> u64 binds maxu64;
export fn and(a: u64, b: u64) -> u64 binds andu64;
export fn or(a: u64, b: u64) -> u64 binds oru64;
export fn xor(a: u64, b: u64) -> u64 binds xoru64;
export fn not(a: u64) -> u64 binds notu64;
export fn nand(a: u64, b: u64) -> u64 binds nandu64;
export fn nor(a: u64, b: u64) -> u64 binds noru64;
export fn xnor(a: u64, b: u64) -> u64 binds xnoru64;
export fn eq(a: u64, b: u64) -> bool binds equ64;
export fn neq(a: u64, b: u64) -> bool binds nequ64;
export fn lt(a: u64, b: u64) -> bool binds ltu64;
export fn lte(a: u64, b: u64) -> bool binds lteu64;
export fn gt(a: u64, b: u64) -> bool binds gtu64;
export fn gte(a: u64, b: u64) -> bool binds gteu64;
export fn shl(a: u64, b: u64) -> u64 binds shlu64;
export fn shr(a: u64, b: u64) -> u64 binds shru64;
export fn wrl(a: u64, b: u64) -> u64 binds wrlu64;
export fn wrr(a: u64, b: u64) -> u64 binds wrru64;

/// Float-related functions and function bindings
export fn f32(i: i8) -> f32 binds i8tof32;
export fn f32(i: i16) -> f32 binds i16tof32;
export fn f32(i: i32) -> f32 binds i32tof32;
export fn f32(i: i64) -> f32 binds i64tof32;
export fn f32(u: u8) -> f32 binds u8tof32;
export fn f32(u: u16) -> f32 binds u16tof32;
export fn f32(u: u32) -> f32 binds u32tof32;
export fn f32(u: u64) -> f32 binds u64tof32;
export fn f32(f: f32) -> f32 = f;
export fn f32(f: f64) -> f32 binds f64tof32;
export fn f32(s: string) -> Fallible{f32} binds stringtof32;
export fn add(a: f32, b: f32) -> f32 binds addf32;
export fn sub(a: f32, b: f32) -> f32 binds subf32;
export fn mul(a: f32, b: f32) -> f32 binds mulf32;
export fn div(a: f32, b: f32) -> f32 binds divf32;
export fn sqrt(f: f32) -> f32 binds sqrtf32;
export fn pow(a: f32, b: f32) -> f32 binds powf32;
export fn min(a: f32, b: f32) -> f32 binds minf32;
export fn max(a: f32, b: f32) -> f32 binds maxf32;
export fn neg(a: f32) -> f32 binds negf32;
export fn neg(a: Fallible{f32}) -> Fallible{f32} binds negf32_result;
export fn eq(a: f32, b: f32) -> bool binds eqf32;
export fn neq(a: f32, b: f32) -> bool binds neqf32;
export fn lt(a: f32, b: f32) -> bool binds ltf32;
export fn lte(a: f32, b: f32) -> bool binds ltef32;
export fn gt(a: f32, b: f32) -> bool binds gtf32;
export fn gte(a: f32, b: f32) -> bool binds gtef32;

export fn f64(i: i8) -> f64 binds i8tof64;
export fn f64(i: i16) -> f64 binds i16tof64;
export fn f64(i: i32) -> f64 binds i32tof64;
export fn f64(i: i64) -> f64 binds i64tof64;
export fn f64(u: u8) -> f64 binds u8tof64;
export fn f64(u: u16) -> f64 binds u16tof64;
export fn f64(u: u32) -> f64 binds u32tof64;
export fn f64(u: u64) -> f64 binds u64tof64;
export fn f64(f: f32) -> f64 binds f32tof64;
export fn f64(f: f64) -> f64 = f;
export fn f64(s: string) -> Fallible{f64} binds stringtof64;
export fn add(a: f64, b: f64) -> f64 binds addf64;
export fn sub(a: f64, b: f64) -> f64 binds subf64;
export fn mul(a: f64, b: f64) -> f64 binds mulf64;
export fn div(a: f64, b: f64) -> f64 binds divf64;
export fn sqrt(f: f64) -> f64 binds sqrtf64;
export fn pow(a: f64, b: f64) -> f64 binds powf64;
export fn min(a: f64, b: f64) -> f64 binds minf64;
export fn max(a: f64, b: f64) -> f64 binds maxf64;
export fn neg(a: f64) -> f64 binds negf64;
export fn eq(a: f64, b: f64) -> bool binds eqf64;
export fn neq(a: f64, b: f64) -> bool binds neqf64;
export fn lt(a: f64, b: f64) -> bool binds ltf64;
export fn lte(a: f64, b: f64) -> bool binds ltef64;
export fn gt(a: f64, b: f64) -> bool binds gtf64;
export fn gte(a: f64, b: f64) -> bool binds gtef64;

/// String related bindings
export fn string(i: i8) -> string binds i8tostring;
export fn string(i: i16) -> string binds i16tostring;
export fn string(i: i32) -> string binds i32tostring;
export fn string(i: i64) -> string binds i64tostring;
export fn string(i: u8) -> string binds u8tostring;
export fn string(i: u16) -> string binds u16tostring;
export fn string(i: u32) -> string binds u32tostring;
export fn string(i: u64) -> string binds u64tostring;
export fn string(f: f32) -> string binds f32tostring;
export fn string(f: f64) -> string binds f64tostring;
export fn string(b: bool) -> string binds booltostring;
export fn string(s: string) -> string = s;
export fn concat(a: string, b: string) -> string binds concatstring;
export fn repeat(a: string, n: i64) -> string binds repeatstring;
export fn replace(s: string, o: string, n: string) -> string binds replacestring;
export fn split(a: string, b: string) -> string[] binds splitstring;
export fn len(a: string) -> i64 binds lenstring;
export fn get(a: string, i: i64) -> Fallible{string} binds getstring;
export fn trim(a: string) -> string binds trimstring;
export fn index(a: string, b: string) -> Fallible{i64} binds indexstring;
export fn min(a: string, b: string) -> string binds minstring;
export fn max(a: string, b: string) -> string binds maxstring;
export fn eq(a: string, b: string) -> bool binds eqstring;
export fn neq(a: string, b: string) -> bool binds neqstring;
export fn lt(a: string, b: string) -> bool binds ltstring;
export fn lte(a: string, b: string) -> bool binds ltestring;
export fn gt(a: string, b: string) -> bool binds gtstring;
export fn gte(a: string, b: string) -> bool binds gtestring;
export fn join(a: Array{string}, s: string) -> string binds joinstring;
export fn join{S}(a: Buffer{string, S}, s: string) -> string binds bufferjoinstring;

/// Boolean related bindings
export fn bool(i: i8) -> bool binds i8tobool;
export fn bool(i: i16) -> bool binds i16tobool;
export fn bool(i: i32) -> bool binds i32tobool;
export fn bool(i: i64) -> bool binds i64tobool;
export fn bool(i: u8) -> bool binds u8tobool;
export fn bool(i: u16) -> bool binds u16tobool;
export fn bool(i: u32) -> bool binds u32tobool;
export fn bool(i: u64) -> bool binds u64tobool;
export fn bool(f: f32) -> bool binds f32tobool;
export fn bool(f: f64) -> bool binds f64tobool;
export fn bool(s: string) -> bool binds stringtobool;
export fn bool(b: bool) -> bool = b;
export fn and(a: bool, b: bool) -> bool binds andbool;
export fn or(a: bool, b: bool) -> bool binds orbool;
export fn xor(a: bool, b: bool) -> bool binds xorbool;
export fn not(a: bool) -> bool binds notbool;
export fn nand(a: bool, b: bool) -> bool binds nandbool;
export fn nor(a: bool, b: bool) -> bool binds norbool;
export fn xnor(a: bool, b: bool) -> bool binds xnorbool;
export fn eq(a: bool, b: bool) -> bool binds eqbool;
export fn neq(a: bool, b: bool) -> bool binds neqbool;
export fn if{T}(c: bool, t: () -> T, f: () -> T) -> T binds ifbool;
export fn if{T}(c: bool, t: () -> T) -> Maybe{T} = if(c, fn = Maybe{T}(t()), fn = Maybe{T}());

/// Array related bindings
export fn get{T}(a: T[], i: i64) -> Maybe{T} binds getarray;
export fn len{T}(a: T[]) -> i64 binds lenarray;
export fn push{T}(a: Array{T}, v: T) -> () binds pusharray;
export fn pop{T}(a: T[]) -> Maybe{T} binds poparray;
export fn map{T, U}(a: Array{T}, m: T -> U) -> Array{U} binds map_onearg;
export fn map{T, U}(a: Array{T}, m: (T, i64) -> U) -> Array{U} binds map_twoarg;
export fn parmap{T, U}(a: Array{T}, m: T -> U) -> Array{U} binds parmap_onearg;
export fn filter{T}(a: Array{T}, f: T -> bool) -> Array{T} binds filter_onearg;
export fn filter{T}(a: Array{T}, f: (T, i64) -> bool) -> Array{T} binds filter_twoarg;
export fn reduce{T}(a: Array{T}, f: (T, T) -> T) -> Maybe{T} binds reduce_sametype;
export fn reduce{T}(a: Array{T}, f: (T, T, i64) -> T) -> Maybe{T} binds reduce_sametype_idx;
export fn reduce{T, U}(a: Array{T}, i: U, f: (U, T) -> U) -> U binds reduce_difftype;
export fn reduce{T, U}(a: Array{T}, i: U, f: (U, T, i64) -> U) -> U binds reduce_difftype_idx;
export fn concat{T}(a: Array{T}, b: Array{T}) -> Array{T} binds concat;
export fn filled{T}(v: T, l: i64) -> Array{T} binds filled;
export fn has{T}(a: Array{T}, v: T) -> bool binds hasarray;
export fn has{T}(a: Array{T}, f: (T) -> bool) -> bool binds hasfnarray;
export fn find{T}(a: Array{T}, f: (T) -> bool) -> Maybe{T} binds findarray;
// TODO: The `if` syntactic sugar will make these `if` calls much nicer (though so would return
// type inference, to be honest)
export fn index{T}(a: Array{T}, v: T) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    fn () -> Maybe{i64} = out,
    fn () -> Maybe{i64} = if(
      val.eq(v),
      fn () -> Maybe{i64} = Maybe(idx),
      fn () -> Maybe{i64} = out
    )
  )
);
export fn index{T}(a: Array{T}, f: (T) -> bool) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    fn () -> Maybe{i64} = out,
    fn () -> Maybe{i64} = if(
      f(val),
      fn () -> i64 = idx)));
export fn index{T}(a: Array{T}, f: (T, i64) -> bool) -> Maybe{i64} = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) -> Maybe{i64} = if(
    out.exists,
    fn () -> Maybe{i64} = out,
    fn () -> Maybe{i64} = if(
      f(val, idx),
      fn () -> i64 = idx)));
export fn every{T}(a: Array{T}, f: (T) -> bool) -> bool binds everyarray;
export fn some{T}(a: Array{T}, f: (T) -> bool) -> bool binds somearray;
export fn repeat{T}(a: Array{T}, c: i64) -> Array{T} binds repeatarray;
export fn store{T}(a: Array{T}, i: i64, v: T) -> Fallible{void} binds storearray;
export fn delete{T}(a: Array{T}, i: i64) -> Fallible{T} binds deletearray;

/// Buffer related bindings
export fn get{T, S}(b: T[S], i: i64) -> Maybe{T} binds getbuffer;
export fn len{T, S}(T[S]) -> i64 = {S}();
export fn map{T, S, U}(a: Buffer{T, S}, m: T -> U) -> Buffer{U, S} binds mapbuffer_onearg;
export fn map{T, S, U}(a: Buffer{T, S}, m: (T, i64) -> U) -> Buffer{U, S} binds mapbuffer_twoarg;
export fn reduce{T, S}(a: Buffer{T, S}, f: (T, T) -> T) -> Maybe{T} binds reducebuffer_sametype;
export fn reduce{T, S, U}(a: Buffer{T, S}, i: U, f: (U, T) -> U) -> U binds reducebuffer_difftype;
export fn has{T, S}(a: Buffer{T, S}, v: T) -> bool binds hasbuffer;
export fn has{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> bool binds hasfnbuffer;
export fn find{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> Maybe{T} binds findbuffer;
export fn every{T, S}(a: Buffer{T, S}, f: (T) -> bool) -> bool binds everybuffer;
fn concatInner{T, S, N}(o: Buffer{T, S + N}, a: Buffer{T, S}, b: Buffer{T, N}) -> void binds concatbuffer;
export fn concat{T, S, N}(a: Buffer{T, S}, b: Buffer{T, N}) -> Buffer{T, S + N} {
  // I can't bind directly into Rust because Rust can't add const integer type parameters together.
  // It's *theoretically* possible to generate a new Rust function in each case with the required
  // sizes, but it will be really difficult, so I'm implementing this for now with the intent to
  // eventually replace it.
  let o = {T[S + N]}(a[0].getOrExit);
  concatInner(o, a, b);
  return o;
}
// TODO: Be able to resolve explicit integer constant values as the integer type so it can be
// grabbed by the type inference system. For now, repeat for buffers outputs an array, instead.
export fn repeat{T, S}(b: Buffer{T, S}, c: i64) -> Array{T} binds repeatbuffertoarray;
export fn store{T, S}(b: Buffer{T, S}, i: i64, v: T) -> Fallible{T} binds storebuffer;

/// Dictionary-related bindings
export fn Dict{K, V}() -> Dict{K, V} binds newdict;
export fn Dict{K, V}(k: K, v: V) -> Dict{K, V} {
  let out = Dict{K, V}();
  out.store(k, v);
  return out;
}
export fn Dict{K, V}(a: Array{(K, V)}) -> Dict{K, V} = a.reduce(Dict{K, V}(), fn (d: Dict{K, V}, v: (K, V)) -> Dict{K, V} {
  d.store(v.0, v.1);
  return d;
});
export fn store{K, V}(d: Dict{K, V}, k: K, v: V) -> void binds storedict;
export fn get{K, V}(d: Dict{K, V}, k: K) -> Maybe{V} binds getdict;
export fn has{K, V}(d: Dict{K, V}, k: K) -> bool binds hasdict;
export fn len{K, V}(d: Dict{K, V}) -> i64 binds lendict;
export fn keys{K, V}(d: Dict{K, V}) -> Array{K} binds keysdict;
export fn vals{K, V}(d: Dict{K, V}) -> Array{V} binds valsdict;
export fn Array{K, V}(d: Dict{K, V}) -> Array{(K, V)} binds arraydict;
export fn concat{K, V}(a: Dict{K, V}, b: Dict{K, V}) -> Dict{K, V} binds concatdict;

/// Set-related bindings
export fn Set{V}() -> Set{V} binds newset;
export fn Set{V}(a: Array{V}) -> Set{V} = a.reduce(Set{V}(), fn (s: Set{V}, v: V) -> Set{V} {
  s.store(v);
  return s;
});
export fn Set{V}(v: V) -> Set{V} {
  let out = Set{V}();
  out.store(v);
  return out;
}
export fn store{V}(s: Set{V}, v: V) -> void binds storeset;
export fn has{V}(s: Set{V}, v: V) -> bool binds hasset;
export fn len{V}(s: Set{V}) -> i64 binds lenset;
export fn Array{V}(s: Set{V}) -> Array{V} binds arrayset;
export fn union{V}(a: Set{V}, b: Set{V}) -> Set{V} binds unionset;
export fn or{V}(a: Set{V}, b: Set{V}) -> Set{V} = union(a, b);
export fn intersect{V}(a: Set{V}, b: Set{V}) -> Set{V} binds intersectset;
export fn and{V}(a: Set{V}, b: Set{V}) -> Set{V} = intersect(a, b);
export fn difference{V}(a: Set{V}, b: Set{V}) -> Set{V} binds differenceset;
export fn div{V}(a: Set{V}, b: Set{V}) -> Set{V} = difference(a, b);
export fn symmetricDifference{V}(a: Set{V}, b: Set{V}) -> Set{V} binds symmetric_differenceset;
export fn xor{V}(a: Set{V}, b: Set{V}) -> Set{V} = symmetricDifference(a, b);
export fn product{V}(a: Set{V}, b: Set{V}) -> Set{(V, V)} binds productset;
export fn mul{V}(a: Set{V}, b: Set{V}) -> Set{(V, V)} = product(a, b);

/// Tree implementation

// The Tree type houses all of the values attached to a tree in an array and two secondary arrays to
// hold the metadata on which value is the parent and which are children, if any. The parent value
// `void` if it has no parent and a positive integer otherwise.
export type Tree{T} =
  vals: Array{T},
  parents: Array{Maybe{i64}},
  children: Array{Array{i64}};

// The Node type simply holds the index to look into the tree for a particular value-parent-children
// triplet, where that index is reffered to as a node ID. This allows node-based code to be written
// while not actually having a recursive data structure that a traditional Node type would defined.
export type Node{T} =
  id: i64,
  tree: Tree{T};

export fn Tree{T}(rootVal: T) -> Tree{T} = Tree{T}(
  Array{T}(rootVal),
  Array{Maybe{i64}}(Maybe{i64}()),
  Array{Array{i64}}(Array{i64}()));
export fn Tree{T}(n: Node{T}) -> Tree{T} = n.tree;

// TODO: This is a more correct solution, but any Tree constructed by us will always have the root
// node be the first element of the array, so we're just doing that so we don't have a `Maybe` here
/*export fn rootNode{T}(t: Tree{T}) -> Maybe{Node{T}} {
  let rootIdx = t.parents.index(Maybe{i64}());
  return if(
    rootIdx.exists,
    fn () -> Node{T} = Node{T}(rootIdx.getOrExit, t)
  );
}*/
export fn rootNode{T}(t: Tree{T}) -> Node{T} = Node{T}(0, t);

export fn len{T}(t: Tree{T}) -> i64 = t.vals.len;

export fn Node{T}(t: Tree{T}, i: i64) -> Maybe{Node{T}} = if(
  t.len.gt(i),
  fn () -> Node{T} = Node{T}(i, t));

export fn parent{T}(n: Node{T}) -> Maybe{Node{T}} {
  let parentId = n.tree.parents[n.id];
  return if(parentId.exists,
    fn () -> Maybe{Node{T}} = if(parentId.getOrExit.exists,
      fn () -> Node{T} = Node{T}(parentId.getOrExit.getOrExit, n.tree)),
    fn () -> Maybe{Node{T}} = Maybe{Node{T}}());
}

export fn children{T}(n: Node{T}) -> Array{Node{T}} = if(
  n.tree.len.gt(n.id),
  fn () -> Array{Node{T}} {
    let childIds = n.tree.children[n.id].getOr(Array{i64}());
    return childIds
      .filter(fn (id: i64) -> bool = n.tree.parents[id].getOr(-1).eq(n.id))
      .map(fn (id: i64) -> Node{T} = Node{T}(id, n.tree));
  },
  fn () -> Array{Node{T}} = Array{Node{T}}());

export fn children{T}(t: Tree{T}) -> Array{Node{T}} = t.rootNode.children;

export fn addChild{T}(n: Node{T}, val: T) -> Node{T} {
  let idx = n.tree.len;
  let parentIdx = n.id;
  n.tree.vals.push(val);
  n.tree.parents.push(Maybe{i64}(parentIdx));
  n.tree.children.push(Array{i64}());
  return Node{T}(idx, n.tree);
}
export fn addChild{T}(t: Tree{T}, val: T) -> Node{T} = t.rootNode.addChild(val);

// TODO: Implement `addChild` when the child is itself a `Node{T}` or a `Tree{T}`

// TODO: Implement `prune` to pull a node out of the tree and re-attach its children to its own
// parent.

// TODO: Implement `subtree` to create a new tree consisting of the specified node as its root and
// only its own children as the children of the tree.

export fn getOr{T}(n: Node{T}, default: T) -> T = n.tree.vals[n.id].getOr(default);

export fn Array{T}(t: Tree{T}) -> Array{Node{T}} = t.vals.map(
  fn (_: T, i: i64) -> Node{T} = Node{T}(t, i).getOrExit);

export fn map{T, U}(t: Tree{T}, mapper: (Node{T}) -> Node{U}) -> Tree{U} = Tree{U}(
  t.Array.map(mapper),
  t.parents.clone(),
  t.children.clone());
export fn map{T, U}(t: Tree{T}, mapper: (Node{T}, i64) -> Node{U}) -> Tree{U} = Tree{U}(
  t.Array.map(mapper),
  t.parents,
  t.children);

export fn every{T}(t: Tree{T}, f: (Node{T}) -> bool) -> bool = t.Array.every(f);

export fn some{T}(t: Tree{T}, f: (Node{T}) -> bool) -> bool = t.Array.some(f);

export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}) -> Node{T}) -> Node{T} = t.Array.reduce(f);
export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}, i64) -> Node{T}) -> Node{T} = t.Array.reduce(f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}) -> U) -> U = t.Array.reduce(i, f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}, i64) -> U) -> U = t.Array.reduce(i, f);

export fn find{T}(t: Tree{T}, f: (T) -> bool) -> Maybe{Node{T}} = t.Array.find(f);

/// Process exit-related bindings
export fn ExitCode(e: u8) -> ExitCode binds to_exit_code;
export fn ExitCode(e: u16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: u64) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i8) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i16) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i32) -> ExitCode = ExitCode(e.u8);
export fn ExitCode(e: i64) -> ExitCode = ExitCode(e.u8);
export fn getOrExit{T}(a: Fallible{T}) -> T binds get_or_exit;
export fn getOrExit{T}(a: T?) -> T binds get_or_maybe_exit;

/// Thread-related bindings
export fn wait(t: i64) binds wait;

/// Time-related bindings
export fn now() -> Instant binds now;
export fn elapsed(i: Instant) -> Duration binds elapsed;

/// Uuid-related bindings
export fn uuid() -> uuid binds uuid::Uuid::new_v4;
export fn string(uuid) -> string binds uuidstring;

/// GPU-related bindings

// The base bindings to create buffers of memory on the GPU, construct a plan for a compute shader,
// execute it, and read the buffer back to the CPU
export type BufferUsages = Binds{"wgpu::BufferUsages"};
export type GBuffer = Binds{"GBuffer"};
export type GPGPU = Binds{"GPGPU"};
export fn mapReadBuffer() -> BufferUsages binds map_read_buffer_type;
export fn storageBuffer() -> BufferUsages binds storage_buffer_type;
export fn GBuffer(usage: BufferUsages, vals: Array{i32}) -> GBuffer binds create_buffer_init;
export fn GBuffer(usage: BufferUsages, size: i64) -> GBuffer binds create_empty_buffer;
export fn GBuffer(vals: Array{i32}) -> GBuffer = GBuffer(storageBuffer(), vals);
export fn GBuffer{T}(vals: Array{T}) -> GBuffer = GBuffer(storageBuffer(), vals.map(fn (v: T) -> i32 = v.i32));
export fn GBuffer(size: i64) -> GBuffer = GBuffer(storageBuffer(), size);
export fn len(gb: GBuffer) -> i64 binds bufferlen;
export fn id(b: GBuffer) -> string binds buffer_id;
export fn GPGPU(source: string, buffers: Array{Array{GBuffer}}, maxGlobalId: i64[3]) -> GPGPU binds GPGPU_new;
export fn GPGPU(source: string, buffer: GBuffer) -> GPGPU binds GPGPU_new_easy;
export fn run(gg: GPGPU) binds gpu_run;
export fn read{T}(b: GBuffer) -> Array{T} binds read_buffer;

// The WgpuType provides a mechanism to build up the logic for a compute shader with normal-looking
// Alan code, not requiring to think in two different languages at the same time. All of the GPU
// types hereafter are derivative of this type
export type WgpuType{N} =
  typeName: N,
  varName: string, // Key to the next field
  statements: Dict{string, string},
  buffers: Set{GBuffer};

// Scalar types and constructors
export type gu32 = WgpuType{"u32"};
export type gi32 = WgpuType{"i32"};
export type gf32 = WgpuType{"f32"};
export type gbool = WgpuType{"bool"};

// TODO: Better constraining on the input types allowed. It will still fail to compile, but the
// error message isn't great at the moment.
export fn build{N}(ret: N) -> GPGPU {
  // TODO: Don't assume all of the buffers involved here are storage buffers
  // Also TODO: Support other buffer types than i32
  let bufferArray = Array{GBuffer}().concat(ret.buffers.Array); // TODO: Shouldn't need this concat
  // let bufferArray = ret.buffers.Array;
  let wgslHeader = bufferArray.map(fn (gb: GBuffer, i: i64) -> string {
    return "@group(0)\n@binding("
      .concat(i.string)
      .concat(")\nvar<storage, read_write> ")
      .concat(gb.id)
      .concat(": array<i32>;\n");
  }).join("\n");
  let wgslFunctionHeader = "@compute\n@workgroup_size(1)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n";
  let wgslFunctionBody = ret.statements.Array.map(fn (kv: (string, string)) -> string {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () -> string = "", fn () -> string {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let wgsl = wgslHeader.concat(wgslFunctionHeader).concat(wgslFunctionBody).concat("}");
  let maxGlobalIdArray = ret
    .statements['@builtin(global_invocation_id) id: vec3u']
    .getOr('0,0,0')
    .split(',')
    .map(fn (s: string) -> i64 = s.i64.getOr(0));
  let maxGlobalId = {i64[3]}(
    maxGlobalIdArray[0].getOr(0),
    maxGlobalIdArray[1].getOr(0),
    maxGlobalIdArray[2].getOr(0)
  );
  let buffers = Array{Array{GBuffer}}();
  buffers.push(bufferArray);
  return GPGPU(wgsl, buffers, maxGlobalId);
}

export fn gu32(u: u32) -> gu32 = gu32(u.string, Dict{string, string}(), Set{GBuffer}());
export fn gu32(gi: gi32) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32(gf: gf32) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32(gb: gbool) -> gu32 {
  let varName = "u32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = u32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gu32(varName, statements, buffers);
}
export fn gu32{T}(u: T) -> gu32 = gu32(u.u32);

export fn gi32(i: i32) -> gi32 = gi32(i.string, Dict{string, string}(), Set{GBuffer}());
export fn gi32(gu: gu32) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32(gf: gf32) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32(gb: gbool) -> gi32 {
  let varName = "i32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = i32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gi32(varName, statements, buffers);
}
export fn gi32{T}(i: T) -> gi32 = gi32(i.i32);

export fn gf32(f: f32) -> gf32 = gf32(f.string, Dict{string, string}(), Set{GBuffer}());
export fn gf32(gu: gu32) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32(gi: gi32) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32(gb: gbool) -> gf32 {
  let varName = "f32_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = f32(").concat(gb.varName).concat(")");
  let statements = gb.statements.clone().concat(Dict(varName, statement));
  let buffers = gb.buffers.clone();
  return gf32(varName, statements, buffers);
}
export fn gf32{T}(f: T) -> gf32 = gf32(f.f32);

export fn gbool(b: bool) -> gbool = gbool(b.string, Dict{string, string}(), Set{GBuffer}());
export fn gbool(gu: gu32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gu.varName).concat(")");
  let statements = gu.statements.clone().concat(Dict(varName, statement));
  let buffers = gu.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool(gi: gi32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gi.varName).concat(")");
  let statements = gi.statements.clone().concat(Dict(varName, statement));
  let buffers = gi.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool(gf: gf32) -> gbool {
  let varName = "bool_".concat(uuid().string.replace('-', '_'));
  let statement = "var ".concat(varName).concat(" = bool(").concat(gf.varName).concat(")");
  let statements = gf.statements.clone().concat(Dict(varName, statement));
  let buffers = gf.buffers.clone();
  return gbool(varName, statements, buffers);
}
export fn gbool{T}(b: T) -> gbool = gbool(b.bool);

// Vector types and constructors
export type gvec2u = WgpuType{"vec2u"};
export type gvec2i = WgpuType{"vec2i"};
export type gvec2f = WgpuType{"vec2f"};
export type gvec2b = WgpuType{"vec2<bool>"};
export type gvec3u = WgpuType{"vec3u"};
export type gvec3i = WgpuType{"vec3i"};
export type gvec3f = WgpuType{"vec3f"};
export type gvec3b = WgpuType{"vec3<bool>"};
export type gvec4u = WgpuType{"vec4u"};
export type gvec4i = WgpuType{"vec4i"};
export type gvec4f = WgpuType{"vec4f"};
export type gvec4b = WgpuType{"vec4<bool>"};

export fn gvec2u() -> gvec2u = gvec2u("vec2u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2u(a: gu32, b: gu32) -> gvec2u {
  let statement = "vec2u(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2u(statement, statements, buffers);
}
export fn gvec2u{T}(a: T, b: T) -> gvec2u = gvec2u(a.gu32, b.gu32);

export fn gvec2i() -> gvec2i = gvec2i("vec2i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2i(a: gi32, b: gi32) -> gvec2i {
  let statement = "vec2i(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2i(statement, statements, buffers);
}
export fn gvec2i{T}(a: T, b: T) -> gvec2i = gvec2i(a.gi32, b.gi32);

export fn gvec2f() -> gvec2f = gvec2f("vec2f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2f(a: gf32, b: gf32) -> gvec2f {
  let statement = "vec2f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2f(statement, statements, buffers);
}
export fn gvec2f{T}(a: T, b: T) -> gvec2f = gvec2f(a.gf32, b.gf32);

export fn gvec2b() -> gvec2b = gvec2b("vec2<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec2b(a: gbool, b: gbool) -> gvec2b {
  let statement = "vec2<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gvec2b(statement, statements, buffers);
}
export fn gvec2b{T}(a: T, b: T) -> gvec2b = gvec2b(a.gbool, b.gbool);

export fn gvec3u() -> gvec3u = gvec3u("vec3u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3u(a: gu32, b: gu32, c: gu32) -> gvec3u {
  let statement = "vec3u(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3u(statement, statements, buffers);
}
export fn gvec3u{T}(a: T, b: T, c: T) -> gvec3u = gvec3u(a.gu32, b.gu32, c.gu32);

export fn gvec3i() -> gvec3i = gvec3i("vec3i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3i(a: gi32, b: gi32, c: gi32) -> gvec3i {
  let statement = "vec3i(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3i(statement, statements, buffers);
}
export fn gvec3i{T}(a: T, b: T, c: T) -> gvec3i = gvec3i(a.gi32, b.gi32, c.gi32);

export fn gvec3f() -> gvec3f = gvec3f("vec3f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3f(a: gf32, b: gf32, c: gf32) -> gvec3f {
  let statement = "vec3f(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3f(statement, statements, buffers);
}
export fn gvec3f{T}(a: T, b: T, c: T) -> gvec3f = gvec3f(a.gf32, b.gf32, c.gf32);

export fn gvec3b() -> gvec3b = gvec3b("vec3<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec3b(a: gbool, b: gbool, c: gbool) -> gvec3b {
  let statement = "vec3<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gvec3b(statement, statements, buffers);
}
export fn gvec3b{T}(a: T, b: T, c: T) -> gvec3b = gvec3b(a.gbool, b.gbool, c.gbool);

export fn gvec4u() -> gvec4u = gvec4u("vec4u()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4u(a: gu32, b: gu32, c: gu32, d: gu32) -> gvec4u {
  let statement = "vec4u(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4u(statement, statements, buffers);
}
export fn gvec4u{T}(a: T, b: T, c: T, d: T) -> gvec4u = gvec4u(a.gu32, b.gu32, c.gu32, d.gu32);

export fn gvec4i() -> gvec4i = gvec4i("vec4i()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4i(a: gi32, b: gi32, c: gi32, d: gi32) -> gvec4i {
  let statement = "vec4i(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4i(statement, statements, buffers);
}
export fn gvec4i{T}(a: T, b: T, c: T, d: T) -> gvec4i = gvec4i(a.gi32, b.gi32, c.gi32, d.gi32);

export fn gvec4f() -> gvec4f = gvec4f("vec4f()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4f(a: gf32, b: gf32, c: gf32, d: gf32) -> gvec4f {
  let statement = "vec4f(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4f(statement, statements, buffers);
}
export fn gvec4f{T}(a: T, b: T, c: T, d: T) -> gvec4f = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);

export fn gvec4b() -> gvec4b = gvec4b("vec4<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn gvec4b(a: gbool, b: gbool, c: gbool, d: gbool) -> gvec4b {
  let statement = "vec4<bool>(".concat(a.varName).concat(", ").concat(b.varName).concat(", ").concat(c.varName).concat(", ").concat(d.varName).concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gvec4b(statement, statements, buffers);
}
export fn gvec4b{T}(a: T, b: T, c: T, d: T) -> gvec4b = gvec4b(a.gbool, b.gbool, c.gbool, d.gbool);

// The global_invocation_id; the entry value to a compute shader, and it's constructor, a
// specialized version of gvec3u that initializes a bit differently.
export fn gFor(x: u32, y: u32, z: u32) -> gvec3u {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',').concat(z.string));
  return gvec3u('id', statements, Set{GBuffer}());
}
export fn gFor{T}(x: T, y: T, z: T) -> gvec3u = gFor(x.u32, y.u32, z.u32);
export fn gFor{T}(x: T, y: T) -> gvec3u = gFor(x.u32, y.u32, 1.u32);
export fn gFor{T}(x: T) -> gu32 = gFor(x.u32, 1.u32, 1.u32).x;

// Matrix types
export type gmat2x2f = WgpuType{"mat2x2f"};
export type gmat2x3f = WgpuType{"mat2x3f"};
export type gmat2x4f = WgpuType{"mat2x4f"};
export type gmat3x2f = WgpuType{"mat3x2f"};
export type gmat3x3f = WgpuType{"mat3x3f"};
export type gmat3x4f = WgpuType{"mat3x4f"};
export type gmat4x2f = WgpuType{"mat4x2f"};
export type gmat4x3f = WgpuType{"mat4x3f"};
export type gmat4x4f = WgpuType{"mat4x4f"};

export fn gmat2x2f() -> gmat2x2f = gmat2x2f("mat2x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x2f(a: gvec2f, b: gvec2f) -> gmat2x2f {
  let statement = "mat2x2f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(statement, statements, buffers);
}
export fn gmat2x2f(a: gf32, b: gf32, c: gf32, d: gf32) -> gmat2x2f {
  let statement = "mat2x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat2x2f(statement, statements, buffers);
}

export fn gmat2x3f() -> gmat2x3f = gmat2x3f("mat2x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x3f(a: gvec3f, b: gvec3f) -> gmat2x3f {
  let statement = "mat2x3f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(statement, statements, buffers);
}
export fn gmat2x3f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) -> gmat2x3f {
  let statement = "mat2x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat2x3f(statement, statements, buffers);
}

export fn gmat2x4f() -> gmat2x4f = gmat2x4f("mat2x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat2x4f(a: gvec4f, b: gvec4f) -> gmat2x4f {
  let statement = "mat2x4f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(statement, statements, buffers);
}
export fn gmat2x4f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32) -> gmat2x4f {
  let statement = "mat2x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat2x4f(statement, statements, buffers);
}

export fn gmat3x2f() -> gmat3x2f = gmat3x2f("mat3x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x2f(a: gvec2f, b: gvec2f, c: gvec2f) -> gmat3x2f {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x2f(statement, statements, buffers);
}
export fn gmat3x2f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) -> gmat3x2f {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat3x2f(statement, statements, buffers);
}

export fn gmat3x3f() -> gmat3x3f = gmat3x3f("mat3x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x3f(a: gvec3f, b: gvec3f, c: gvec3f) -> gmat3x3f {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x3f(statement, statements, buffers);
}
export fn gmat3x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32
) -> gmat3x3f {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers);
  return gmat3x3f(statement, statements, buffers);
}

export fn gmat3x4f() -> gmat3x4f = gmat3x4f("mat3x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat3x4f(a: gvec4f, b: gvec4f, c: gvec4f) -> gmat3x4f {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x4f(statement, statements, buffers);
}
export fn gmat3x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) -> gmat3x4f {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat3x4f(statement, statements, buffers);
}

export fn gmat4x2f() -> gmat4x2f = gmat4x2f("mat4x2f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x2f(a: gvec2f, b: gvec2f, c: gvec2f, d: gvec2f) -> gmat4x2f {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x2f(statement, statements, buffers);
}
export fn gmat4x2f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32
) -> gmat4x2f {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat4x2f(statement, statements, buffers);
}

export fn gmat4x3f() -> gmat4x3f = gmat4x3f("mat4x3f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x3f(a: gvec3f, b: gvec3f, c: gvec3f, d: gvec3f) -> gmat4x3f {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x3f(statement, statements, buffers);
}
export fn gmat4x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) -> gmat4x3f {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat4x3f(statement, statements, buffers);
}

export fn gmat4x4f() -> gmat4x4f = gmat4x4f("mat4x4f()", Dict{string, string}(), Set{GBuffer}());
export fn gmat4x4f(a: gvec4f, b: gvec4f, c: gvec4f, d: gvec4f) -> gmat4x4f {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x4f(statement, statements, buffers);
}
export fn gmat4x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32,
  m: gf32,
  n: gf32,
  o: gf32,
  p: gf32
) -> gmat4x4f {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(", ")
    .concat(m.varName)
    .concat(", ")
    .concat(n.varName)
    .concat(", ")
    .concat(o.varName)
    .concat(", ")
    .concat(p.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements)
    .concat(m.statements)
    .concat(n.statements)
    .concat(o.statements)
    .concat(p.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers)
    .union(m.buffers)
    .union(n.buffers)
    .union(o.buffers)
    .union(p.buffers);
  return gmat4x4f(statement, statements, buffers);
}

// TODO: Fixed-length buffers within wgsl

// TODO: How to handle structs?

// GPU Type accessors

export fn x(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2u) -> gu32 = v.x;
export fn j(v: gvec2u) -> gu32 = v.y;
export fn r(v: gvec2u) -> gu32 = v.x;
export fn g(v: gvec2u) -> gu32 = v.y;

fn gvec22u(v: gvec2u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2u) -> gvec2u = gvec22u(v, '.xy');
export fn yx(v: gvec2u) -> gvec2u = gvec22u(v, '.yx');
export fn ij(v: gvec2u) -> gvec2u = v.xy;
export fn ji(v: gvec2u) -> gvec2u = v.yx;
export fn rg(v: gvec2u) -> gvec2u = v.xy;
export fn gr(v: gvec2u) -> gvec2u = v.yx;

export fn x(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2i) -> gi32 = v.x;
export fn j(v: gvec2i) -> gi32 = v.y;
export fn r(v: gvec2i) -> gi32 = v.x;
export fn g(v: gvec2i) -> gi32 = v.y;

fn gvec22i(v: gvec2i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2i) -> gvec2i = gvec22i(v, '.xy');
export fn yx(v: gvec2i) -> gvec2i = gvec22i(v, '.yx');
export fn ij(v: gvec2i) -> gvec2i = v.xy;
export fn ji(v: gvec2i) -> gvec2i = v.yx;
export fn rg(v: gvec2i) -> gvec2i = v.xy;
export fn gr(v: gvec2i) -> gvec2i = v.yx;

export fn x(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec2f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec2f) -> gf32 = v.x;
export fn j(v: gvec2f) -> gf32 = v.y;
export fn r(v: gvec2f) -> gf32 = v.x;
export fn g(v: gvec2f) -> gf32 = v.y;

fn gvec22f(v: gvec2f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2f) -> gvec2f = gvec22f(v, '.xy');
export fn yx(v: gvec2f) -> gvec2f = gvec22f(v, '.yx');
export fn ij(v: gvec2f) -> gvec2f = v.xy;
export fn ji(v: gvec2f) -> gvec2f = v.yx;
export fn rg(v: gvec2f) -> gvec2f = v.xy;
export fn gr(v: gvec2f) -> gvec2f = v.yx;

export fn x(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec2b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec2b) -> gbool = v.x;
export fn j(v: gvec2b) -> gbool = v.y;
export fn r(v: gvec2b) -> gbool = v.x;
export fn g(v: gvec2b) -> gbool = v.y;

fn gvec22b(v: gvec2b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec2b) -> gvec2b = gvec22b(v, '.xy');
export fn yx(v: gvec2b) -> gvec2b = gvec22b(v, '.yx');
export fn ij(v: gvec2b) -> gvec2b = v.xy;
export fn ji(v: gvec2b) -> gvec2b = v.yx;
export fn rg(v: gvec2b) -> gvec2b = v.xy;
export fn gr(v: gvec2b) -> gvec2b = v.yx;

export fn x(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3u) -> gu32 = v.x;
export fn j(v: gvec3u) -> gu32 = v.y;
export fn k(v: gvec3u) -> gu32 = v.z;
export fn r(v: gvec3u) -> gu32 = v.x;
export fn g(v: gvec3u) -> gu32 = v.y;
export fn b(v: gvec3u) -> gu32 = v.z;

fn gvec32u(v: gvec3u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3u) -> gvec2u = gvec32u(v, '.xy');
export fn yx(v: gvec3u) -> gvec2u = gvec32u(v, '.yx');
export fn xz(v: gvec3u) -> gvec2u = gvec32u(v, '.xz');
export fn zx(v: gvec3u) -> gvec2u = gvec32u(v, '.zx');
export fn yz(v: gvec3u) -> gvec2u = gvec32u(v, '.yz');
export fn zy(v: gvec3u) -> gvec2u = gvec32u(v, '.zy');
export fn ij(v: gvec3u) -> gvec2u = v.xy;
export fn ji(v: gvec3u) -> gvec2u = v.yx;
export fn ik(v: gvec3u) -> gvec2u = v.xz;
export fn ki(v: gvec3u) -> gvec2u = v.zx;
export fn jk(v: gvec3u) -> gvec2u = v.yz;
export fn kj(v: gvec3u) -> gvec2u = v.zy;
export fn rg(v: gvec3u) -> gvec2u = v.xy;
export fn gr(v: gvec3u) -> gvec2u = v.yx;
export fn rb(v: gvec3u) -> gvec2u = v.xz;
export fn br(v: gvec3u) -> gvec2u = v.zx;
export fn gb(v: gvec3u) -> gvec2u = v.yz;
export fn bg(v: gvec3u) -> gvec2u = v.zy;

fn gvec33u(v: gvec3u, a: string) -> gvec3u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3u) -> gvec3u = gvec33u(v, '.xyz');
export fn xzy(v: gvec3u) -> gvec3u = gvec33u(v, '.xzy');
export fn yxz(v: gvec3u) -> gvec3u = gvec33u(v, '.yxz');
export fn yzx(v: gvec3u) -> gvec3u = gvec33u(v, '.yzx');
export fn zxy(v: gvec3u) -> gvec3u = gvec33u(v, '.zxy');
export fn zyx(v: gvec3u) -> gvec3u = gvec33u(v, '.zyx');
export fn ijk(v: gvec3u) -> gvec3u = v.xyz;
export fn ikj(v: gvec3u) -> gvec3u = v.xzy;
export fn jik(v: gvec3u) -> gvec3u = v.yxz;
export fn jki(v: gvec3u) -> gvec3u = v.yzx;
export fn kij(v: gvec3u) -> gvec3u = v.zxy;
export fn kji(v: gvec3u) -> gvec3u = v.zyx;
export fn rgb(v: gvec3u) -> gvec3u = v.xyz;
export fn rbg(v: gvec3u) -> gvec3u = v.xzy;
export fn grb(v: gvec3u) -> gvec3u = v.yxz;
export fn gbr(v: gvec3u) -> gvec3u = v.yzx;
export fn brg(v: gvec3u) -> gvec3u = v.zxy;
export fn bgr(v: gvec3u) -> gvec3u = v.zyx;

export fn x(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3i) -> gi32 = v.x;
export fn j(v: gvec3i) -> gi32 = v.y;
export fn k(v: gvec3i) -> gi32 = v.z;
export fn r(v: gvec3i) -> gi32 = v.x;
export fn g(v: gvec3i) -> gi32 = v.y;
export fn b(v: gvec3i) -> gi32 = v.z;

fn gvec32i(v: gvec3i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3i) -> gvec2i = gvec32i(v, '.xy');
export fn yx(v: gvec3i) -> gvec2i = gvec32i(v, '.yx');
export fn xz(v: gvec3i) -> gvec2i = gvec32i(v, '.xz');
export fn zx(v: gvec3i) -> gvec2i = gvec32i(v, '.zx');
export fn yz(v: gvec3i) -> gvec2i = gvec32i(v, '.yz');
export fn zy(v: gvec3i) -> gvec2i = gvec32i(v, '.zy');
export fn ij(v: gvec3i) -> gvec2i = v.xy;
export fn ji(v: gvec3i) -> gvec2i = v.yx;
export fn ik(v: gvec3i) -> gvec2i = v.xz;
export fn ki(v: gvec3i) -> gvec2i = v.zx;
export fn jk(v: gvec3i) -> gvec2i = v.yz;
export fn kj(v: gvec3i) -> gvec2i = v.zy;
export fn rg(v: gvec3i) -> gvec2i = v.xy;
export fn gr(v: gvec3i) -> gvec2i = v.yx;
export fn rb(v: gvec3i) -> gvec2i = v.xz;
export fn br(v: gvec3i) -> gvec2i = v.zx;
export fn gb(v: gvec3i) -> gvec2i = v.yz;
export fn bg(v: gvec3i) -> gvec2i = v.zy;

fn gvec33i(v: gvec3i, a: string) -> gvec3i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3i) -> gvec3i = gvec33i(v, '.xyz');
export fn xzy(v: gvec3i) -> gvec3i = gvec33i(v, '.xzy');
export fn yxz(v: gvec3i) -> gvec3i = gvec33i(v, '.yxz');
export fn yzx(v: gvec3i) -> gvec3i = gvec33i(v, '.yzx');
export fn zxy(v: gvec3i) -> gvec3i = gvec33i(v, '.zxy');
export fn zyx(v: gvec3i) -> gvec3i = gvec33i(v, '.zyx');
export fn ijk(v: gvec3i) -> gvec3i = v.xyz;
export fn ikj(v: gvec3i) -> gvec3i = v.xzy;
export fn jik(v: gvec3i) -> gvec3i = v.yxz;
export fn jki(v: gvec3i) -> gvec3i = v.yzx;
export fn kij(v: gvec3i) -> gvec3i = v.zxy;
export fn kji(v: gvec3i) -> gvec3i = v.zyx;
export fn rgb(v: gvec3i) -> gvec3i = v.xyz;
export fn rbg(v: gvec3i) -> gvec3i = v.xzy;
export fn grb(v: gvec3i) -> gvec3i = v.yxz;
export fn gbr(v: gvec3i) -> gvec3i = v.yzx;
export fn brg(v: gvec3i) -> gvec3i = v.zxy;
export fn bgr(v: gvec3i) -> gvec3i = v.zyx;

export fn x(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec3f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec3f) -> gf32 = v.x;
export fn j(v: gvec3f) -> gf32 = v.y;
export fn k(v: gvec3f) -> gf32 = v.z;
export fn r(v: gvec3f) -> gf32 = v.x;
export fn g(v: gvec3f) -> gf32 = v.y;
export fn b(v: gvec3f) -> gf32 = v.z;

fn gvec32f(v: gvec3f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3f) -> gvec2f = gvec32f(v, '.xy');
export fn yx(v: gvec3f) -> gvec2f = gvec32f(v, '.yx');
export fn xz(v: gvec3f) -> gvec2f = gvec32f(v, '.xz');
export fn zx(v: gvec3f) -> gvec2f = gvec32f(v, '.zx');
export fn yz(v: gvec3f) -> gvec2f = gvec32f(v, '.yz');
export fn zy(v: gvec3f) -> gvec2f = gvec32f(v, '.zy');
export fn ij(v: gvec3f) -> gvec2f = v.xy;
export fn ji(v: gvec3f) -> gvec2f = v.yx;
export fn ik(v: gvec3f) -> gvec2f = v.xz;
export fn ki(v: gvec3f) -> gvec2f = v.zx;
export fn jk(v: gvec3f) -> gvec2f = v.yz;
export fn kj(v: gvec3f) -> gvec2f = v.zy;
export fn rg(v: gvec3f) -> gvec2f = v.xy;
export fn gr(v: gvec3f) -> gvec2f = v.yx;
export fn rb(v: gvec3f) -> gvec2f = v.xz;
export fn br(v: gvec3f) -> gvec2f = v.zx;
export fn gb(v: gvec3f) -> gvec2f = v.yz;
export fn bg(v: gvec3f) -> gvec2f = v.zy;

fn gvec33f(v: gvec3f, a: string) -> gvec3f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3f) -> gvec3f = gvec33f(v, '.xyz');
export fn xzy(v: gvec3f) -> gvec3f = gvec33f(v, '.xzy');
export fn yxz(v: gvec3f) -> gvec3f = gvec33f(v, '.yxz');
export fn yzx(v: gvec3f) -> gvec3f = gvec33f(v, '.yzx');
export fn zxy(v: gvec3f) -> gvec3f = gvec33f(v, '.zxy');
export fn zyx(v: gvec3f) -> gvec3f = gvec33f(v, '.zyx');
export fn ijk(v: gvec3f) -> gvec3f = v.xyz;
export fn ikj(v: gvec3f) -> gvec3f = v.xzy;
export fn jik(v: gvec3f) -> gvec3f = v.yxz;
export fn jki(v: gvec3f) -> gvec3f = v.yzx;
export fn kij(v: gvec3f) -> gvec3f = v.zxy;
export fn kji(v: gvec3f) -> gvec3f = v.zyx;
export fn rgb(v: gvec3f) -> gvec3f = v.xyz;
export fn rbg(v: gvec3f) -> gvec3f = v.xzy;
export fn grb(v: gvec3f) -> gvec3f = v.yxz;
export fn gbr(v: gvec3f) -> gvec3f = v.yzx;
export fn brg(v: gvec3f) -> gvec3f = v.zxy;
export fn bgr(v: gvec3f) -> gvec3f = v.zyx;

export fn x(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec3b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec3b) -> gbool = v.x;
export fn j(v: gvec3b) -> gbool = v.y;
export fn k(v: gvec3b) -> gbool = v.z;
export fn r(v: gvec3b) -> gbool = v.x;
export fn g(v: gvec3b) -> gbool = v.y;
export fn b(v: gvec3b) -> gbool = v.z;

fn gvec32b(v: gvec3b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec3b) -> gvec2b = gvec32b(v, '.xy');
export fn yx(v: gvec3b) -> gvec2b = gvec32b(v, '.yx');
export fn xz(v: gvec3b) -> gvec2b = gvec32b(v, '.xz');
export fn zx(v: gvec3b) -> gvec2b = gvec32b(v, '.zx');
export fn yz(v: gvec3b) -> gvec2b = gvec32b(v, '.yz');
export fn zy(v: gvec3b) -> gvec2b = gvec32b(v, '.zy');
export fn ij(v: gvec3b) -> gvec2b = v.xy;
export fn ji(v: gvec3b) -> gvec2b = v.yx;
export fn ik(v: gvec3b) -> gvec2b = v.xz;
export fn ki(v: gvec3b) -> gvec2b = v.zx;
export fn jk(v: gvec3b) -> gvec2b = v.yz;
export fn kj(v: gvec3b) -> gvec2b = v.zy;
export fn rg(v: gvec3b) -> gvec2b = v.xy;
export fn gr(v: gvec3b) -> gvec2b = v.yx;
export fn rb(v: gvec3b) -> gvec2b = v.xz;
export fn br(v: gvec3b) -> gvec2b = v.zx;
export fn gb(v: gvec3b) -> gvec2b = v.yz;
export fn bg(v: gvec3b) -> gvec2b = v.zy;

fn gvec33b(v: gvec3b, a: string) -> gvec3b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
export fn xyz(v: gvec3b) -> gvec3b = gvec33b(v, '.xyz');
export fn xzy(v: gvec3b) -> gvec3b = gvec33b(v, '.xzy');
export fn yxz(v: gvec3b) -> gvec3b = gvec33b(v, '.yxz');
export fn yzx(v: gvec3b) -> gvec3b = gvec33b(v, '.yzx');
export fn zxy(v: gvec3b) -> gvec3b = gvec33b(v, '.zxy');
export fn zyx(v: gvec3b) -> gvec3b = gvec33b(v, '.zyx');
export fn ijk(v: gvec3b) -> gvec3b = v.xyz;
export fn ikj(v: gvec3b) -> gvec3b = v.xzy;
export fn jik(v: gvec3b) -> gvec3b = v.yxz;
export fn jki(v: gvec3b) -> gvec3b = v.yzx;
export fn kij(v: gvec3b) -> gvec3b = v.zxy;
export fn kji(v: gvec3b) -> gvec3b = v.zyx;
export fn rgb(v: gvec3b) -> gvec3b = v.xyz;
export fn rbg(v: gvec3b) -> gvec3b = v.xzy;
export fn grb(v: gvec3b) -> gvec3b = v.yxz;
export fn gbr(v: gvec3b) -> gvec3b = v.yzx;
export fn brg(v: gvec3b) -> gvec3b = v.zxy;
export fn bgr(v: gvec3b) -> gvec3b = v.zyx;

export fn x(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4u) -> gu32 {
  let varName = v.varName.concat('.w');
  return gu32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4u) -> gu32 = v.x;
export fn j(v: gvec4u) -> gu32 = v.y;
export fn k(v: gvec4u) -> gu32 = v.z;
export fn l(v: gvec4u) -> gu32 = v.w;
export fn r(v: gvec4u) -> gu32 = v.x;
export fn g(v: gvec4u) -> gu32 = v.y;
export fn b(v: gvec4u) -> gu32 = v.z;
export fn a(v: gvec4u) -> gu32 = v.w;

fn gvec42u(v: gvec4u, a: string) -> gvec2u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4u) -> gvec2u = gvec42u(v, '.xy');
export fn yx(v: gvec4u) -> gvec2u = gvec42u(v, '.yx');
export fn xz(v: gvec4u) -> gvec2u = gvec42u(v, '.xz');
export fn zx(v: gvec4u) -> gvec2u = gvec42u(v, '.zx');
export fn xw(v: gvec4u) -> gvec2u = gvec42u(v, '.xw');
export fn wx(v: gvec4u) -> gvec2u = gvec42u(v, '.wx');
export fn yz(v: gvec4u) -> gvec2u = gvec42u(v, '.yz');
export fn zy(v: gvec4u) -> gvec2u = gvec42u(v, '.zy');
export fn yw(v: gvec4u) -> gvec2u = gvec42u(v, '.yw');
export fn wy(v: gvec4u) -> gvec2u = gvec42u(v, '.wy');
export fn zw(v: gvec4u) -> gvec2u = gvec42u(v, '.zw');
export fn wz(v: gvec4u) -> gvec2u = gvec42u(v, '.wz');
export fn ij(v: gvec4u) -> gvec2u = v.xy;
export fn ji(v: gvec4u) -> gvec2u = v.yx;
export fn ik(v: gvec4u) -> gvec2u = v.xz;
export fn ki(v: gvec4u) -> gvec2u = v.zx;
export fn il(v: gvec4u) -> gvec2u = v.xw;
export fn li(v: gvec4u) -> gvec2u = v.wx;
export fn jk(v: gvec4u) -> gvec2u = v.yz;
export fn kj(v: gvec4u) -> gvec2u = v.zy;
export fn jl(v: gvec4u) -> gvec2u = v.yw;
export fn lj(v: gvec4u) -> gvec2u = v.wy;
export fn kl(v: gvec4u) -> gvec2u = v.zw;
export fn lk(v: gvec4u) -> gvec2u = v.wz;
export fn rg(v: gvec4u) -> gvec2u = v.xy;
export fn gr(v: gvec4u) -> gvec2u = v.yx;
export fn rb(v: gvec4u) -> gvec2u = v.xz;
export fn br(v: gvec4u) -> gvec2u = v.zx;
export fn ra(v: gvec4u) -> gvec2u = v.xw;
export fn ar(v: gvec4u) -> gvec2u = v.wx;
export fn gb(v: gvec4u) -> gvec2u = v.yz;
export fn bg(v: gvec4u) -> gvec2u = v.zy;
export fn ga(v: gvec4u) -> gvec2u = v.yw;
export fn ag(v: gvec4u) -> gvec2u = v.wy;
export fn ba(v: gvec4u) -> gvec2u = v.zw;
export fn ab(v: gvec4u) -> gvec2u = v.wz;

fn gvec43u(v: gvec4u, a: string) -> gvec3u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4u) -> gvec3u = gvec43u(v, '.xyz'); // 123
export fn xyw(v: gvec4u) -> gvec3u = gvec43u(v, '.xyw'); // 124
export fn xzy(v: gvec4u) -> gvec3u = gvec43u(v, '.xzy'); // 132
export fn xzw(v: gvec4u) -> gvec3u = gvec43u(v, '.xzw'); // 134
export fn xwy(v: gvec4u) -> gvec3u = gvec43u(v, '.xwy'); // 142
export fn xwz(v: gvec4u) -> gvec3u = gvec43u(v, '.xwz'); // 143
export fn yxz(v: gvec4u) -> gvec3u = gvec43u(v, '.yxz'); // 213
export fn yxw(v: gvec4u) -> gvec3u = gvec43u(v, '.yxw'); // 214
export fn yzx(v: gvec4u) -> gvec3u = gvec43u(v, '.yzx'); // 231
export fn yzw(v: gvec4u) -> gvec3u = gvec43u(v, '.yzw'); // 234
export fn ywx(v: gvec4u) -> gvec3u = gvec43u(v, '.ywx'); // 241
export fn ywz(v: gvec4u) -> gvec3u = gvec43u(v, '.ywz'); // 243
export fn zxy(v: gvec4u) -> gvec3u = gvec43u(v, '.zxy'); // 312
export fn zxw(v: gvec4u) -> gvec3u = gvec43u(v, '.zxw'); // 314
export fn zyx(v: gvec4u) -> gvec3u = gvec43u(v, '.zyx'); // 321
export fn zyw(v: gvec4u) -> gvec3u = gvec43u(v, '.zyw'); // 324
export fn zwx(v: gvec4u) -> gvec3u = gvec43u(v, '.zwx'); // 341
export fn zwy(v: gvec4u) -> gvec3u = gvec43u(v, '.zwy'); // 342
export fn wxy(v: gvec4u) -> gvec3u = gvec43u(v, '.wxy'); // 412
export fn wxz(v: gvec4u) -> gvec3u = gvec43u(v, '.wxz'); // 413
export fn wyx(v: gvec4u) -> gvec3u = gvec43u(v, '.wyx'); // 421
export fn wyz(v: gvec4u) -> gvec3u = gvec43u(v, '.wyz'); // 423
export fn wzx(v: gvec4u) -> gvec3u = gvec43u(v, '.wzx'); // 431
export fn wzy(v: gvec4u) -> gvec3u = gvec43u(v, '.wzy'); // 432
export fn ijk(v: gvec4u) -> gvec3u = v.xyz;
export fn ijl(v: gvec4u) -> gvec3u = v.xyw;
export fn ikj(v: gvec4u) -> gvec3u = v.xzy;
export fn ikl(v: gvec4u) -> gvec3u = v.xzw;
export fn ilj(v: gvec4u) -> gvec3u = v.xwy;
export fn ilk(v: gvec4u) -> gvec3u = v.xwz;
export fn jik(v: gvec4u) -> gvec3u = v.yxz;
export fn jil(v: gvec4u) -> gvec3u = v.yxw;
export fn jki(v: gvec4u) -> gvec3u = v.yzx;
export fn jkl(v: gvec4u) -> gvec3u = v.yzw;
export fn jli(v: gvec4u) -> gvec3u = v.ywx;
export fn jlk(v: gvec4u) -> gvec3u = v.ywz;
export fn kij(v: gvec4u) -> gvec3u = v.zxy;
export fn kil(v: gvec4u) -> gvec3u = v.zxw;
export fn kji(v: gvec4u) -> gvec3u = v.zyx;
export fn kjl(v: gvec4u) -> gvec3u = v.zyw;
export fn kli(v: gvec4u) -> gvec3u = v.zwx;
export fn klj(v: gvec4u) -> gvec3u = v.zwy;
export fn lij(v: gvec4u) -> gvec3u = v.wxy;
export fn lik(v: gvec4u) -> gvec3u = v.wxz;
export fn lji(v: gvec4u) -> gvec3u = v.wyx;
export fn ljk(v: gvec4u) -> gvec3u = v.wyz;
export fn lki(v: gvec4u) -> gvec3u = v.wzx;
export fn lkj(v: gvec4u) -> gvec3u = v.wzy;
export fn rgb(v: gvec4u) -> gvec3u = v.xyz;
export fn rga(v: gvec4u) -> gvec3u = v.xyw;
export fn rbg(v: gvec4u) -> gvec3u = v.xzy;
export fn rba(v: gvec4u) -> gvec3u = v.xzw;
export fn rag(v: gvec4u) -> gvec3u = v.xwy;
export fn rab(v: gvec4u) -> gvec3u = v.xwz;
export fn grb(v: gvec4u) -> gvec3u = v.yxz;
export fn gra(v: gvec4u) -> gvec3u = v.yxw;
export fn gbr(v: gvec4u) -> gvec3u = v.yzx;
export fn gba(v: gvec4u) -> gvec3u = v.yzw;
export fn gar(v: gvec4u) -> gvec3u = v.ywx;
export fn gab(v: gvec4u) -> gvec3u = v.ywz;
export fn brg(v: gvec4u) -> gvec3u = v.zxy;
export fn bra(v: gvec4u) -> gvec3u = v.zxw;
export fn bgr(v: gvec4u) -> gvec3u = v.zyx;
export fn bga(v: gvec4u) -> gvec3u = v.zyw;
export fn bar(v: gvec4u) -> gvec3u = v.zwx;
export fn bag(v: gvec4u) -> gvec3u = v.zwy;
export fn arb(v: gvec4u) -> gvec3u = v.wxy;
export fn arg(v: gvec4u) -> gvec3u = v.wxz;
export fn abr(v: gvec4u) -> gvec3u = v.wyx;
export fn abg(v: gvec4u) -> gvec3u = v.wyz;
export fn agr(v: gvec4u) -> gvec3u = v.wzx;
export fn agb(v: gvec4u) -> gvec3u = v.wzy;

fn gvec44u(v: gvec4u, a: string) -> gvec4u {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4u(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4u) -> gvec4u = gvec44u(v, '.xyzw'); // 1234
export fn xywz(v: gvec4u) -> gvec4u = gvec44u(v, '.xywz'); // 1243
export fn xzyw(v: gvec4u) -> gvec4u = gvec44u(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4u) -> gvec4u = gvec44u(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4u) -> gvec4u = gvec44u(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4u) -> gvec4u = gvec44u(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4u) -> gvec4u = gvec44u(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4u) -> gvec4u = gvec44u(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4u) -> gvec4u = gvec44u(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4u) -> gvec4u = gvec44u(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4u) -> gvec4u = gvec44u(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4u) -> gvec4u = gvec44u(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4u) -> gvec4u = gvec44u(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4u) -> gvec4u = gvec44u(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4u) -> gvec4u = gvec44u(v, '.zyxw'); // 3214
export fn zywx(v: gvec4u) -> gvec4u = gvec44u(v, '.zywx'); // 3241
export fn zwxy(v: gvec4u) -> gvec4u = gvec44u(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4u) -> gvec4u = gvec44u(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4u) -> gvec4u = gvec44u(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4u) -> gvec4u = gvec44u(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4u) -> gvec4u = gvec44u(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4u) -> gvec4u = gvec44u(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4u) -> gvec4u = gvec44u(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4u) -> gvec4u = gvec44u(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4u) -> gvec4u = v.xyzw;
export fn ijlk(v: gvec4u) -> gvec4u = v.xywz;
export fn ikjl(v: gvec4u) -> gvec4u = v.xzyw;
export fn iklj(v: gvec4u) -> gvec4u = v.xzwy;
export fn iljk(v: gvec4u) -> gvec4u = v.xwyz;
export fn ilkj(v: gvec4u) -> gvec4u = v.xwzy;
export fn jikl(v: gvec4u) -> gvec4u = v.yxzw;
export fn jilk(v: gvec4u) -> gvec4u = v.yxwz;
export fn jkil(v: gvec4u) -> gvec4u = v.yzxw;
export fn jkli(v: gvec4u) -> gvec4u = v.yzwx;
export fn jlik(v: gvec4u) -> gvec4u = v.ywxz;
export fn jlki(v: gvec4u) -> gvec4u = v.ywzx;
export fn kijl(v: gvec4u) -> gvec4u = v.zxyw;
export fn kilj(v: gvec4u) -> gvec4u = v.zxwy;
export fn kjil(v: gvec4u) -> gvec4u = v.zyxw;
export fn kjli(v: gvec4u) -> gvec4u = v.zywx;
export fn klij(v: gvec4u) -> gvec4u = v.zwxy;
export fn klji(v: gvec4u) -> gvec4u = v.zwyx;
export fn lijk(v: gvec4u) -> gvec4u = v.wxyz;
export fn likj(v: gvec4u) -> gvec4u = v.wxzy;
export fn ljik(v: gvec4u) -> gvec4u = v.wyxz;
export fn ljki(v: gvec4u) -> gvec4u = v.wyzx;
export fn lkij(v: gvec4u) -> gvec4u = v.wzxy;
export fn lkji(v: gvec4u) -> gvec4u = v.wzyx;
export fn rgba(v: gvec4u) -> gvec4u = v.xyzw;
export fn rgab(v: gvec4u) -> gvec4u = v.xywz;
export fn rbga(v: gvec4u) -> gvec4u = v.xzyw;
export fn rbag(v: gvec4u) -> gvec4u = v.xzwy;
export fn ragb(v: gvec4u) -> gvec4u = v.xwyz;
export fn rabg(v: gvec4u) -> gvec4u = v.xwzy;
export fn grba(v: gvec4u) -> gvec4u = v.yxzw;
export fn grab(v: gvec4u) -> gvec4u = v.yxwz;
export fn gbra(v: gvec4u) -> gvec4u = v.yzxw;
export fn gbar(v: gvec4u) -> gvec4u = v.yzwx;
export fn garb(v: gvec4u) -> gvec4u = v.ywxz;
export fn gabr(v: gvec4u) -> gvec4u = v.ywzx;
export fn argb(v: gvec4u) -> gvec4u = v.wxyz;
export fn arbg(v: gvec4u) -> gvec4u = v.wxzy;
export fn agrb(v: gvec4u) -> gvec4u = v.wyxz;
export fn agbr(v: gvec4u) -> gvec4u = v.wyzx;
export fn abrg(v: gvec4u) -> gvec4u = v.wzxy;
export fn abgr(v: gvec4u) -> gvec4u = v.wzyx;

export fn x(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4i) -> gi32 {
  let varName = v.varName.concat('.w');
  return gi32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4i) -> gi32 = v.x;
export fn j(v: gvec4i) -> gi32 = v.y;
export fn k(v: gvec4i) -> gi32 = v.z;
export fn l(v: gvec4i) -> gi32 = v.w;
export fn r(v: gvec4i) -> gi32 = v.x;
export fn g(v: gvec4i) -> gi32 = v.y;
export fn b(v: gvec4i) -> gi32 = v.z;
export fn a(v: gvec4i) -> gi32 = v.w;

fn gvec42i(v: gvec4i, a: string) -> gvec2i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4i) -> gvec2i = gvec42i(v, '.xy');
export fn yx(v: gvec4i) -> gvec2i = gvec42i(v, '.yx');
export fn xz(v: gvec4i) -> gvec2i = gvec42i(v, '.xz');
export fn zx(v: gvec4i) -> gvec2i = gvec42i(v, '.zx');
export fn xw(v: gvec4i) -> gvec2i = gvec42i(v, '.xw');
export fn wx(v: gvec4i) -> gvec2i = gvec42i(v, '.wx');
export fn yz(v: gvec4i) -> gvec2i = gvec42i(v, '.yz');
export fn zy(v: gvec4i) -> gvec2i = gvec42i(v, '.zy');
export fn yw(v: gvec4i) -> gvec2i = gvec42i(v, '.yw');
export fn wy(v: gvec4i) -> gvec2i = gvec42i(v, '.wy');
export fn zw(v: gvec4i) -> gvec2i = gvec42i(v, '.zw');
export fn wz(v: gvec4i) -> gvec2i = gvec42i(v, '.wz');
export fn ij(v: gvec4i) -> gvec2i = v.xy;
export fn ji(v: gvec4i) -> gvec2i = v.yx;
export fn ik(v: gvec4i) -> gvec2i = v.xz;
export fn ki(v: gvec4i) -> gvec2i = v.zx;
export fn il(v: gvec4i) -> gvec2i = v.xw;
export fn li(v: gvec4i) -> gvec2i = v.wx;
export fn jk(v: gvec4i) -> gvec2i = v.yz;
export fn kj(v: gvec4i) -> gvec2i = v.zy;
export fn jl(v: gvec4i) -> gvec2i = v.yw;
export fn lj(v: gvec4i) -> gvec2i = v.wy;
export fn kl(v: gvec4i) -> gvec2i = v.zw;
export fn lk(v: gvec4i) -> gvec2i = v.wz;
export fn rg(v: gvec4i) -> gvec2i = v.xy;
export fn gr(v: gvec4i) -> gvec2i = v.yx;
export fn rb(v: gvec4i) -> gvec2i = v.xz;
export fn br(v: gvec4i) -> gvec2i = v.zx;
export fn ra(v: gvec4i) -> gvec2i = v.xw;
export fn ar(v: gvec4i) -> gvec2i = v.wx;
export fn gb(v: gvec4i) -> gvec2i = v.yz;
export fn bg(v: gvec4i) -> gvec2i = v.zy;
export fn ga(v: gvec4i) -> gvec2i = v.yw;
export fn ag(v: gvec4i) -> gvec2i = v.wy;
export fn ba(v: gvec4i) -> gvec2i = v.zw;
export fn ab(v: gvec4i) -> gvec2i = v.wz;

fn gvec43i(v: gvec4i, a: string) -> gvec3i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4i) -> gvec3i = gvec43i(v, '.xyz'); // 123
export fn xyw(v: gvec4i) -> gvec3i = gvec43i(v, '.xyw'); // 124
export fn xzy(v: gvec4i) -> gvec3i = gvec43i(v, '.xzy'); // 132
export fn xzw(v: gvec4i) -> gvec3i = gvec43i(v, '.xzw'); // 134
export fn xwy(v: gvec4i) -> gvec3i = gvec43i(v, '.xwy'); // 142
export fn xwz(v: gvec4i) -> gvec3i = gvec43i(v, '.xwz'); // 143
export fn yxz(v: gvec4i) -> gvec3i = gvec43i(v, '.yxz'); // 213
export fn yxw(v: gvec4i) -> gvec3i = gvec43i(v, '.yxw'); // 214
export fn yzx(v: gvec4i) -> gvec3i = gvec43i(v, '.yzx'); // 231
export fn yzw(v: gvec4i) -> gvec3i = gvec43i(v, '.yzw'); // 234
export fn ywx(v: gvec4i) -> gvec3i = gvec43i(v, '.ywx'); // 241
export fn ywz(v: gvec4i) -> gvec3i = gvec43i(v, '.ywz'); // 243
export fn zxy(v: gvec4i) -> gvec3i = gvec43i(v, '.zxy'); // 312
export fn zxw(v: gvec4i) -> gvec3i = gvec43i(v, '.zxw'); // 314
export fn zyx(v: gvec4i) -> gvec3i = gvec43i(v, '.zyx'); // 321
export fn zyw(v: gvec4i) -> gvec3i = gvec43i(v, '.zyw'); // 324
export fn zwx(v: gvec4i) -> gvec3i = gvec43i(v, '.zwx'); // 341
export fn zwy(v: gvec4i) -> gvec3i = gvec43i(v, '.zwy'); // 342
export fn wxy(v: gvec4i) -> gvec3i = gvec43i(v, '.wxy'); // 412
export fn wxz(v: gvec4i) -> gvec3i = gvec43i(v, '.wxz'); // 413
export fn wyx(v: gvec4i) -> gvec3i = gvec43i(v, '.wyx'); // 421
export fn wyz(v: gvec4i) -> gvec3i = gvec43i(v, '.wyz'); // 423
export fn wzx(v: gvec4i) -> gvec3i = gvec43i(v, '.wzx'); // 431
export fn wzy(v: gvec4i) -> gvec3i = gvec43i(v, '.wzy'); // 432
export fn ijk(v: gvec4i) -> gvec3i = v.xyz;
export fn ijl(v: gvec4i) -> gvec3i = v.xyw;
export fn ikj(v: gvec4i) -> gvec3i = v.xzy;
export fn ikl(v: gvec4i) -> gvec3i = v.xzw;
export fn ilj(v: gvec4i) -> gvec3i = v.xwy;
export fn ilk(v: gvec4i) -> gvec3i = v.xwz;
export fn jik(v: gvec4i) -> gvec3i = v.yxz;
export fn jil(v: gvec4i) -> gvec3i = v.yxw;
export fn jki(v: gvec4i) -> gvec3i = v.yzx;
export fn jkl(v: gvec4i) -> gvec3i = v.yzw;
export fn jli(v: gvec4i) -> gvec3i = v.ywx;
export fn jlk(v: gvec4i) -> gvec3i = v.ywz;
export fn kij(v: gvec4i) -> gvec3i = v.zxy;
export fn kil(v: gvec4i) -> gvec3i = v.zxw;
export fn kji(v: gvec4i) -> gvec3i = v.zyx;
export fn kjl(v: gvec4i) -> gvec3i = v.zyw;
export fn kli(v: gvec4i) -> gvec3i = v.zwx;
export fn klj(v: gvec4i) -> gvec3i = v.zwy;
export fn lij(v: gvec4i) -> gvec3i = v.wxy;
export fn lik(v: gvec4i) -> gvec3i = v.wxz;
export fn lji(v: gvec4i) -> gvec3i = v.wyx;
export fn ljk(v: gvec4i) -> gvec3i = v.wyz;
export fn lki(v: gvec4i) -> gvec3i = v.wzx;
export fn lkj(v: gvec4i) -> gvec3i = v.wzy;
export fn rgb(v: gvec4i) -> gvec3i = v.xyz;
export fn rga(v: gvec4i) -> gvec3i = v.xyw;
export fn rbg(v: gvec4i) -> gvec3i = v.xzy;
export fn rba(v: gvec4i) -> gvec3i = v.xzw;
export fn rag(v: gvec4i) -> gvec3i = v.xwy;
export fn rab(v: gvec4i) -> gvec3i = v.xwz;
export fn grb(v: gvec4i) -> gvec3i = v.yxz;
export fn gra(v: gvec4i) -> gvec3i = v.yxw;
export fn gbr(v: gvec4i) -> gvec3i = v.yzx;
export fn gba(v: gvec4i) -> gvec3i = v.yzw;
export fn gar(v: gvec4i) -> gvec3i = v.ywx;
export fn gab(v: gvec4i) -> gvec3i = v.ywz;
export fn brg(v: gvec4i) -> gvec3i = v.zxy;
export fn bra(v: gvec4i) -> gvec3i = v.zxw;
export fn bgr(v: gvec4i) -> gvec3i = v.zyx;
export fn bga(v: gvec4i) -> gvec3i = v.zyw;
export fn bar(v: gvec4i) -> gvec3i = v.zwx;
export fn bag(v: gvec4i) -> gvec3i = v.zwy;
export fn arb(v: gvec4i) -> gvec3i = v.wxy;
export fn arg(v: gvec4i) -> gvec3i = v.wxz;
export fn abr(v: gvec4i) -> gvec3i = v.wyx;
export fn abg(v: gvec4i) -> gvec3i = v.wyz;
export fn agr(v: gvec4i) -> gvec3i = v.wzx;
export fn agb(v: gvec4i) -> gvec3i = v.wzy;

fn gvec44i(v: gvec4i, a: string) -> gvec4i {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4i(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4i) -> gvec4i = gvec44i(v, '.xyzw'); // 1234
export fn xywz(v: gvec4i) -> gvec4i = gvec44i(v, '.xywz'); // 1243
export fn xzyw(v: gvec4i) -> gvec4i = gvec44i(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4i) -> gvec4i = gvec44i(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4i) -> gvec4i = gvec44i(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4i) -> gvec4i = gvec44i(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4i) -> gvec4i = gvec44i(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4i) -> gvec4i = gvec44i(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4i) -> gvec4i = gvec44i(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4i) -> gvec4i = gvec44i(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4i) -> gvec4i = gvec44i(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4i) -> gvec4i = gvec44i(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4i) -> gvec4i = gvec44i(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4i) -> gvec4i = gvec44i(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4i) -> gvec4i = gvec44i(v, '.zyxw'); // 3214
export fn zywx(v: gvec4i) -> gvec4i = gvec44i(v, '.zywx'); // 3241
export fn zwxy(v: gvec4i) -> gvec4i = gvec44i(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4i) -> gvec4i = gvec44i(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4i) -> gvec4i = gvec44i(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4i) -> gvec4i = gvec44i(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4i) -> gvec4i = gvec44i(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4i) -> gvec4i = gvec44i(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4i) -> gvec4i = gvec44i(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4i) -> gvec4i = gvec44i(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4i) -> gvec4i = v.xyzw;
export fn ijlk(v: gvec4i) -> gvec4i = v.xywz;
export fn ikjl(v: gvec4i) -> gvec4i = v.xzyw;
export fn iklj(v: gvec4i) -> gvec4i = v.xzwy;
export fn iljk(v: gvec4i) -> gvec4i = v.xwyz;
export fn ilkj(v: gvec4i) -> gvec4i = v.xwzy;
export fn jikl(v: gvec4i) -> gvec4i = v.yxzw;
export fn jilk(v: gvec4i) -> gvec4i = v.yxwz;
export fn jkil(v: gvec4i) -> gvec4i = v.yzxw;
export fn jkli(v: gvec4i) -> gvec4i = v.yzwx;
export fn jlik(v: gvec4i) -> gvec4i = v.ywxz;
export fn jlki(v: gvec4i) -> gvec4i = v.ywzx;
export fn kijl(v: gvec4i) -> gvec4i = v.zxyw;
export fn kilj(v: gvec4i) -> gvec4i = v.zxwy;
export fn kjil(v: gvec4i) -> gvec4i = v.zyxw;
export fn kjli(v: gvec4i) -> gvec4i = v.zywx;
export fn klij(v: gvec4i) -> gvec4i = v.zwxy;
export fn klji(v: gvec4i) -> gvec4i = v.zwyx;
export fn lijk(v: gvec4i) -> gvec4i = v.wxyz;
export fn likj(v: gvec4i) -> gvec4i = v.wxzy;
export fn ljik(v: gvec4i) -> gvec4i = v.wyxz;
export fn ljki(v: gvec4i) -> gvec4i = v.wyzx;
export fn lkij(v: gvec4i) -> gvec4i = v.wzxy;
export fn lkji(v: gvec4i) -> gvec4i = v.wzyx;
export fn rgba(v: gvec4i) -> gvec4i = v.xyzw;
export fn rgab(v: gvec4i) -> gvec4i = v.xywz;
export fn rbga(v: gvec4i) -> gvec4i = v.xzyw;
export fn rbag(v: gvec4i) -> gvec4i = v.xzwy;
export fn ragb(v: gvec4i) -> gvec4i = v.xwyz;
export fn rabg(v: gvec4i) -> gvec4i = v.xwzy;
export fn grba(v: gvec4i) -> gvec4i = v.yxzw;
export fn grab(v: gvec4i) -> gvec4i = v.yxwz;
export fn gbra(v: gvec4i) -> gvec4i = v.yzxw;
export fn gbar(v: gvec4i) -> gvec4i = v.yzwx;
export fn garb(v: gvec4i) -> gvec4i = v.ywxz;
export fn gabr(v: gvec4i) -> gvec4i = v.ywzx;
export fn argb(v: gvec4i) -> gvec4i = v.wxyz;
export fn arbg(v: gvec4i) -> gvec4i = v.wxzy;
export fn agrb(v: gvec4i) -> gvec4i = v.wyxz;
export fn agbr(v: gvec4i) -> gvec4i = v.wyzx;
export fn abrg(v: gvec4i) -> gvec4i = v.wzxy;
export fn abgr(v: gvec4i) -> gvec4i = v.wzyx;

export fn x(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn y(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn z(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn w(v: gvec4f) -> gf32 {
  let varName = v.varName.concat('.w');
  return gf32(varName, v.statements, v.buffers);
}
export fn i(v: gvec4f) -> gf32 = v.x;
export fn j(v: gvec4f) -> gf32 = v.y;
export fn k(v: gvec4f) -> gf32 = v.z;
export fn l(v: gvec4f) -> gf32 = v.w;
export fn r(v: gvec4f) -> gf32 = v.x;
export fn g(v: gvec4f) -> gf32 = v.y;
export fn b(v: gvec4f) -> gf32 = v.z;
export fn a(v: gvec4f) -> gf32 = v.w;

fn gvec42f(v: gvec4f, a: string) -> gvec2f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4f) -> gvec2f = gvec42f(v, '.xy');
export fn yx(v: gvec4f) -> gvec2f = gvec42f(v, '.yx');
export fn xz(v: gvec4f) -> gvec2f = gvec42f(v, '.xz');
export fn zx(v: gvec4f) -> gvec2f = gvec42f(v, '.zx');
export fn xw(v: gvec4f) -> gvec2f = gvec42f(v, '.xw');
export fn wx(v: gvec4f) -> gvec2f = gvec42f(v, '.wx');
export fn yz(v: gvec4f) -> gvec2f = gvec42f(v, '.yz');
export fn zy(v: gvec4f) -> gvec2f = gvec42f(v, '.zy');
export fn yw(v: gvec4f) -> gvec2f = gvec42f(v, '.yw');
export fn wy(v: gvec4f) -> gvec2f = gvec42f(v, '.wy');
export fn zw(v: gvec4f) -> gvec2f = gvec42f(v, '.zw');
export fn wz(v: gvec4f) -> gvec2f = gvec42f(v, '.wz');
export fn ij(v: gvec4f) -> gvec2f = v.xy;
export fn ji(v: gvec4f) -> gvec2f = v.yx;
export fn ik(v: gvec4f) -> gvec2f = v.xz;
export fn ki(v: gvec4f) -> gvec2f = v.zx;
export fn il(v: gvec4f) -> gvec2f = v.xw;
export fn li(v: gvec4f) -> gvec2f = v.wx;
export fn jk(v: gvec4f) -> gvec2f = v.yz;
export fn kj(v: gvec4f) -> gvec2f = v.zy;
export fn jl(v: gvec4f) -> gvec2f = v.yw;
export fn lj(v: gvec4f) -> gvec2f = v.wy;
export fn kl(v: gvec4f) -> gvec2f = v.zw;
export fn lk(v: gvec4f) -> gvec2f = v.wz;
export fn rg(v: gvec4f) -> gvec2f = v.xy;
export fn gr(v: gvec4f) -> gvec2f = v.yx;
export fn rb(v: gvec4f) -> gvec2f = v.xz;
export fn br(v: gvec4f) -> gvec2f = v.zx;
export fn ra(v: gvec4f) -> gvec2f = v.xw;
export fn ar(v: gvec4f) -> gvec2f = v.wx;
export fn gb(v: gvec4f) -> gvec2f = v.yz;
export fn bg(v: gvec4f) -> gvec2f = v.zy;
export fn ga(v: gvec4f) -> gvec2f = v.yw;
export fn ag(v: gvec4f) -> gvec2f = v.wy;
export fn ba(v: gvec4f) -> gvec2f = v.zw;
export fn ab(v: gvec4f) -> gvec2f = v.wz;

fn gvec43f(v: gvec4f, a: string) -> gvec3f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4f) -> gvec3f = gvec43f(v, '.xyz'); // 123
export fn xyw(v: gvec4f) -> gvec3f = gvec43f(v, '.xyw'); // 124
export fn xzy(v: gvec4f) -> gvec3f = gvec43f(v, '.xzy'); // 132
export fn xzw(v: gvec4f) -> gvec3f = gvec43f(v, '.xzw'); // 134
export fn xwy(v: gvec4f) -> gvec3f = gvec43f(v, '.xwy'); // 142
export fn xwz(v: gvec4f) -> gvec3f = gvec43f(v, '.xwz'); // 143
export fn yxz(v: gvec4f) -> gvec3f = gvec43f(v, '.yxz'); // 213
export fn yxw(v: gvec4f) -> gvec3f = gvec43f(v, '.yxw'); // 214
export fn yzx(v: gvec4f) -> gvec3f = gvec43f(v, '.yzx'); // 231
export fn yzw(v: gvec4f) -> gvec3f = gvec43f(v, '.yzw'); // 234
export fn ywx(v: gvec4f) -> gvec3f = gvec43f(v, '.ywx'); // 241
export fn ywz(v: gvec4f) -> gvec3f = gvec43f(v, '.ywz'); // 243
export fn zxy(v: gvec4f) -> gvec3f = gvec43f(v, '.zxy'); // 312
export fn zxw(v: gvec4f) -> gvec3f = gvec43f(v, '.zxw'); // 314
export fn zyx(v: gvec4f) -> gvec3f = gvec43f(v, '.zyx'); // 321
export fn zyw(v: gvec4f) -> gvec3f = gvec43f(v, '.zyw'); // 324
export fn zwx(v: gvec4f) -> gvec3f = gvec43f(v, '.zwx'); // 341
export fn zwy(v: gvec4f) -> gvec3f = gvec43f(v, '.zwy'); // 342
export fn wxy(v: gvec4f) -> gvec3f = gvec43f(v, '.wxy'); // 412
export fn wxz(v: gvec4f) -> gvec3f = gvec43f(v, '.wxz'); // 413
export fn wyx(v: gvec4f) -> gvec3f = gvec43f(v, '.wyx'); // 421
export fn wyz(v: gvec4f) -> gvec3f = gvec43f(v, '.wyz'); // 423
export fn wzx(v: gvec4f) -> gvec3f = gvec43f(v, '.wzx'); // 431
export fn wzy(v: gvec4f) -> gvec3f = gvec43f(v, '.wzy'); // 432
export fn ijk(v: gvec4f) -> gvec3f = v.xyz;
export fn ijl(v: gvec4f) -> gvec3f = v.xyw;
export fn ikj(v: gvec4f) -> gvec3f = v.xzy;
export fn ikl(v: gvec4f) -> gvec3f = v.xzw;
export fn ilj(v: gvec4f) -> gvec3f = v.xwy;
export fn ilk(v: gvec4f) -> gvec3f = v.xwz;
export fn jik(v: gvec4f) -> gvec3f = v.yxz;
export fn jil(v: gvec4f) -> gvec3f = v.yxw;
export fn jki(v: gvec4f) -> gvec3f = v.yzx;
export fn jkl(v: gvec4f) -> gvec3f = v.yzw;
export fn jli(v: gvec4f) -> gvec3f = v.ywx;
export fn jlk(v: gvec4f) -> gvec3f = v.ywz;
export fn kij(v: gvec4f) -> gvec3f = v.zxy;
export fn kil(v: gvec4f) -> gvec3f = v.zxw;
export fn kji(v: gvec4f) -> gvec3f = v.zyx;
export fn kjl(v: gvec4f) -> gvec3f = v.zyw;
export fn kli(v: gvec4f) -> gvec3f = v.zwx;
export fn klj(v: gvec4f) -> gvec3f = v.zwy;
export fn lij(v: gvec4f) -> gvec3f = v.wxy;
export fn lik(v: gvec4f) -> gvec3f = v.wxz;
export fn lji(v: gvec4f) -> gvec3f = v.wyx;
export fn ljk(v: gvec4f) -> gvec3f = v.wyz;
export fn lki(v: gvec4f) -> gvec3f = v.wzx;
export fn lkj(v: gvec4f) -> gvec3f = v.wzy;
export fn rgb(v: gvec4f) -> gvec3f = v.xyz;
export fn rga(v: gvec4f) -> gvec3f = v.xyw;
export fn rbg(v: gvec4f) -> gvec3f = v.xzy;
export fn rba(v: gvec4f) -> gvec3f = v.xzw;
export fn rag(v: gvec4f) -> gvec3f = v.xwy;
export fn rab(v: gvec4f) -> gvec3f = v.xwz;
export fn grb(v: gvec4f) -> gvec3f = v.yxz;
export fn gra(v: gvec4f) -> gvec3f = v.yxw;
export fn gbr(v: gvec4f) -> gvec3f = v.yzx;
export fn gba(v: gvec4f) -> gvec3f = v.yzw;
export fn gar(v: gvec4f) -> gvec3f = v.ywx;
export fn gab(v: gvec4f) -> gvec3f = v.ywz;
export fn brg(v: gvec4f) -> gvec3f = v.zxy;
export fn bra(v: gvec4f) -> gvec3f = v.zxw;
export fn bgr(v: gvec4f) -> gvec3f = v.zyx;
export fn bga(v: gvec4f) -> gvec3f = v.zyw;
export fn bar(v: gvec4f) -> gvec3f = v.zwx;
export fn bag(v: gvec4f) -> gvec3f = v.zwy;
export fn arb(v: gvec4f) -> gvec3f = v.wxy;
export fn arg(v: gvec4f) -> gvec3f = v.wxz;
export fn abr(v: gvec4f) -> gvec3f = v.wyx;
export fn abg(v: gvec4f) -> gvec3f = v.wyz;
export fn agr(v: gvec4f) -> gvec3f = v.wzx;
export fn agb(v: gvec4f) -> gvec3f = v.wzy;

fn gvec44f(v: gvec4f, a: string) -> gvec4f {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4f(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4f) -> gvec4f = gvec44f(v, '.xyzw'); // 1234
export fn xywz(v: gvec4f) -> gvec4f = gvec44f(v, '.xywz'); // 1243
export fn xzyw(v: gvec4f) -> gvec4f = gvec44f(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4f) -> gvec4f = gvec44f(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4f) -> gvec4f = gvec44f(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4f) -> gvec4f = gvec44f(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4f) -> gvec4f = gvec44f(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4f) -> gvec4f = gvec44f(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4f) -> gvec4f = gvec44f(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4f) -> gvec4f = gvec44f(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4f) -> gvec4f = gvec44f(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4f) -> gvec4f = gvec44f(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4f) -> gvec4f = gvec44f(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4f) -> gvec4f = gvec44f(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4f) -> gvec4f = gvec44f(v, '.zyxw'); // 3214
export fn zywx(v: gvec4f) -> gvec4f = gvec44f(v, '.zywx'); // 3241
export fn zwxy(v: gvec4f) -> gvec4f = gvec44f(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4f) -> gvec4f = gvec44f(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4f) -> gvec4f = gvec44f(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4f) -> gvec4f = gvec44f(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4f) -> gvec4f = gvec44f(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4f) -> gvec4f = gvec44f(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4f) -> gvec4f = gvec44f(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4f) -> gvec4f = gvec44f(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4f) -> gvec4f = v.xyzw;
export fn ijlk(v: gvec4f) -> gvec4f = v.xywz;
export fn ikjl(v: gvec4f) -> gvec4f = v.xzyw;
export fn iklj(v: gvec4f) -> gvec4f = v.xzwy;
export fn iljk(v: gvec4f) -> gvec4f = v.xwyz;
export fn ilkj(v: gvec4f) -> gvec4f = v.xwzy;
export fn jikl(v: gvec4f) -> gvec4f = v.yxzw;
export fn jilk(v: gvec4f) -> gvec4f = v.yxwz;
export fn jkil(v: gvec4f) -> gvec4f = v.yzxw;
export fn jkli(v: gvec4f) -> gvec4f = v.yzwx;
export fn jlik(v: gvec4f) -> gvec4f = v.ywxz;
export fn jlki(v: gvec4f) -> gvec4f = v.ywzx;
export fn kijl(v: gvec4f) -> gvec4f = v.zxyw;
export fn kilj(v: gvec4f) -> gvec4f = v.zxwy;
export fn kjil(v: gvec4f) -> gvec4f = v.zyxw;
export fn kjli(v: gvec4f) -> gvec4f = v.zywx;
export fn klij(v: gvec4f) -> gvec4f = v.zwxy;
export fn klji(v: gvec4f) -> gvec4f = v.zwyx;
export fn lijk(v: gvec4f) -> gvec4f = v.wxyz;
export fn likj(v: gvec4f) -> gvec4f = v.wxzy;
export fn ljik(v: gvec4f) -> gvec4f = v.wyxz;
export fn ljki(v: gvec4f) -> gvec4f = v.wyzx;
export fn lkij(v: gvec4f) -> gvec4f = v.wzxy;
export fn lkji(v: gvec4f) -> gvec4f = v.wzyx;
export fn rgba(v: gvec4f) -> gvec4f = v.xyzw;
export fn rgab(v: gvec4f) -> gvec4f = v.xywz;
export fn rbga(v: gvec4f) -> gvec4f = v.xzyw;
export fn rbag(v: gvec4f) -> gvec4f = v.xzwy;
export fn ragb(v: gvec4f) -> gvec4f = v.xwyz;
export fn rabg(v: gvec4f) -> gvec4f = v.xwzy;
export fn grba(v: gvec4f) -> gvec4f = v.yxzw;
export fn grab(v: gvec4f) -> gvec4f = v.yxwz;
export fn gbra(v: gvec4f) -> gvec4f = v.yzxw;
export fn gbar(v: gvec4f) -> gvec4f = v.yzwx;
export fn garb(v: gvec4f) -> gvec4f = v.ywxz;
export fn gabr(v: gvec4f) -> gvec4f = v.ywzx;
export fn argb(v: gvec4f) -> gvec4f = v.wxyz;
export fn arbg(v: gvec4f) -> gvec4f = v.wxzy;
export fn agrb(v: gvec4f) -> gvec4f = v.wyxz;
export fn agbr(v: gvec4f) -> gvec4f = v.wyzx;
export fn abrg(v: gvec4f) -> gvec4f = v.wzxy;
export fn abgr(v: gvec4f) -> gvec4f = v.wzyx;

export fn x(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn y(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn z(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn w(v: gvec4b) -> gbool {
  let varName = v.varName.concat('.w');
  return gbool(varName, v.statements, v.buffers);
}
export fn i(v: gvec4b) -> gbool = v.x;
export fn j(v: gvec4b) -> gbool = v.y;
export fn k(v: gvec4b) -> gbool = v.z;
export fn l(v: gvec4b) -> gbool = v.w;
export fn r(v: gvec4b) -> gbool = v.x;
export fn g(v: gvec4b) -> gbool = v.y;
export fn b(v: gvec4b) -> gbool = v.z;
export fn a(v: gvec4b) -> gbool = v.w;

fn gvec42b(v: gvec4b, a: string) -> gvec2b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn xy(v: gvec4b) -> gvec2b = gvec42b(v, '.xy');
export fn yx(v: gvec4b) -> gvec2b = gvec42b(v, '.yx');
export fn xz(v: gvec4b) -> gvec2b = gvec42b(v, '.xz');
export fn zx(v: gvec4b) -> gvec2b = gvec42b(v, '.zx');
export fn xw(v: gvec4b) -> gvec2b = gvec42b(v, '.xw');
export fn wx(v: gvec4b) -> gvec2b = gvec42b(v, '.wx');
export fn yz(v: gvec4b) -> gvec2b = gvec42b(v, '.yz');
export fn zy(v: gvec4b) -> gvec2b = gvec42b(v, '.zy');
export fn yw(v: gvec4b) -> gvec2b = gvec42b(v, '.yw');
export fn wy(v: gvec4b) -> gvec2b = gvec42b(v, '.wy');
export fn zw(v: gvec4b) -> gvec2b = gvec42b(v, '.zw');
export fn wz(v: gvec4b) -> gvec2b = gvec42b(v, '.wz');
export fn ij(v: gvec4b) -> gvec2b = v.xy;
export fn ji(v: gvec4b) -> gvec2b = v.yx;
export fn ik(v: gvec4b) -> gvec2b = v.xz;
export fn ki(v: gvec4b) -> gvec2b = v.zx;
export fn il(v: gvec4b) -> gvec2b = v.xw;
export fn li(v: gvec4b) -> gvec2b = v.wx;
export fn jk(v: gvec4b) -> gvec2b = v.yz;
export fn kj(v: gvec4b) -> gvec2b = v.zy;
export fn jl(v: gvec4b) -> gvec2b = v.yw;
export fn lj(v: gvec4b) -> gvec2b = v.wy;
export fn kl(v: gvec4b) -> gvec2b = v.zw;
export fn lk(v: gvec4b) -> gvec2b = v.wz;
export fn rg(v: gvec4b) -> gvec2b = v.xy;
export fn gr(v: gvec4b) -> gvec2b = v.yx;
export fn rb(v: gvec4b) -> gvec2b = v.xz;
export fn br(v: gvec4b) -> gvec2b = v.zx;
export fn ra(v: gvec4b) -> gvec2b = v.xw;
export fn ar(v: gvec4b) -> gvec2b = v.wx;
export fn gb(v: gvec4b) -> gvec2b = v.yz;
export fn bg(v: gvec4b) -> gvec2b = v.zy;
export fn ga(v: gvec4b) -> gvec2b = v.yw;
export fn ag(v: gvec4b) -> gvec2b = v.wy;
export fn ba(v: gvec4b) -> gvec2b = v.zw;
export fn ab(v: gvec4b) -> gvec2b = v.wz;

fn gvec43b(v: gvec4b, a: string) -> gvec3b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn xyz(v: gvec4b) -> gvec3b = gvec43b(v, '.xyz'); // 123
export fn xyw(v: gvec4b) -> gvec3b = gvec43b(v, '.xyw'); // 124
export fn xzy(v: gvec4b) -> gvec3b = gvec43b(v, '.xzy'); // 132
export fn xzw(v: gvec4b) -> gvec3b = gvec43b(v, '.xzw'); // 134
export fn xwy(v: gvec4b) -> gvec3b = gvec43b(v, '.xwy'); // 142
export fn xwz(v: gvec4b) -> gvec3b = gvec43b(v, '.xwz'); // 143
export fn yxz(v: gvec4b) -> gvec3b = gvec43b(v, '.yxz'); // 213
export fn yxw(v: gvec4b) -> gvec3b = gvec43b(v, '.yxw'); // 214
export fn yzx(v: gvec4b) -> gvec3b = gvec43b(v, '.yzx'); // 231
export fn yzw(v: gvec4b) -> gvec3b = gvec43b(v, '.yzw'); // 234
export fn ywx(v: gvec4b) -> gvec3b = gvec43b(v, '.ywx'); // 241
export fn ywz(v: gvec4b) -> gvec3b = gvec43b(v, '.ywz'); // 243
export fn zxy(v: gvec4b) -> gvec3b = gvec43b(v, '.zxy'); // 312
export fn zxw(v: gvec4b) -> gvec3b = gvec43b(v, '.zxw'); // 314
export fn zyx(v: gvec4b) -> gvec3b = gvec43b(v, '.zyx'); // 321
export fn zyw(v: gvec4b) -> gvec3b = gvec43b(v, '.zyw'); // 324
export fn zwx(v: gvec4b) -> gvec3b = gvec43b(v, '.zwx'); // 341
export fn zwy(v: gvec4b) -> gvec3b = gvec43b(v, '.zwy'); // 342
export fn wxy(v: gvec4b) -> gvec3b = gvec43b(v, '.wxy'); // 412
export fn wxz(v: gvec4b) -> gvec3b = gvec43b(v, '.wxz'); // 413
export fn wyx(v: gvec4b) -> gvec3b = gvec43b(v, '.wyx'); // 421
export fn wyz(v: gvec4b) -> gvec3b = gvec43b(v, '.wyz'); // 423
export fn wzx(v: gvec4b) -> gvec3b = gvec43b(v, '.wzx'); // 431
export fn wzy(v: gvec4b) -> gvec3b = gvec43b(v, '.wzy'); // 432
export fn ijk(v: gvec4b) -> gvec3b = v.xyz;
export fn ijl(v: gvec4b) -> gvec3b = v.xyw;
export fn ikj(v: gvec4b) -> gvec3b = v.xzy;
export fn ikl(v: gvec4b) -> gvec3b = v.xzw;
export fn ilj(v: gvec4b) -> gvec3b = v.xwy;
export fn ilk(v: gvec4b) -> gvec3b = v.xwz;
export fn jik(v: gvec4b) -> gvec3b = v.yxz;
export fn jil(v: gvec4b) -> gvec3b = v.yxw;
export fn jki(v: gvec4b) -> gvec3b = v.yzx;
export fn jkl(v: gvec4b) -> gvec3b = v.yzw;
export fn jli(v: gvec4b) -> gvec3b = v.ywx;
export fn jlk(v: gvec4b) -> gvec3b = v.ywz;
export fn kij(v: gvec4b) -> gvec3b = v.zxy;
export fn kil(v: gvec4b) -> gvec3b = v.zxw;
export fn kji(v: gvec4b) -> gvec3b = v.zyx;
export fn kjl(v: gvec4b) -> gvec3b = v.zyw;
export fn kli(v: gvec4b) -> gvec3b = v.zwx;
export fn klj(v: gvec4b) -> gvec3b = v.zwy;
export fn lij(v: gvec4b) -> gvec3b = v.wxy;
export fn lik(v: gvec4b) -> gvec3b = v.wxz;
export fn lji(v: gvec4b) -> gvec3b = v.wyx;
export fn ljk(v: gvec4b) -> gvec3b = v.wyz;
export fn lki(v: gvec4b) -> gvec3b = v.wzx;
export fn lkj(v: gvec4b) -> gvec3b = v.wzy;
export fn rgb(v: gvec4b) -> gvec3b = v.xyz;
export fn rga(v: gvec4b) -> gvec3b = v.xyw;
export fn rbg(v: gvec4b) -> gvec3b = v.xzy;
export fn rba(v: gvec4b) -> gvec3b = v.xzw;
export fn rag(v: gvec4b) -> gvec3b = v.xwy;
export fn rab(v: gvec4b) -> gvec3b = v.xwz;
export fn grb(v: gvec4b) -> gvec3b = v.yxz;
export fn gra(v: gvec4b) -> gvec3b = v.yxw;
export fn gbr(v: gvec4b) -> gvec3b = v.yzx;
export fn gba(v: gvec4b) -> gvec3b = v.yzw;
export fn gar(v: gvec4b) -> gvec3b = v.ywx;
export fn gab(v: gvec4b) -> gvec3b = v.ywz;
export fn brg(v: gvec4b) -> gvec3b = v.zxy;
export fn bra(v: gvec4b) -> gvec3b = v.zxw;
export fn bgr(v: gvec4b) -> gvec3b = v.zyx;
export fn bga(v: gvec4b) -> gvec3b = v.zyw;
export fn bar(v: gvec4b) -> gvec3b = v.zwx;
export fn bag(v: gvec4b) -> gvec3b = v.zwy;
export fn arb(v: gvec4b) -> gvec3b = v.wxy;
export fn arg(v: gvec4b) -> gvec3b = v.wxz;
export fn abr(v: gvec4b) -> gvec3b = v.wyx;
export fn abg(v: gvec4b) -> gvec3b = v.wyz;
export fn agr(v: gvec4b) -> gvec3b = v.wzx;
export fn agb(v: gvec4b) -> gvec3b = v.wzy;

fn gvec44b(v: gvec4b, a: string) -> gvec4b {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4b(varName, v.statements, v.buffers);
}
export fn xyzw(v: gvec4b) -> gvec4b = gvec44b(v, '.xyzw'); // 1234
export fn xywz(v: gvec4b) -> gvec4b = gvec44b(v, '.xywz'); // 1243
export fn xzyw(v: gvec4b) -> gvec4b = gvec44b(v, '.xzyw'); // 1324
export fn xzwy(v: gvec4b) -> gvec4b = gvec44b(v, '.xzwy'); // 1342
export fn xwyz(v: gvec4b) -> gvec4b = gvec44b(v, '.xwyz'); // 1423
export fn xwzy(v: gvec4b) -> gvec4b = gvec44b(v, '.xwzy'); // 1432
export fn yxzw(v: gvec4b) -> gvec4b = gvec44b(v, '.yxzw'); // 2134
export fn yxwz(v: gvec4b) -> gvec4b = gvec44b(v, '.yxwz'); // 2143
export fn yzxw(v: gvec4b) -> gvec4b = gvec44b(v, '.yzxw'); // 2314
export fn yzwx(v: gvec4b) -> gvec4b = gvec44b(v, '.yzwx'); // 2341
export fn ywxz(v: gvec4b) -> gvec4b = gvec44b(v, '.ywxz'); // 2413
export fn ywzx(v: gvec4b) -> gvec4b = gvec44b(v, '.ywzx'); // 2431
export fn zxyw(v: gvec4b) -> gvec4b = gvec44b(v, '.zxyw'); // 3124
export fn zxwy(v: gvec4b) -> gvec4b = gvec44b(v, '.zxwy'); // 3142
export fn zyxw(v: gvec4b) -> gvec4b = gvec44b(v, '.zyxw'); // 3214
export fn zywx(v: gvec4b) -> gvec4b = gvec44b(v, '.zywx'); // 3241
export fn zwxy(v: gvec4b) -> gvec4b = gvec44b(v, '.zwxy'); // 3412
export fn zwyx(v: gvec4b) -> gvec4b = gvec44b(v, '.zwyx'); // 3421
export fn wxyz(v: gvec4b) -> gvec4b = gvec44b(v, '.wxyz'); // 4123
export fn wxzy(v: gvec4b) -> gvec4b = gvec44b(v, '.wxzy'); // 4132
export fn wyxz(v: gvec4b) -> gvec4b = gvec44b(v, '.wyxz'); // 4213
export fn wyzx(v: gvec4b) -> gvec4b = gvec44b(v, '.wyzx'); // 4231
export fn wzxy(v: gvec4b) -> gvec4b = gvec44b(v, '.wzxy'); // 4312
export fn wzyx(v: gvec4b) -> gvec4b = gvec44b(v, '.wzyx'); // 4321
export fn ijkl(v: gvec4b) -> gvec4b = v.xyzw;
export fn ijlk(v: gvec4b) -> gvec4b = v.xywz;
export fn ikjl(v: gvec4b) -> gvec4b = v.xzyw;
export fn iklj(v: gvec4b) -> gvec4b = v.xzwy;
export fn iljk(v: gvec4b) -> gvec4b = v.xwyz;
export fn ilkj(v: gvec4b) -> gvec4b = v.xwzy;
export fn jikl(v: gvec4b) -> gvec4b = v.yxzw;
export fn jilk(v: gvec4b) -> gvec4b = v.yxwz;
export fn jkil(v: gvec4b) -> gvec4b = v.yzxw;
export fn jkli(v: gvec4b) -> gvec4b = v.yzwx;
export fn jlik(v: gvec4b) -> gvec4b = v.ywxz;
export fn jlki(v: gvec4b) -> gvec4b = v.ywzx;
export fn kijl(v: gvec4b) -> gvec4b = v.zxyw;
export fn kilj(v: gvec4b) -> gvec4b = v.zxwy;
export fn kjil(v: gvec4b) -> gvec4b = v.zyxw;
export fn kjli(v: gvec4b) -> gvec4b = v.zywx;
export fn klij(v: gvec4b) -> gvec4b = v.zwxy;
export fn klji(v: gvec4b) -> gvec4b = v.zwyx;
export fn lijk(v: gvec4b) -> gvec4b = v.wxyz;
export fn likj(v: gvec4b) -> gvec4b = v.wxzy;
export fn ljik(v: gvec4b) -> gvec4b = v.wyxz;
export fn ljki(v: gvec4b) -> gvec4b = v.wyzx;
export fn lkij(v: gvec4b) -> gvec4b = v.wzxy;
export fn lkji(v: gvec4b) -> gvec4b = v.wzyx;
export fn rgba(v: gvec4b) -> gvec4b = v.xyzw;
export fn rgab(v: gvec4b) -> gvec4b = v.xywz;
export fn rbga(v: gvec4b) -> gvec4b = v.xzyw;
export fn rbag(v: gvec4b) -> gvec4b = v.xzwy;
export fn ragb(v: gvec4b) -> gvec4b = v.xwyz;
export fn rabg(v: gvec4b) -> gvec4b = v.xwzy;
export fn grba(v: gvec4b) -> gvec4b = v.yxzw;
export fn grab(v: gvec4b) -> gvec4b = v.yxwz;
export fn gbra(v: gvec4b) -> gvec4b = v.yzxw;
export fn gbar(v: gvec4b) -> gvec4b = v.yzwx;
export fn garb(v: gvec4b) -> gvec4b = v.ywxz;
export fn gabr(v: gvec4b) -> gvec4b = v.ywzx;
export fn brga(v: gvec4b) -> gvec4b = v.zxyw;
export fn brag(v: gvec4b) -> gvec4b = v.zxwy;
export fn bgra(v: gvec4b) -> gvec4b = v.zyxw;
export fn bgar(v: gvec4b) -> gvec4b = v.zywx;
export fn barg(v: gvec4b) -> gvec4b = v.zwxy;
export fn bagr(v: gvec4b) -> gvec4b = v.zwyx;
export fn argb(v: gvec4b) -> gvec4b = v.wxyz;
export fn arbg(v: gvec4b) -> gvec4b = v.wxzy;
export fn agrb(v: gvec4b) -> gvec4b = v.wyxz;
export fn agbr(v: gvec4b) -> gvec4b = v.wyzx;
export fn abrg(v: gvec4b) -> gvec4b = v.wzxy;
export fn abgr(v: gvec4b) -> gvec4b = v.wzyx;

// TODO: Improve GBuffer to support other buffer types
export fn get(gb: GBuffer, i: gu32) -> gi32 {
  let statement = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(gb));
  return gi32(statement, i.statements, buffers);
}

export fn store(a: gi32, b: gi32) -> gi32 {
    let statement = a.varName.concat(" = ").concat(b.varName);
    let statements = a.statements.concat(b.statements).concat(Dict(statement, statement));
    let buffers = a.buffers.union(b.buffers);
    return gi32(statement, statements, buffers);
}

// GPU Math

export fn add(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn add{T}(a: gu32, b: T) -> gu32 = add(a, b.gu32);
export fn add{T}(a: T, b: gu32) -> gu32 = add(a.gu32, b);

export fn add(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn add{T}(a: gi32, b: T) -> gi32 = add(a, b.gi32);
export fn add{T}(a: T, b: gi32) -> gi32 = add(a.gi32, b);

export fn add(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn add{T}(a: gf32, b: T) -> gf32 = add(a, b.gf32);
export fn add{T}(a: T, b: gf32) -> gf32 = add(a.gf32, b);

export fn mul(a: gu32, b: gu32) -> gu32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gu32(varName, statements, buffers);
}
export fn mul{T}(a: gu32, b: T) -> gu32 = mul(a, b.gu32);
export fn mul{T}(a: T, b: gu32) -> gu32 = mul(a.gu32, b);

export fn mul(a: gi32, b: gi32) -> gi32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gi32(varName, statements, buffers);
}
export fn mul{T}(a: gi32, b: T) -> gi32 = mul(a, b.gi32);
export fn mul{T}(a: T, b: gi32) -> gi32 = mul(a.gi32, b);

export fn mul(a: gf32, b: gf32) -> gf32 {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gf32(varName, statements, buffers);
}
export fn mul{T}(a: gf32, b: T) -> gf32 = mul(a, b.gf32);
export fn mul{T}(a: T, b: gf32) -> gf32 = mul(a.gf32, b);

// GBuffer methods

// TODO: Support more than i32 for GBuffer
export fn map(gb: GBuffer, f: (gi32) -> gi32) -> GBuffer {
  let idx = gFor(gb.len);
  let val = gb[idx];
  let out = GBuffer(gb.len.mul(4));
  let compute = out[idx].store(f(val));
  compute.build.run;
  return out;
}

/// Stdout/stderr-related bindings
// TODO: Rework this to just print anything that can be converted to `string` via interfaces
export fn print(d: Duration) binds print_duration;
export fn print{T}(v: Fallible{T}) binds println_result;
export fn print{T}(v: Maybe{T}) binds println_maybe;
export fn print{T}(v: Array{T}) binds print_vec;
export fn print{T, N}(v: Buffer{T, N}) binds print_buffer;
export fn print{T}(v: Array{Fallible{T}}) binds print_vec_result;
export fn print(v: void) binds println_void;
export fn print{T}(v: T) binds println;
export fn eprint{T}(v: Fallible{T}) binds eprintln_result;
export fn eprint{T}(v: Maybe{T}) binds eprintln_maybe;
export fn eprint{T}(v: T) binds eprintln;

// TODO: Function resolution is effectively backwards at the moment. This is the fallback `getOr`,
// but it needs to be defined last instead of first.
export fn getOr{T, U}(v: U, d: T) -> T = {T}(v).getOr(d);

/// Built-in operator definitions
export infix add as + precedence 3;
export infix sub as - precedence 3;
export prefix neg as - precedence 6;
export infix mul as * precedence 4;
export infix div as / precedence 4;
export infix mod as % precedence 4;
// export infix template as % precedence 4;
export infix pow as ** precedence 5;
export infix and as & precedence 4;
export infix and as && precedence 4;
export infix or as | precedence 3;
export infix or as || precedence 3;
export infix xor as ^ precedence 3;
export prefix not as ! precedence 5;
export infix nand as !& precedence 4;
export infix nor as !| precedence 3;
export infix xnor as !^ precedence 3;
export infix eq as == precedence 1;
export infix neq as != precedence 1;
export infix lt as < precedence 1;
export infix lte as <= precedence 1;
export infix gt as > precedence 1;
export infix gte as >= precedence 1;
export prefix len as # precedence 1; // TODO: Is this useful?
export infix shl as << precedence 2;
export infix shr as >> precedence 2;
export infix wrl as <<< precedence 2;
export infix wrr as >>> precedence 2;
export infix store as = precedence 0;
