/**
 * The Alan root scope. The functions and types it binds from Rust are either part of the standard
 * library, or are defined in the sibling root.rs file
 **/

/// Type system setup

// Declaration of the types the compiler-time type system is built on. There are four groups of these compiler-defined types: meta types of the type system itself, host types to interact with the host language, type types to construct your own types, and compute types that perform compile-time computation

/// Meta types
ctype Type; // Any kind of concrete type
ctype Generic; // Any type that is a generic type (not yet realized into a concrete type)
ctype Int{T}; // An integer used *to define a type*, like the length of a fixed array. Can be used as a generic to cast a type into an integer, or fail otherwise
ctype Float{T}; // A float used to define a type. I have no idea why you'd want this, yet. Can be used as a generic to cast a type into a float, or fail otherwise
ctype Bool{T}; // A bool used to define a type. Heavily used for conditional compilation. Can be used as a generic to cast a type into a bool, or fail otherwise
ctype String{T}; // A string used to define a type. Useful for conditional inclusion of files/code. Can be used as a generic to cast a type into a string
ctype Group{G}; // A grouping of type statements `()`. Useful to allow for tuples of tuples
ctype Unwrap{T}; // Unwraps a type into its definition. Useful for creating a new type that extends an existing type, or iteratively building up a type
ctype Function{I, O}; // A function type, indicating the input and output of the function
ctype AnyOf{A, B}; // The AnyOf type is kinda like a Tuple, in that all sub-types are present, but it only *resolves* into one of these types above it. Useful for choosing the "best" integer, or a particular function by name.

/// Host types
ctype Binds{T}; // A direct reference into the platform language's type system
ctype Call{N, F}; // A reference to a function call (or method, etc) in the platform language
ctype Infix{O}; // A reference to a native infix operation in the platform language
ctype Prefix{O}; // A reference to a native prefix operation in the platform language
ctype Method{F}; // A reference to a native method in the platform language
ctype Property{P}; // A reference to a native property in the platform language
ctype Cast{T}; // A reference to a native type in the platform language to cast to
ctype Own{T}; // Specifying that the native code needs an owned version of the type
ctype Deref{T}; // Specifying that the native code needs an owned version of the type and it is safe to dereference the reference
ctype Mut{T}; // Specifying that the function (native or otherwise) needs a mutable reference of the type
ctype Dependency{N, V}; // The representation of a dependency (of some form or another). Does nothing on its own
ctype Rust{D}; // Specifying that the provided dependency is a Rust dependency.
ctype Nodejs{D}; // Specifying that the provided dependency is a Node.js dependency.
ctype Import{N, D}; // Imports the named value from the dependency.
ctype From{D}; // Pulls the desired value from the dependency. Magically figures out which is needed through compiler trickery.

/// Type types
ctype Tuple{A, B}; // A tuple of two (or more) types in a single compound type
ctype Field{L, V}; // Labeling a type with a property name. Useful to turn tuples into structs
ctype Either{A, B}; // An either type, allowing the value to be from *one* of the specified types, kinda like Rust enums
ctype Buffer{T, S}; // A buffer type, a pre-allocated, fixed-length array of the specified type the specified amount
ctype Array{T}; // An array type, a variable-length array of the specified type the specified amount. This would usually be an stdlib type built in the language itself, but we're just going to re-use the one in the platform language

/// Compute types
ctype Prop{T, P}; // Extracts the inner type from the outer type by the property name or number
ctype Len{A}; // Returns the length of the input type in terms of the number of elements it contains, which is most useful for Buffers, Tuples, and Either, causes a compiler failure for Arrays, and returns 1 for everything else
ctype Size{T}; // Returns the size in bytes of the type in question, if possible, causing a compiler failure otherwise.
ctype FileStr{F}; // Read a file and return a string constant, useful for including large strings from a separate, nearby file, or fails if it doesn't exist
ctype Concat{A, B}; // Concatenates two strings together at compile time
ctype Env{K}; // Read an environment variable at compile time and return a string of the value. Returns an empty string if the key doesn't exist. Intended to be used with...
ctype EnvExists{K}; // Returns a boolean if the environment variable key exists at compile time, and...
ctype Fail{M}; // A special type that if ever encountered at compile time causes the compilation to fail with the specified error message. Useful with conditional types
ctype If{C, A, B}; // A conditional type, if C is true, resolves to A, otherwise to B. There's also a simpler version...
ctype If{C, T}; // That expects a two-type tuple and extracts the first tuple type for true and the second for false, which can be bound to symbolic syntax
ctype Env{K, D}; // Finally, since the majority of the time this is what you'd want, this variant of `Env` takes a default value to use when the key does not exist, making this another conditional type
ctype Neg{A}; // Negate the value
ctype Add{A, B}; // Combines the Int or Float types together at compile time into a new Int or Float. Fails if an Int and Float are mixed.
ctype Sub{A, B}; // Same, but subtracts them
ctype Mul{A, B}; // Multiplication
ctype Div{A, B}; // Division
ctype Mod{A, B}; // Modulus (remainder)
ctype Pow{A, B}; // Exponentiation/Power
ctype Min{A, B}; // Minimum value of the two
ctype Max{A, B}; // Maximum value of the two
ctype Not{A}; // Inverts the boolean provided
ctype And{A, B}; // Performs a boolean or bitwise AND on the inputs, depending on type
ctype Or{A, B}; // Performs a boolean or bitwise OR on the inputs
ctype Xor{A, B}; // Performs a boolean or bitwise XOR on the inputs
ctype Nand{A, B}; // Performs a boolean or bitwise NAND on the inputs
ctype Nor{A, B}; // Performs a boolean or bitwise NOR on the inputs
ctype Xnor{A, B}; // Performs a boolean or bitwise XNOR on the inputs (same as EQ for booleans)
ctype Eq{A, B}; // Returns true if the two types are the same (or are the same int, float, bool, or string), false otherwise
ctype Neq{A, B}; // Returns true if the two types are difference
ctype Lt{A, B}; // Returns true if A is less than B (and are an int or float)
ctype Lte{A, B}; // Returns true if A is less than or equal to B
ctype Gt{A, B}; // Returns true if A is greater than B
ctype Gte{A, B}; // Returns true if A is greater than or equal to B

// Defining the operators in the type system; they can be defined before the types themselves
type infix Function as -> precedence 4; // I -> O, where I is the input and O is the output. With Tuples and Fields you can reconstruct arguments for functions.
type infix Call as :: precedence 0; // N :: F, where N is the native function (or method) and F is the function type
type infix Dependency as @ precedence 1; // N @ V, where N is the name of the dependency and V is the version
type infix Import as <- precedence 0; // N <- D, where N is the name of the value to be imported and D is the dependency to pull it from
type prefix From as <-- precedence 0; // <- D, where D is the dependency to pull a value or values from, TODO: Switch to <- once disambiguation is fixed
type infix Tuple as , precedence 0; // A, B, C, ... The tuple type combines with other tuple types to become a larger tuple type. To have a tuple of tuples, you need to `Group` the inner tuple, eg `(a, b), c`
type infix Field as : precedence 1; // Foo: Bar, let's you specify a property access label for the type, useful for syntactic sugar on a tuple type and the Either type (eventually).
type infix Either as | precedence 0; // A | B, the type has a singular value from only one of the types at once.
type infix Prop as . precedence 6; // A.B, returns the sub-type within A referenced by property B. Allows an inverse of a Tuple or Either type, accessed by either the Field name or an integer index
type infix AnyOf as & precedence 0; // A & B, which can be passed to a function that takes A or B as necessary.
type infix Buffer as [ precedence 2; // Technically allows `Foo[3` by itself to be valid syntax, but...
type postfix Self as ] precedence 11; // This one goes to eleven. Technically not necessary, but allows for `Foo[3]` to do the "right thing" and become a buffer of size 3
type postfix Array as [] precedence 5; // Allows `Foo[]` to do the right thing
type postfix Maybe as ? precedence 5; // Allows `Foo?` for nullable types. Should this have a precedence of 5?
type postfix Fallible as ! precedence 5; // Allows `Foo!` for fallible types. Same question on the precedence.
type infix Add as + precedence 3;
type infix Sub as - precedence 3;
type infix Mul as * precedence 4;
type infix Div as / precedence 4;
type infix Mod as % precedence 4;
type infix Pow as ** precedence 5;
type infix If as :? precedence 1; // C puts this kind of thing as a very high precedence. I'm not sure if I want to follow it. I feel like that would force grouping parens everywhere.
type infix And as && precedence 4;
type infix Or as || precedence 3;
type infix Xor as ^ precedence 3;
type prefix Not as ~ precedence 5; // TODO: Temporarily change this from ! to ~ until the operator prefix/postfix tiebreaker is updated to accept whichever *works* rather than prefer prefix
type infix Nand as !& precedence 4;
type infix Nor as !| precedence 3;
type infix Xnor as !^ precedence 3;
type infix Eq as == precedence 1;
type infix Neq as != precedence 1;
type infix Lt as < precedence 1;
type infix Lte as <= precedence 1;
type infix Gt as > precedence 1;
type infix Gte as >= precedence 1;

// Environment variable-derived boolean constants to be used by the root scope (or your own code)
type Test = Env{"ALAN_TARGET"} == "test";
type Release = Env{"ALAN_TARGET"} == "release";
type Debug = Env{"ALAN_TARGET"} == "debug";
type Rs = Env{"ALAN_OUTPUT_LANG"} == "rs";
type Js = Env{"ALAN_OUTPUT_LANG"} == "js";
type Lin = Env{"ALAN_PLATFORM"} == "linux";
type Win = Env{"ALAN_PLATFORM"} == "windows";
type Mac = Env{"ALAN_PLATFORM"} == "macos";
type x86_32 = Env{"ALAN_ARCH"} == "x86_32";
type x86_64 = Env{"ALAN_ARCH"} == "x86_64";
type arm_32 = Env{"ALAN_ARCH"} == "arm_32";
type arm_64 = ENV{"ALAN_ARCH"} == "arm_64";
type Browser = Env{"ALAN_PLATFORM"} == "browser"; // Technically not necessary, always also Js

// Importing the Root Scope backing implementation and supporting 3rd party libraries
type{Rs} RootBacking = Rust{"alan_std" @ "https://github.com/alantech/alan.git"};
type{Rs && Mac && x86_64} = Rust{"alan_std" @ "https://github.com/alantech/alan.git#eff8b0661015df144c430f387349f790e717819b"}; // Until wgpu fixes the regression post v24 for x86 Macs 
type{Js} RootBacking = Nodejs{"alan_std" @ "https://github.com/alantech/alan.git"};

// Defining derived types
type void = ();
type Self{T} = T;
type{Rs} Error = Binds{"alan_std::AlanError" <- RootBacking};
type{Js} Error = Binds{"alan_std.AlanError" <- RootBacking};
type Fallible{T} = T | Error;
type Maybe{T} = T | ();

// Binding the float types
type{Rs} f32 = Binds{"f32"};
type{Js} f32 = Binds{"alan_std.F32" <- RootBacking};
type{Rs} f64 = Binds{"f64"};
type{Js} f64 = Binds{"alan_std.F64" <- RootBacking};

// Binding the integer types
type{Rs} u8 = Binds{"u8"};
type{Js} u8 = Binds{"alan_std.U8" <- RootBacking};
type{Rs} u16 = Binds{"u16"};
type{Js} u16 = Binds{"alan_std.U16" <- RootBacking};
type{Rs} u32 = Binds{"u32"};
type{Js} u32 = Binds{"alan_std.U32" <- RootBacking};
type{Rs} u64 = Binds{"u64"};
type{Js} u64 = Binds{"alan_std.U64" <- RootBacking};
type{Rs} i8 = Binds{"i8"};
type{Js} i8 = Binds{"alan_std.I8" <- RootBacking};
type{Rs} i16 = Binds{"i16"};
type{Js} i16 = Binds{"alan_std.I16" <- RootBacking};
type{Rs} i32 = Binds{"i32"};
type{Js} i32 = Binds{"alan_std.I32" <- RootBacking};
type{Rs} i64 = Binds{"i64"};
type{Js} i64 = Binds{"alan_std.I64" <- RootBacking};

// Binding the string types
type{Rs} string = Binds{"String"};
type{Js} string = Binds{"alan_std.Str" <- RootBacking};

// Binding the boolean types
type{Rs} bool = Binds{"bool"};
type{Js} bool = Binds{"alan_std.Bool" <- RootBacking};

// Binding the exit code type
type{Rs} ExitCode = Binds{"std::process::ExitCode"};
type{Js} ExitCode = Binds{"Number"};

// Binding the time types
type{Rs} Instant = Binds{"std::time::Instant"};
type{Rs} Duration = Binds{"std::time::Duration"};
type{Js} Performance = Binds{"Performance"}

// Binding the uuid type
type{Rs} uuid = Binds{"alan_std::Uuid" <- RootBacking};
type{Js} uuid = Binds{"alan_std.uuidv4" <- RootBacking};

// Binding the Dict and Set types
type{Rs} Dict{K, V} = Binds{"alan_std::OrderedHashMap" <- RootBacking, K, V};
type{Js} Dict{K, V} = Binds{"Map", K, V};
type{Rs} Set{V} = Binds{"std::collections::HashSet", V};
type{Js} Set{V} = Binds{"alan_std.FuzzySet" <- RootBacking, V};

// Basic trig constants (this language is meant for GPGPU, this makes sense in the root scope)
const e = 2.718281828459045;
const pi = 3.141592653589793;
const tau = 6.283185307179586;

/// Built-in operator definitions; can be defined before the functions are
infix add as + precedence 5;
infix sub as - precedence 5;
prefix neg as - precedence 8;
infix mul as * precedence 6;
infix cross as >< precedence 6;
infix dot as *. precedence 6;
infix div as / precedence 6;
infix mod as % precedence 6;
// export infix template as % precedence 4;
infix pow as ** precedence 7;
infix and as & precedence 3;
infix and as && precedence 3;
infix or as | precedence 2;
infix or as || precedence 2;
infix getOr as ?? precedence 8;
postfix getOrExit as !! precedence 8;
postfix Maybe as ? precedence 9;
postfix Fallible as ! precedence 9;
infix xor as ^ precedence 2;
prefix not as ! precedence 4;
infix nand as !& precedence 3;
infix nor as !| precedence 2;
infix xnor as !^ precedence 2;
infix eq as == precedence 4;
infix neq as != precedence 4;
infix lt as < precedence 4;
infix lte as <= precedence 4;
infix gt as > precedence 4;
infix gte as >= precedence 4;
prefix len as # precedence 1; // TODO: Is this useful?
infix shl as << precedence 5;
infix shr as >> precedence 5;
infix wrl as <<< precedence 5;
infix wrr as >>> precedence 5;
infix store as = precedence 0;

/// Functions for (potentially) every type
fn{Rs} clone{T} (v: T) -> T = {Method{"clone"} :: (v: T) -> T}(v);
fn{Js} clone{T} (v: T) -> T = {"alan_std.clone" <- RootBacking :: (v: T) -> T}(v);
fn void{T}(v: T) -> void {}
fn void() -> void {}
fn{Rs} store{T} (a: Mut{T}, b: T) -> T = {"std::mem::replace" :: (Mut{T}, Own{T}) -> T}(a, b);
fn{Js} store{T} (a: Mut{T}, b: T) -> T = {"((a, b) => Object.keys(b).forEach((k) => a[k] = b[k]))" :: (Mut{T}, T) -> T}(a, b);

/// Fallible, Maybe, and Either functions
fn{Rs} Maybe{T}(v: T!) = {Method{"ok"} :: T! -> T?}(v);
fn{Rs} Fallible{T}(v: T?, e: Error) = {Method{"ok_or"} :: (T?, Error) -> T!}(v, e);
fn getOr{T, U}(v: U, d: T) = {T}(v) ?? d;
fn{Rs} getOr{T} (v: T?, d: T) = {Method{"unwrap_or"} :: (Own{T?}, Own{T}) -> T}(v, d);
fn{Js} getOr{T} (v: T?, d: T) = {"((v, d) => v ?? d)" :: (T?, T) -> T}(v, d);
fn{Rs} getOr{T} (v: T!, d: T) = {Method{"unwrap_or"} :: (Own{T!}, Own{T}) -> T}(v, d);
fn{Js} getOr{T} (v: T!, d: T) = {"((v, d) => v instanceof alan_std.AlanError ? d : v)" :: (T!, T) -> T}(v, d);
fn{Rs} getOrExit{T} (v: T!) = {Method{"unwrap"} :: Own{T!} -> T}(v);
fn{Js} getOrExit{T} (v: T!) = {"((a) => { if (!(a instanceof alan_std.AlanError)) { return a; } else { process.exit(101); } })" :: T! -> T}(v);
fn{Rs} getOrExit{T} (v: T?) = {Method{"unwrap"} :: Own{T?} -> T}(v);
fn{Js} getOrExit{T} (v: T?) = {"((a) => { if (a !== null && a !== undefined) { return a; } else { process.exit(101); } })" :: T? -> T}(v);
fn{Rs} Error{T} (e: string) = {"Err" :: Own{Error} -> T!}(
  {Method{"into"} :: Own{string} -> Error}(e));
fn{Rs} Error (e: string) = {Method{"into"} :: Own{string} -> Error}(e);
fn{Js} Error{T} "new alan_std.AlanError" <- RootBacking :: string -> T!;
fn{Js} Error "new alan_std.AlanError" <- RootBacking :: string -> Error;
fn{Rs} exists{T} (m: T?) = {Method{"is_some"} :: T? -> bool}(m);
fn{Js} exists{T} (m: T?) = {"((a) => new alan_std.Bool(a !== null))" <- RootBacking :: T? -> bool}(m);
fn{Rs} exists{T} (m: T!) = {Method{"is_ok"} :: T! -> bool}(m);
fn{Js} exists{T} (m: T!) = {"((a) => new alan_std.Bool(!(a instanceof alan_std.AlanError)))" <- RootBacking :: T! -> bool}(m);
fn{Rs} string(e: Error) = {"format!" :: ("{}", Error) -> string}(e);
fn{Js} string Property{"message"} :: Error -> string;

/// Primitive type casting functions
fn{Rs} f32 Cast{"f32"} :: Deref{i8} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: i8 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{i16} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: i16 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{i32} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: i32 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{i64} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: i64 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{u8} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: u8 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{u16} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: u16 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{u32} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: u32 -> f32;
fn{Rs} f32 Cast{"f32"} :: Deref{u64} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: u64 -> f32;
fn f32(f: f32) = f;
fn{Rs} f32 Cast{"f32"} :: Deref{f64} -> f32;
fn{Js} f32 "new alan_std.F32" <- RootBacking :: f64 -> f32;
fn{Rs} f32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> f32!;
fn{Js} f32 "((s) => { let f = parseFloat(s.val); if (Number.isNaN(f)) { return alan_std.nanToError(f); } else { return new alan_std.F32(f); } })" :: string -> f32!;

fn{Rs} f64 Cast{"f64"} :: Deref{i8} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: i8 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{i16} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: i16 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{i32} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: i32 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{i64} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: i64 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{u8} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: u8 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{u16} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: u16 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{u32} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: u32 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{u64} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: u64 -> f64;
fn{Rs} f64 Cast{"f64"} :: Deref{f32} -> f64;
fn{Js} f64 "new alan_std.F64" <- RootBacking :: f32 -> f64;
fn f64(f: f64) = f;
fn{Rs} f64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> f64!;
fn{Js} f64 "((s) => { let f = parseFloat(s.val); if (Number.isNaN(f)) { return alan_std.nanToError(f); } else { return new alan_std.F32(f); } })" :: string -> f64!;

fn{Rs} u8 Cast{"u8"} :: Deref{i8} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: i8 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{i16} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: i16 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{i32} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: i32 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{i64} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: i64 -> u8;
fn u8(i: u8) = i;
fn{Rs} u8 Cast{"u8"} :: Deref{u16} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: u16 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{u32} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: u32 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{u64} -> u8;
fn{Js} u8 "new alan_std.U8" <- RootBacking :: u64 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{f32} -> u8;
fn{Js} u8 "((f) => new alan_std.U8(Math.floor(f.val)))" <- RootBacking :: f32 -> u8;
fn{Rs} u8 Cast{"u8"} :: Deref{f64} -> u8;
fn{Js} u8 "((f) => new alan_std.U8(Math.floor(f.val)))" <- RootBacking :: f64 -> u8;
fn{Rs} u8 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u8!;
fn{Js} u8 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U8(v); } })" <- RootBacking :: string -> u8!;

fn{Rs} u16 Cast{"u16"} :: Deref{i8} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: i8 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{i16} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: i16 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{i32} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: i32 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{i64} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: i64 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{u8} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: u8 -> u16;
fn u16(i: u16) = i;
fn{Rs} u16 Cast{"u16"} :: Deref{u32} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: u32 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{u64} -> u16;
fn{Js} u16 "new alan_std.U16" <- RootBacking :: u64 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{f32} -> u16;
fn{Js} u16 "((f) => new alan_std.U16(Math.floor(f.val)))" <- RootBacking :: f32 -> u16;
fn{Rs} u16 Cast{"u16"} :: Deref{f64} -> u16;
fn{Js} u16 "((f) => new alan_std.U16(Math.floor(f.val)))" <- RootBacking :: f64 -> u16;
fn{Rs} u16 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u16!;
fn{Js} u16 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U16(v); } })" <- RootBacking :: string -> u16!;

fn{Rs} u32 Cast{"u32"} :: Deref{i8} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: i8 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{i16} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: i16 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{i32} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: i32 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{i64} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: i64 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{u8} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: u8 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{u16} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: u16 -> u32;
fn u32(i: u32) = i;
fn{Rs} u32 Cast{"u32"} :: Deref{u64} -> u32;
fn{Js} u32 "new alan_std.U32" <- RootBacking :: u64 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{f32} -> u32;
fn{Js} u32 "((f) => new alan_std.U32(Math.floor(f.val)))" <- RootBacking :: f32 -> u32;
fn{Rs} u32 Cast{"u32"} :: Deref{f64} -> u32;
fn{Js} u32 "((f) => new alan_std.U32(Math.floor(f.val)))" <- RootBacking :: f64 -> u32;
fn{Rs} u32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u32!;
fn{Js} u32 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U32(v); } })" <- RootBacking :: string -> u32!;

fn{Rs} u64 Cast{"u64"} :: Deref{i8} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: i8 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{i16} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: i16 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{i32} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: i32 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{i64} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: i64 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{u8} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: u8 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{u16} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: u16 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{u32} -> u64;
fn{Js} u64 "new alan_std.U64" <- RootBacking :: u32 -> u64;
fn u64(u: u64) = u;
fn{Rs} u64 Cast{"u64"} :: Deref{f32} -> u64;
fn{Js} u64 "((f) => new alan_std.U64(Math.floor(f.val)))" <- RootBacking :: f32 -> u64;
fn{Rs} u64 Cast{"u64"} :: Deref{f64} -> u64;
fn{Js} u64 "((f) => new alan_std.U64(Math.floor(f.val)))" <- RootBacking :: f64 -> u64;
fn{Rs} u64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u64!;
fn{Js} u64 "((s) => { try { return new alan_std.U64(BigInt(s.val)) } catch (e) { return new alan_std.AlanError(new alan_std.Str(e.message)); } })" <- RootBacking :: string -> u64!;

fn i8(i: i8) = i;
fn{Rs} i8 Cast{"i8"} :: Deref{i16} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: i16 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{i32} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: i32 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{i64} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: i64 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{u8} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: u8 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{u16} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: u16 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{u32} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: u32 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{u64} -> i8;
fn{Js} i8 "new alan_std.I8" <- RootBacking :: u64 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{f32} -> i8;
fn{Js} i8 "((f) => new alan_std.I8(Math.floor(f.val)))" <- RootBacking :: f32 -> i8;
fn{Rs} i8 Cast{"i8"} :: Deref{f64} -> i8;
fn{Js} i8 "((f) => new alan_std.I8(Math.floor(f.val)))" <- RootBacking :: f64 -> i8;
// TODO: LOL, what a hack
fn{Rs} i8 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i8!;
fn{Js} i8 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I8(v); } })" <- RootBacking :: string -> i8!;

fn{Rs} i16 Cast{"i16"} :: Deref{i8} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: i8 -> i16;
fn i16(i: i16) = i;
fn{Rs} i16 Cast{"i16"} :: Deref{i32} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: i32 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{i64} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: i64 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{u8} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: u8 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{u16} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: u16 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{u32} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: u32 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{u64} -> i16;
fn{Js} i16 "new alan_std.I16" <- RootBacking :: u64 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{f32} -> i16;
fn{Js} i16 "((f) => new alan_std.I16(Math.floor(f.val)))" <- RootBacking :: f32 -> i16;
fn{Rs} i16 Cast{"i16"} :: Deref{f64} -> i16;
fn{Js} i16 "((f) => new alan_std.I16(Math.floor(f.val)))" <- RootBacking :: f64 -> i16;
fn{Rs} i16 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i16!;
fn{Js} i16 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I16(v); } })" <- RootBacking :: string -> i16!;

fn{Rs} i32 Cast{"i32"} :: Deref{i8} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: i8 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{i16} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: i16 -> i32;
fn i32(i: i32) = i;
fn{Rs} i32 Cast{"i32"} :: Deref{i64} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: i64 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{u8} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: u8 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{u16} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: u16 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{u32} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: u32 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{u64} -> i32;
fn{Js} i32 "new alan_std.I32" <- RootBacking :: u64 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{f32} -> i32;
fn{Js} i32 "((f) => new alan_std.I32(Math.floor(f.val)))" <- RootBacking :: f32 -> i32;
fn{Rs} i32 Cast{"i32"} :: Deref{f64} -> i32;
fn{Js} i32 "((f) => new alan_std.I32(Math.floor(f.val)))" <- RootBacking :: f64 -> i32;
fn{Js} i32 (f: f64) -> i32 = {"new alan_std.I32" <- RootBacking :: f64 -> i32}(
  {"Math.floor" :: f64 -> f64}(f));
fn{Rs} i32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i32!;
fn{Js} i32 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I32(v); } })" <- RootBacking :: string -> i32!;

fn{Rs} i64 Cast{"i64"} :: Deref{i8} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: i8 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{i16} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: i16 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{i32} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: i32 -> i64;
fn i64(i: i64) = i;
fn{Rs} i64 Cast{"i64"} :: Deref{u8} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: u8 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{u16} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: u16 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{u32} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: u32 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{u64} -> i64;
fn{Js} i64 "new alan_std.I64" <- RootBacking :: u64 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{f32} -> i64;
fn{Js} i64 "((f) => new alan_std.I64(Math.floor(f.val)))" <- RootBacking :: f32 -> i64;
fn{Rs} i64 Cast{"i64"} :: Deref{f64} -> i64;
fn{Js} i64 "((f) => new alan_std.I64(Math.floor(f.val)))" <- RootBacking :: f64 -> i64;
fn{Rs} i64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i64!;
fn{Js} i64 "((s) => { try { return new alan_std.I64(BigInt(s.val)) } catch (e) { return new alan_std.AlanError(new alan_std.Str(e.message)); } })" <- RootBacking :: string -> i64!;

fn{Rs} bool (i: i8) = {Infix{"!="} :: (Deref{i8}, Deref{i8}) -> bool}(i, 0.i8);
fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i8 -> bool;
fn{Rs} bool (i: i16) = {Infix{"!="} :: (Deref{i16}, Deref{i16}) -> bool}(i, 0.i16);
fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i16 -> bool;
fn{Rs} bool (i: i32) = {Infix{"!="} :: (Deref{i32}, Deref{i32}) -> bool}(i, 0.i32);
fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i32 -> bool;
fn{Rs} bool (i: i64) = {Infix{"!="} :: (Deref{i64}, Deref{i64}) -> bool}(i, 0);
fn{Js} bool "((i) => new alan_std.Bool(i.val != 0n))" <- RootBacking :: i64 -> bool;
fn{Rs} bool (u: u8) = {Infix{"!="} :: (Deref{u8}, Deref{u8}) -> bool}(u, 0.u8);
fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u8 -> bool;
fn{Rs} bool (u: u16) = {Infix{"!="} :: (Deref{u16}, Deref{u16}) -> bool}(u, 0.u16);
fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u16 -> bool;
fn{Rs} bool (u: u32) = {Infix{"!="} :: (Deref{u32}, Deref{u32}) -> bool}(u, 0.u32);
fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u32 -> bool;
fn{Rs} bool (u: u64) = {Infix{"!="} :: (Deref{u64}, Deref{u64}) -> bool}(u, 0.u64);
fn{Js} bool "((u) => new alan_std.Bool(u.val != 0n))" <- RootBacking :: u64 -> bool;
fn{Rs} bool (f: f32) = {Infix{"!="} :: (Deref{f32}, Deref{f32}) -> bool}(f, 0.f32);
fn{Js} bool "((f) => new alan_std.Bool(f.val != 0.0))" <- RootBacking :: f32 -> bool;
fn{Rs} bool (f: f64) = {Infix{"!="} :: (Deref{f64}, Deref{f64}) -> bool}(f, 0.f64);
fn{Js} bool "((f) => new alan_std.Bool(f.val != 0.0))" <- RootBacking :: f64 -> bool;
fn{Rs} bool(s: string) = {Infix{"=="} :: (string, string) -> bool}(s, "true");
fn{Js} bool "((s) => new alan_std.Bool(s.val == 'true'))" <- RootBacking :: string -> bool;
fn bool(b: bool) = b;

/// Bitcasting functions (TODO: Is there a better naming scheme possible?)
fn asU8(v: u8) = v;
fn{Rs} asU8(v: i8) = {"u8::from_le_bytes" :: Own{Buffer{u8, 1}} -> u8}({"i8::to_le_bytes" :: Own{i8} -> Buffer{u8, 1}}(v));
fn{Js} asU8 "alan_std.i8AsU8" <- RootBacking :: i8 -> u8;
fn asU16(v: u16) = v;
fn{Rs} asU16(v: i16) = {"u16::from_le_bytes" :: Own{Buffer{u8, 2}} -> u16}({"i16::to_le_bytes" :: Own{i16} -> Buffer{u8, 2}}(v));
fn{Js} asU16 "alan_std.i16AsU16" <- RootBacking :: i16 -> u16;
fn asU32(v: u32) = v;
fn{Rs} asU32(v: i32) = {"u32::from_le_bytes" :: Own{Buffer{u8, 4}} -> u32}({"i32::to_le_bytes" :: Own{i32} -> Buffer{u8, 4}}(v));
fn{Js} asU32 "alan_std.i32AsU32" <- RootBacking :: i32 -> u32;
fn{Rs} asU32(v: f32) = {"u32::from_le_bytes" :: Own{Buffer{u8, 4}} -> u32}({"f32::to_le_bytes" :: Own{f32} -> Buffer{u8, 4}}(v));
fn{Js} asU32 "alan_std.f32AsU32" <- RootBacking :: f32 -> u32;
fn asU64(v: u64) = v;
fn{Rs} asU64(v: i64) = {"u64::from_le_bytes" :: Own{Buffer{u8, 8}} -> u64}({"i64::to_le_bytes" :: Own{i64} -> Buffer{u8, 8}}(v));
fn{Js} asU64 "alan_std.i64AsU64" <- RootBacking :: i64 -> u64;
fn{Rs} asU64(v: f64) = {"u64::from_le_bytes" :: Own{Buffer{u8, 8}} -> f64}({"f64::to_le_bytes" :: Own{f64} -> Buffer{u8, 8}}(v));
fn{Js} asU64 "alan_std.f64AsU64" <- RootBacking :: f64 -> u64;

fn{Rs} asI8(v: u8) = {"i8::from_le_bytes" :: Own{Buffer{u8, 1}} -> i8}({"u8::to_le_bytes" :: Own{u8} -> Buffer{u8, 1}}(v));
fn{Js} asI8 "alan_std.u8AsI8" <- RootBacking :: u8 -> i8;
fn asI8(v: i8) = v;
fn{Rs} asI16(v: u16) = {"i16::from_le_bytes" :: Own{Buffer{u8, 2}} -> i16}({"u16::to_le_bytes" :: Own{u16} -> Buffer{u8, 2}}(v));
fn{Js} asI16 "alan_std.u16AsI16" <- RootBacking :: u16 -> i16;
fn asI16(v: i16) = v;
fn{Rs} asI32(v: u32) = {"i32::from_le_bytes" :: Own{Buffer{u8, 4}} -> i32}({"u32::to_le_bytes" :: Own{u32} -> Buffer{u8, 4}}(v));
fn{Js} asI32 "alan_std.u32AsI32" <- RootBacking :: u32 -> i32;
fn asI32(v: i32) = v;
fn{Rs} asI32(v: f32) = {"i32::from_le_bytes" :: Own{Buffer{u8, 4}} -> i32}({"f32::to_le_bytes" :: Own{f32} -> Buffer{u8, 4}}(v));
fn{Js} asI32 "alan_std.f32AsI32" <- RootBacking :: f32 -> i32;
fn{Rs} asI64(v: u64) = {"i64::from_le_bytes" :: Own{Buffer{u8, 8}} -> i64}({"u64::to_le_bytes" :: Own{u64} -> Buffer{u8, 8}}(v));
fn{Js} asI64 "alan_std.u64AsI64" <- RootBacking :: u64 -> i64;
fn asI64(v: i64) = v;
fn{Rs} asI64(v: f64) = {"i64::from_le_bytes" :: Own{Buffer{u8, 8}} -> i64}({"f64::to_le_bytes" :: Own{f64} -> Buffer{u8, 8}}(v));
fn{Js} asI64 "alan_std.f64AsI64" <- RootBacking :: f64 -> i64;

fn{Rs} asF32(v: u32) = {"f32::from_le_bytes" :: Own{Buffer{u8, 4}} -> f32}({"u32::to_le_bytes" :: Own{u32} -> Buffer{u8, 4}}(v));
fn{Js} asF32 "alan_std.u32AsF32" <- RootBacking :: u32 -> f32;
fn{Rs} asF32(v: i32) = {"f32::from_le_bytes" :: Own{Buffer{u8, 4}} -> f32}({"i32::to_le_bytes" :: Own{i32} -> Buffer{u8, 4}}(v));
fn{Js} asF32 "alan_std.i32AsF32" <- RootBacking :: i32 -> f32;
fn asF32(v: f32) = v;
fn{Rs} asF64(v: u64) = {"f64::from_le_bytes" :: Own{Buffer{u8, 8}} -> f64}({"u64::to_le_bytes" :: Own{u64} -> Buffer{u8, 8}}(v));
fn{Js} asF64 "alan_std.u64AsF64" <- RootBacking :: u64 -> f64;
fn{Rs} asF64(v: i64) = {"f64::from_le_bytes" :: Own{Buffer{u8, 8}} -> f64}({"i64::to_le_bytes" :: Own{i64} -> Buffer{u8, 8}}(v));
fn{Js} asF64 "alan_std.i64AsF64" <- RootBacking :: i64 -> f64;
fn asF64(v: f64) = v;

/// Boolean-related functions
fn{Rs} and Infix{"&&"} :: (Deref{bool}, Deref{bool}) -> bool;
fn{Js} and "((a, b) => new alan_std.Bool(a.val && b.val))" <- RootBacking :: (bool, bool) -> bool;
fn{Rs} or Infix{"||"} :: (Deref{bool}, Deref{bool}) -> bool;
fn{Js} or "((a, b) => new alan_std.Bool(a.val || b.val))" <- RootBacking :: (bool, bool) -> bool;
fn{Rs} xor Infix{"^"} :: (Deref{bool}, Deref{bool}) -> bool;
fn{Js} xor "((a, b) => new alan_std.Bool(!!(a.val ^ b.val)))" <- RootBacking :: (bool, bool) -> bool;
fn{Rs} not Prefix{"!"} :: Deref{bool} -> bool;
fn{Js} not "((a) => new alan_std.Bool(!a.val))" :: bool -> bool;
fn nand (a: bool, b: bool) = a.and(b).not;
fn nor (a: bool, b: bool) = a.or(b).not;
fn{Rs} xnor Infix{"=="} :: (bool, bool) -> bool;
fn{Js} xnor "((a, b) => new alan_std.Bool(a.val == b.val))" :: (bool, bool) -> bool;
fn{Rs} eq Infix{"=="} :: (bool, bool) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" :: (bool, bool) -> bool;
fn{Rs} neq Infix{"!="} :: (bool, bool) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" :: (bool, bool) -> bool;
fn if{T}(c: bool, t: T) = if(c, fn () = Maybe{T}(t), fn () = Maybe{T}());
fn if{T}(c: bool, t: T, f: T) = if(c, fn () = t, fn () = f);
fn if{T}(c: bool, t: () -> T) = if(c, fn () = Maybe{T}(t()), fn () = Maybe{T}());
fn{Rs} if{T} "alan_std::ifbool" <- RootBacking :: (bool, () -> T, () -> T) -> T;
fn{Js} if{T} "alan_std.ifbool" <- RootBacking :: (bool, () -> T, () -> T) -> T;
fn{Js} if(c: bool, t: () -> ()) {
  if(c, t, fn { 0; });
}
fn{Rs} if "ifstatementhack" :: (bool, () -> ()) -> ();
fn{Rs} if "ifelsestatementhack" :: (bool, () -> (), () -> ()) -> ();

/// Float-related functions
fn{Rs} add Infix{"+"} :: (f32, f32) -> f32;
fn{Js} add "((a, b) => new alan_std.F32(a.val + b.val))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} sub Infix{"-"} :: (f32, f32) -> f32;
fn{Js} sub "((a, b) => new alan_std.F32(a.val - b.val))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} mul Infix{"*"} :: (f32, f32) -> f32;
fn{Js} mul "((a, b) => new alan_std.F32(a.val * b.val))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} div Infix{"/"} :: (f32, f32) -> f32;
fn{Js} div "((a, b) => new alan_std.F32(a.val / b.val))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} sqrt Method{"sqrt"} :: f32 -> f32;
fn{Js} sqrt "((a) => new alan_std.F32(Math.sqrt(a)))" <- RootBacking :: f32 -> f32;
fn{Rs} pow Method{"powf"} :: (f32, Deref{f32}) -> f32;
fn{Js} pow "((a, b) => new alan_std.F32(a.val ** b.val))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} abs Method{"abs"} :: f32 -> f32;
fn{Js} abs "((a) => new alan_std.F32(Math.abs(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} neg Prefix{"-"} :: Deref{f32} -> f32;
fn{Js} neg "((a) => new alan_std.F32(-a.val))" <- RootBacking :: f32 -> f32;
fn{Rs} eq Infix{"=="} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} eq "((a, b) => new alan_std.F32(a.val == b.val))" <- RootBacking :: (f32, f32) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} neq "((a, b) => new alan_std.F32(a.val != b.val))" <- RootBacking :: (f32, f32) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (f32, f32) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (f32, f32) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (f32, f32) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{f32}, Deref{f32}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (f32, f32) -> bool;
fn min (a: f32, b: f32) = if(a <= b, a, b);
fn max (a: f32, b: f32) = if(a >= b, a, b);
fn clamp(v: f32, l: f32, h: f32) = if(v <= l, l, if(v >= h, h, v));
fn saturate(v: f32) = clamp(v, 0.0.f32, 1.0.f32);
fn{Rs} floor Method{"floor"} :: f32 -> f32;
fn{Js} floor "((a) => new alan_std.F32(Math.floor(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} ceil Method{"ceil"} :: f32 -> f32;
fn{Js} ceil "((a) => new alan_std.F32(Math.ceil(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} acos Method{"acos"} :: f32 -> f32;
fn{Js} acos "((a) => new alan_std.F32(Math.acos(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} acosh Method{"acosh"} :: f32 -> f32;
fn{Js} acosh "((a) => new alan_std.F32(Math.acosh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} asin Method{"asin"} :: f32 -> f32;
fn{Js} asin "((a) => new alan_std.F32(Math.asin(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} asinh Method{"asinh"} :: f32 -> f32;
fn{Js} asinh "((a) => new alan_std.F32(Math.asinh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} atan Method{"atan"} :: f32 -> f32;
fn{Js} atan "((a) => new alan_std.F32(Math.atan(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} atanh Method{"atanh"} :: f32 -> f32;
fn{Js} atanh "((a) => new alan_std.F32(Math.atanh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} atan2 Method{"atan2"} :: (f32, Deref{f32}) -> f32;
fn{Js} atan2 "((a, b) => new alan_std.F32(Math.atan2(a.val, b.val)))" <- RootBacking :: (f32, f32) -> f32;
fn{Rs} cos Method{"cos"} :: f32 -> f32;
fn{Js} cos "((a) => new alan_std.F32(Math.cos(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} cosh Method{"cosh"} :: f32 -> f32;
fn{Js} cosh "((a) => new alan_std.F32(Math.cosh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} sin Method{"sin"} :: f32 -> f32;
fn{Js} sin "((a) => new alan_std.F32(Math.sin(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} sinh Method{"sinh"} :: f32 -> f32;
fn{Js} sinh "((a) => new alan_std.F32(Math.sinh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} tan Method{"tan"} :: f32 -> f32;
fn{Js} tan "((a) => new alan_std.F32(Math.tan(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} tanh Method{"tanh"} :: f32 -> f32;
fn{Js} tanh "((a) => new alan_std.F32(Math.tanh(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} exp Method{"exp"} :: f32 -> f32;
fn{Js} exp "((a) => new alan_std.F32(Math.exp(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} ln Method{"ln"} :: f32 -> f32;
fn{Js} ln "((a) => new alan_std.F32(Math.log(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} log2 Method{"log2"} :: f32 -> f32;
fn{Js} log2 "((a) => new alan_std.F32(Math.log2(a.val)))" <- RootBacking :: f32 -> f32;
fn{Rs} log10 Method{"log10"} :: f32 -> f32;
fn{Js} log10 "((a) => new alan_std.F32(Math.log10(a.val)))" <- RootBacking :: f32 -> f32;
fn sec(x: f32) = 1.0.f32 / cos(x);
fn csc(x: f32) = 1.0.f32 / sin(x);
fn cot(x: f32) = 1.0.f32 / tan(x);
fn asec(x: f32) = acos(1.0.f32 / x);
fn acsc(x: f32) = asin(1.0.f32 / x);
fn acot(x: f32) = pi.f32 / 2.0.f32 - atan(x);
fn sech(x: f32) = 1.0.f32 / cosh(x);
fn csch(x: f32) = 1.0.f32 / sinh(x);
fn coth(x: f32) = 1.0.f32 / tanh(x);
fn asech(x: f32) = ln((1.0.f32 + sqrt(1.0.f32 - x ** 2.0.f32)) / x);
fn acsch(x: f32) = ln(1.0.f32 / x + sqrt(1.0.f32 / x ** 2.0.f32 + 1.0.f32));
fn acoth(x: f32) = ln((x + 1.0.f32) / (x - 1.0.f32)) / 2.0.f32;
fn{Rs} round Method{"round_ties_even"} :: Deref{f32} -> f32;
fn{Js} round Method{"roundTiesEven"} :: f32 -> f32;
fn magnitude f32 = arg0.abs;
fn{Rs} inverseSqrt (v: f32) = {Method{"recip"} :: f32 -> f32}(sqrt(v));
fn{Js} inverseSqrt (v: f32) = 1.0.f32 / sqrt(v);
fn{Rs} fma Method{"mul_add"} :: (f32, Deref{f32}, Deref{f32}) -> f32;
fn{Js} fma "((a, b, c) => new alan_std.F32(a.val * b.val + c.val))" <- RootBacking :: (f32, f32, f32) -> f32;
fn{Rs} fract Method{"fract"} :: f32 -> f32;
fn{Js} fract "((a) => new alan_std.F32(a.val % 1))" <- RootBacking :: f32 -> f32;

fn{Rs} add Infix{"+"} :: (f64, f64) -> f64;
fn{Js} add "((a, b) => new alan_std.F64(a.val + b.val))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} sub Infix{"-"} :: (f64, f64) -> f64;
fn{Js} sub "((a, b) => new alan_std.F64(a.val - b.val))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} mul Infix{"*"} :: (f64, f64) -> f64;
fn{Js} mul "((a, b) => new alan_std.F64(a.val * b.val))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} div Infix{"/"} :: (f64, f64) -> f64;
fn{Js} div "((a, b) => new alan_std.F64(a.val / b.val))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} sqrt Method{"sqrt"} :: f64 -> f64;
fn{Js} sqrt "((a) => new alan_std.F64(Math.sqrt(a)))" <- RootBacking :: f64 -> f64;
fn{Rs} pow Method{"powf"} :: (f64, Deref{f64}) -> f64;
fn{Js} pow "((a, b) => new alan_std.F64(a.val ** b.val))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} abs Method{"abs"} :: f64 -> f64;
fn{Js} abs "((a) => new alan_std.F64(Math.abs(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} neg Prefix{"-"} :: Deref{f64} -> f64;
fn{Js} neg "((a) => new alan_std.F64(-a.val))" <- RootBacking :: f64 -> f64;
fn{Rs} eq Infix{"=="} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} eq "((a, b) => new alan_std.F64(a.val == b.val))" <- RootBacking :: (f64, f64) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} neq "((a, b) => new alan_std.F64(a.val != b.val))" <- RootBacking :: (f64, f64) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} lt "((a, b) => new alan_std.F64(a.val < b.val))" <- RootBacking :: (f64, f64) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} lte "((a, b) => new alan_std.F64(a.val <= b.val))" <- RootBacking :: (f64, f64) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} gt "((a, b) => new alan_std.F64(a.val > b.val))" <- RootBacking :: (f64, f64) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{f64}, Deref{f64}) -> bool;
fn{Js} gte "((a, b) => new alan_std.F64(a.val >= b.val))" <- RootBacking :: (f64, f64) -> bool;
fn min (a: f64, b: f64) = if(a <= b, a, b);
fn max (a: f64, b: f64) = if(a >= b, a, b);
fn clamp(v: f64, l: f64, h: f64) = if(v <= l, l, if(v >= h, h, v));
fn saturate(v: f64) = clamp(v, 0.0, 1.0);
fn{Rs} floor Method{"floor"} :: f64 -> f64;
fn{Js} floor "((a) => new alan_std.F64(Math.floor(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} ceil Method{"ceil"} :: f64 -> f64;
fn{Js} ceil "((a) => new alan_std.F64(Math.ceil(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} acos Method{"acos"} :: f64 -> f64;
fn{Js} acos "((a) => new alan_std.F64(Math.acos(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} acosh Method{"acosh"} :: f64 -> f64;
fn{Js} acosh "((a) => new alan_std.F64(Math.acosh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} asin Method{"asin"} :: f64 -> f64;
fn{Js} asin "((a) => new alan_std.F64(Math.asin(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} asinh Method{"asinh"} :: f64 -> f64;
fn{Js} asinh "((a) => new alan_std.F64(Math.asinh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} atan Method{"atan"} :: f64 -> f64;
fn{Js} atan "((a) => new alan_std.F64(Math.atan(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} atanh Method{"atanh"} :: f64 -> f64;
fn{Js} atanh "((a) => new alan_std.F64(Math.atanh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} atan2 Method{"atan2"} :: (f64, Deref{f64}) -> f64;
fn{Js} atan2 "((a, b) => new alan_std.F64(Math.atan2(a.val, b.val)))" <- RootBacking :: (f64, f64) -> f64;
fn{Rs} cos Method{"cos"} :: f64 -> f64;
fn{Js} cos "((a) => new alan_std.F64(Math.cos(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} cosh Method{"cosh"} :: f64 -> f64;
fn{Js} cosh "((a) => new alan_std.F64(Math.cosh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} sin Method{"sin"} :: f64 -> f64;
fn{Js} sin "((a) => new alan_std.F64(Math.sin(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} sinh Method{"sinh"} :: f64 -> f64;
fn{Js} sinh "((a) => new alan_std.F64(Math.sinh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} tan Method{"tan"} :: f64 -> f64;
fn{Js} tan "((a) => new alan_std.F64(Math.tan(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} tanh Method{"tanh"} :: f64 -> f64;
fn{Js} tanh "((a) => new alan_std.F64(Math.tanh(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} exp Method{"exp"} :: f64 -> f64;
fn{Js} exp "((a) => new alan_std.F64(Math.exp(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} ln Method{"ln"} :: f64 -> f64;
fn{Js} ln "((a) => new alan_std.F64(Math.log(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} log2 Method{"log2"} :: f64 -> f64;
fn{Js} log2 "((a) => new alan_std.F64(Math.log2(a.val)))" <- RootBacking :: f64 -> f64;
fn{Rs} log10 Method{"log10"} :: f64 -> f64;
fn{Js} log10 "((a) => new alan_std.F64(Math.log10(a.val)))" <- RootBacking :: f64 -> f64;
fn sec(x: f64) = 1.0 / cos(x);
fn csc(x: f64) = 1.0 / sin(x);
fn cot(x: f64) = 1.0 / tan(x);
fn asec(x: f64) = acos(1.0 / x);
fn acsc(x: f64) = asin(1.0 / x);
fn acot(x: f64) = pi / 2.0 - atan(x);
fn sech(x: f64) = 1.0 / cosh(x);
fn csch(x: f64) = 1.0 / sinh(x);
fn coth(x: f64) = 1.0 / tanh(x);
fn asech(x: f64) = ln((1.0 + sqrt(1.0 - x ** 2.0)) / x);
fn acsch(x: f64) = ln(1.0 / x + sqrt(1.0 / x ** 2.0 + 1.0));
fn acoth(x: f64) = ln((x + 1.0) / (x - 1.0)) / 2.0;
fn{Rs} round Method{"round_ties_even"} :: Deref{f64} -> f64;
fn{Js} round Method{"roundTiesEven"} :: f64 -> f64;
fn magnitude f64 = arg0.abs;
fn{Rs} inverseSqrt (v: f64) = {Method{"recip"} :: f64 -> f64}(sqrt(v));
fn{Js} inverseSqrt (v: f64) = 1.0 / sqrt(v);
fn{Rs} fma Method{"mul_add"} :: (f64, Deref{f64}, Deref{f64}) -> f64;
fn{Js} fma "((a, b, c) => new alan_std.F32(a.val * b.val + c.val))" <- RootBacking :: (f64, f64, f64) -> f64;
fn{Rs} fract Method{"fract"} :: f64 -> f64;
fn{Js} fract "((a) => new alan_std.F64(a.val % 1))" <- RootBacking :: f64 -> f64;

/// Unsigned Integer-related functions
fn{Rs} add Method{"wrapping_add"} :: (u8, Deref{u8}) -> u8;
fn{Js} add Method{"wrappingAdd"} :: (u8, u8) -> u8;
fn{Rs} sub Method{"wrapping_sub"} :: (u8, Deref{u8}) -> u8;
fn{Js} sub Method{"wrappingSub"} :: (u8, u8) -> u8;
fn{Rs} mul Method{"wrapping_mul"} :: (u8, Deref{u8}) -> u8;
fn{Js} mul Method{"wrappingMul"} :: (u8, u8) -> u8;
fn{Rs} div Method{"wrapping_div"} :: (u8, Deref{u8}) -> u8;
fn{Js} div Method{"wrappingDiv"} :: (u8, u8) -> u8;
fn{Rs} mod Method{"wrapping_rem"} :: (u8, Deref{u8}) -> u8;
fn{Js} mod Method{"wrappingMod"} :: (u8, u8) -> u8;
fn{Rs} pow (a: u8, b: u8) = {Method{"wrapping_pow"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (u8, u8) -> u8;
fn{Rs} and Infix{"&"} :: (Deref{u8}, Deref{u8}) -> u8;
fn{Js} and "((a, b) => new alan_std.U8(a & b))" <- RootBacking :: (u8, u8) -> u8;
fn{Rs} or Infix{"|"} :: (Deref{u8}, Deref{u8}) -> u8;
fn{Js} or "((a, b) => new alan_std.U8(a | b))" <- RootBacking :: (u8, u8) -> u8;
fn{Rs} xor Infix{"^"} :: (Deref{u8}, Deref{u8}) -> u8;
fn{Js} xor "((a, b) => new alan_std.U8(a ^ b))" <- RootBacking :: (u8, u8) -> u8;
fn{Rs} not Prefix{"!"} :: Deref{u8} -> u8;
fn{Js} not Method{"not"} :: u8 -> u8;
fn nand (a: u8, b: u8) = !(a & b);
fn nor (a: u8, b: u8) = !(a | b);
fn xnor (a: u8, b: u8) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u8, u8) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u8, u8) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u8, u8) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u8, u8) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u8, u8) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{u8}, Deref{u8}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u8, u8) -> bool;
fn min (a: u8, b: u8) = if(a <= b, a, b);
fn max (a: u8, b: u8) = if(a >= b, a, b);
fn clamp(v: u8, l: u8, h: u8) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: u8, b: u8) = {Method{"wrapping_shl"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (u8, u8) -> u8;
fn{Rs} shr (a: u8, b: u8) = {Method{"wrapping_shr"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (u8, u8) -> u8;
fn{Rs} wrl (a: u8, b: u8) = {Method{"rotate_left"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (u8, u8) -> u8;
fn{Rs} wrr (a: u8, b: u8) = {Method{"rotate_right"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (u8, u8) -> u8;
fn{Rs} clz (a: u8) = {Method{"leading_zeros"} :: u8 -> u32}(a).u8;
fn{Js} clz Method{"clz"} :: u8 -> u8;
fn{Rs} ones (a: u8) = {Method{"count_ones"} :: u8 -> u32}(a).u8;
fn{Js} ones Method{"ones"} :: u8 -> u8;
fn{Rs} ctz (a: u8) = {Method{"trailing_zeros"} :: u8 -> u32}(a).u8;
fn{Js} ctz Method{"ctz"} :: u8 -> u8;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{u8} -> u8;
fn{Js} reverseBits Method{"reverseBits"} :: u8 -> u8;
fn extractBits(v: u8, offset: u8, count: u8) = (v >> offset) & (2.u8 ** count - 1.u8);
fn insertBits(v: u8, newbits: u8, offset: u8, count: u8) =
  ((newbits & (2.u8 ** count - 1.u8)) << offset) + (v & !((2.u8 ** count - 1.u8) << offset));
fn flb (a: u8) {
  let val = a.clz;
  return if(val == 8.u8, 128.u8, 7.u8 - val);
}
fn ftb (a: u8) {
  let val = a.ctz;
  return if(val == 8.u8, 128.u8, val);
}

fn{Rs} add Method{"wrapping_add"} :: (u16, Deref{u16}) -> u16;
fn{Js} add Method{"wrappingAdd"} :: (u16, u16) -> u16;
fn{Rs} sub Method{"wrapping_sub"} :: (u16, Deref{u16}) -> u16;
fn{Js} sub Method{"wrappingSub"} :: (u16, u16) -> u16;
fn{Rs} mul Method{"wrapping_mul"} :: (u16, Deref{u16}) -> u16;
fn{Js} mul Method{"wrappingMul"} :: (u16, u16) -> u16;
fn{Rs} div Method{"wrapping_div"} :: (u16, Deref{u16}) -> u16;
fn{Js} div Method{"wrappingDiv"} :: (u16, u16) -> u16;
fn{Rs} mod Method{"wrapping_rem"} :: (u16, Deref{u16}) -> u16;
fn{Js} mod Method{"wrappingMod"} :: (u16, u16) -> u16;
fn{Rs} pow (a: u16, b: u16) = {Method{"wrapping_pow"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (u16, u16) -> u16;
fn{Rs} and Infix{"&"} :: (Deref{u16}, Deref{u16}) -> u16;
fn{Js} and "((a, b) => new alan_std.U16(a & b))" <- RootBacking :: (u16, u16) -> u16;
fn{Rs} or Infix{"|"} :: (Deref{u16}, Deref{u16}) -> u16;
fn{Js} or "((a, b) => new alan_std.U16(a | b))" <- RootBacking :: (u16, u16) -> u16;
fn{Rs} xor Infix{"^"} :: (Deref{u16}, Deref{u16}) -> u16;
fn{Js} xor "((a, b) => new alan_std.U16(a ^ b))" <- RootBacking :: (u16, u16) -> u16;
fn{Rs} not Prefix{"!"} :: Deref{u16} -> u16;
fn{Js} not Method{"not"} :: u16 -> u16;
fn nand (a: u16, b: u16) = !(a & b);
fn nor (a: u16, b: u16) = !(a | b);
fn xnor (a: u16, b: u16) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u16, u16) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u16, u16) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u16, u16) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u16, u16) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u16, u16) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{u16}, Deref{u16}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u16, u16) -> bool;
fn min (a: u16, b: u16) = if(a <= b, a, b);
fn max (a: u16, b: u16) = if(a >= b, a, b);
fn clamp(v: u16, l: u16, h: u16) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: u16, b: u16) = {Method{"wrapping_shl"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (u16, u16) -> u16;
fn{Rs} shr (a: u16, b: u16) = {Method{"wrapping_shr"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (u16, u16) -> u16;
fn{Rs} wrl (a: u16, b: u16) = {Method{"rotate_left"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (u16, u16) -> u16;
fn{Rs} wrr (a: u16, b: u16) = {Method{"rotate_right"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (u16, u16) -> u16;
fn{Rs} clz (a: u16) = {Method{"leading_zeros"} :: u16 -> u32}(a).u16;
fn{Js} clz Method{"clz"} :: u16 -> u16;
fn{Rs} ones (a: u16) = {Method{"count_ones"} :: u16 -> u32}(a).u16;
fn{Js} ones Method{"ones"} :: u16 -> u16;
fn{Rs} ctz (a: u16) = {Method{"trailing_zeros"} :: u16 -> u32}(a).u16;
fn{Js} ctz Method{"ctz"} :: u16 -> u16;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{u16} -> u16;
fn{Js} reverseBits Method{"reverseBits"} :: u16 -> u16;
fn extractBits(v: u16, offset: u16, count: u16) = (v >> offset) & (2.u16 ** count - 1.u16);
fn insertBits(v: u16, newbits: u16, offset: u16, count: u16) =
  ((newbits & (2.u16 ** count - 1.u16)) << offset) + (v & !((2.u16 ** count - 1.u16) << offset));
fn flb (a: u16) {
  let val = a.clz;
  return if(val == 16.u16, 32_768.u16, 15.u16 - val);
}
fn ftb (a: u16) {
  let val = a.ctz;
  return if(val == 16.u16, 32_768.u16, val);
}

fn{Rs} add Method{"wrapping_add"} :: (u32, Deref{u32}) -> u32;
fn{Js} add Method{"wrappingAdd"} :: (u32, u32) -> u32;
fn{Rs} sub Method{"wrapping_sub"} :: (u32, Deref{u32}) -> u32;
fn{Js} sub Method{"wrappingSub"} :: (u32, u32) -> u32;
fn{Rs} mul Method{"wrapping_mul"} :: (u32, Deref{u32}) -> u32;
fn{Js} mul Method{"wrappingMul"} :: (u32, u32) -> u32;
fn{Rs} div Method{"wrapping_div"} :: (u32, Deref{u32}) -> u32;
fn{Js} div Method{"wrappingDiv"} :: (u32, u32) -> u32;
fn{Rs} mod Method{"wrapping_rem"} :: (u32, Deref{u32}) -> u32;
fn{Js} mod Method{"wrappingMod"} :: (u32, u32) -> u32;
fn{Rs} pow (a: u32, b: u32) = {Method{"wrapping_pow"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (u32, u32) -> u32;
fn{Rs} and Infix{"&"} :: (Deref{u32}, Deref{u32}) -> u32;
fn{Js} and "((a, b) => new alan_std.U32(a & b))" <- RootBacking :: (u32, u32) -> u32;
fn{Rs} or Infix{"|"} :: (Deref{u32}, Deref{u32}) -> u32;
fn{Js} or "((a, b) => new alan_std.U32(a | b))" <- RootBacking :: (u32, u32) -> u32;
fn{Rs} xor Infix{"^"} :: (Deref{u32}, Deref{u32}) -> u32;
fn{Js} xor "((a, b) => new alan_std.U32(a ^ b))" <- RootBacking :: (u32, u32) -> u32;
fn{Rs} not Prefix{"!"} :: Deref{u32} -> u32;
fn{Js} not Method{"not"} :: u32 -> u32;
fn nand (a: u32, b: u32) = !(a & b);
fn nor (a: u32, b: u32) = !(a | b);
fn xnor (a: u32, b: u32) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u32, u32) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u32, u32) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u32, u32) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u32, u32) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u32, u32) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{u32}, Deref{u32}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u32, u32) -> bool;
fn min (a: u32, b: u32) = if(a <= b, a, b);
fn max (a: u32, b: u32) = if(a >= b, a, b);
fn clamp(v: u32, l: u32, h: u32) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: u32, b: u32) = {Method{"wrapping_shl"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (u32, u32) -> u32;
fn{Rs} shr (a: u32, b: u32) = {Method{"wrapping_shr"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (u32, u32) -> u32;
fn{Rs} wrl (a: u32, b: u32) = {Method{"rotate_left"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (u32, u32) -> u32;
fn{Rs} wrr (a: u32, b: u32) = {Method{"rotate_right"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (u32, u32) -> u32;
fn{Rs} clz Method{"leading_zeros"} :: u32 -> u32;
fn{Js} clz Method{"clz"} :: u32 -> u32;
fn{Rs} ones (a: u32) = {Method{"count_ones"} :: u32 -> u32}(a).u32;
fn{Js} ones Method{"ones"} :: u32 -> u32;
fn{Rs} ctz (a: u32) = {Method{"trailing_zeros"} :: u32 -> u32}(a).u32;
fn{Js} ctz Method{"ctz"} :: u32 -> u32;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{u32} -> u32;
fn{Js} reverseBits Method{"reverseBits"} :: u32 -> u32;
fn extractBits(v: u32, offset: u32, count: u32) = (v >> offset) & (2.u32 ** count - 1.u32);
fn insertBits(v: u32, newbits: u32, offset: u32, count: u32) =
  ((newbits & (2.u32 ** count - 1.u32)) << offset) + (v & !((2.u32 ** count - 1.u32) << offset));
fn flb (a: u32) {
  let val = a.clz;
  return if(val == 32.u32, 2_147_483_648.u32, 31.u32 - val);
}
fn ftb (a: u32) {
  let val = a.ctz;
  return if(val == 32.u32, 2_147_483_648.u32, val);
}

fn{Rs} add Method{"wrapping_add"} :: (u64, Deref{u64}) -> u64;
fn{Js} add Method{"wrappingAdd"} :: (u64, u64) -> u64;
fn{Rs} sub Method{"wrapping_sub"} :: (u64, Deref{u64}) -> u64;
fn{Js} sub Method{"wrappingSub"} :: (u64, u64) -> u64;
fn{Rs} mul Method{"wrapping_mul"} :: (u64, Deref{u64}) -> u64;
fn{Js} mul Method{"wrappingMul"} :: (u64, u64) -> u64;
fn{Rs} div Method{"wrapping_div"} :: (u64, Deref{u64}) -> u64;
fn{Js} div Method{"wrappingDiv"} :: (u64, u64) -> u64;
fn{Rs} mod Method{"wrapping_rem"} :: (u64, Deref{u64}) -> u64;
fn{Js} mod Method{"wrappingMod"} :: (u64, u64) -> u64;
fn{Rs} pow (a: u64, b: u64) = {Method{"wrapping_pow"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (u64, u64) -> u64;
fn{Rs} and Infix{"&"} :: (Deref{u64}, Deref{u64}) -> u64;
fn{Js} and "((a, b) => new alan_std.U64(a & b))" <- RootBacking :: (u64, u64) -> u64;
fn{Rs} or Infix{"|"} :: (Deref{u64}, Deref{u64}) -> u64;
fn{Js} or "((a, b) => new alan_std.U64(a | b))" <- RootBacking :: (u64, u64) -> u64;
fn{Rs} xor Infix{"^"} :: (Deref{u64}, Deref{u64}) -> u64;
fn{Js} xor "((a, b) => new alan_std.U64(a ^ b))" <- RootBacking :: (u64, u64) -> u64;
fn{Rs} not Prefix{"!"} :: Deref{u64} -> u64;
fn{Js} not Method{"not"} :: u64 -> u64;
fn nand (a: u64, b: u64) = !(a & b);
fn nor (a: u64, b: u64) = !(a | b);
fn xnor (a: u64, b: u64) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u64, u64) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u64, u64) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u64, u64) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u64, u64) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u64, u64) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{u64}, Deref{u64}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u64, u64) -> bool;
fn min (a: u64, b: u64) = if(a <= b, a, b);
fn max (a: u64, b: u64) = if(a >= b, a, b);
fn clamp(v: u64, l: u64, h: u64) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: u64, b: u64) = {Method{"wrapping_shl"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (u64, u64) -> u64;
fn{Rs} shr (a: u64, b: u64) = {Method{"wrapping_shr"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (u64, u64) -> u64;
fn{Rs} wrl (a: u64, b: u64) = {Method{"rotate_left"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (u64, u64) -> u64;
fn{Rs} wrr (a: u64, b: u64) = {Method{"rotate_right"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (u64, u64) -> u64;
fn{Rs} clz (a: u64) = {Method{"leading_zeros"} :: u64 -> u32}(a).u64;
fn{Js} clz Method{"clz"} :: u64 -> u64;
fn{Rs} ones (a: u64) = {Method{"count_ones"} :: u64 -> u32}(a).u64;
fn{Js} ones Method{"ones"} :: u64 -> u64;
fn{Rs} ctz (a: u64) = {Method{"trailing_zeros"} :: u64 -> u32}(a).u64;
fn{Js} ctz Method{"ctz"} :: u64 -> u64;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{u64} -> u64;
fn{Js} reverseBits Method{"reverseBits"} :: u64 -> u64;
fn extractBits(v: u64, offset: u64, count: u64) = (v >> offset) & (2.u64 ** count - 1.u64);
fn insertBits(v: u64, newbits: u64, offset: u64, count: u64) =
  ((newbits & (2.u64 ** count - 1.u64)) << offset) + (v & !((2.u64 ** count - 1.u64) << offset));
fn flb (a: u64) {
  let val = a.clz;
  return if(val == 64.u64, (-9_223_372_036_854_775_808).asU64, 63.u64 - val);
}
fn ftb (a: u64) {
  let val = a.ctz;
  return if(val == 64.u64, (-9_223_372_036_854_775_808).asU64, val);
}

/// Signed Integer-related functions
fn{Rs} add Method{"wrapping_add"} :: (i8, Deref{i8}) -> i8;
fn{Js} add Method{"wrappingAdd"} :: (i8, i8) -> i8;
fn{Rs} sub Method{"wrapping_sub"} :: (i8, Deref{i8}) -> i8;
fn{Js} sub Method{"wrappingSub"} :: (i8, i8) -> i8;
fn{Rs} mul Method{"wrapping_mul"} :: (i8, Deref{i8}) -> i8;
fn{Js} mul Method{"wrappingMul"} :: (i8, i8) -> i8;
fn{Rs} div Method{"wrapping_div"} :: (i8, Deref{i8}) -> i8;
fn{Js} div Method{"wrappingDiv"} :: (i8, i8) -> i8;
fn{Rs} mod Method{"wrapping_rem"} :: (i8, Deref{i8}) -> i8;
fn{Js} mod Method{"wrappingMod"} :: (i8, i8) -> i8;
fn{Rs} pow (a: i8, b: i8) = {Method{"wrapping_pow"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (i8, i8) -> i8;
fn{Rs} abs Method{"abs"} :: i8 -> i8;
fn{Js} abs "((a) => new alan_std.I8(Math.abs(a.val)))" <- RootBacking :: i8 -> i8;
fn{Rs} neg Prefix{"-"} :: Deref{i8} -> i8;
fn{Js} neg "((a) => new alan_std.I8(-a))" <- RootBacking :: i8 -> i8;
fn{Rs} and Infix{"&"} :: (Deref{i8}, Deref{i8}) -> i8;
fn{Js} and "((a, b) => new alan_std.I8(a & b))" <- RootBacking :: (i8, i8) -> i8;
fn{Rs} or Infix{"|"} :: (Deref{i8}, Deref{i8}) -> i8;
fn{Js} or "((a, b) => new alan_std.I8(a | b))" <- RootBacking :: (i8, i8) -> i8;
fn{Rs} xor Infix{"^"} :: (Deref{i8}, Deref{i8}) -> i8;
fn{Js} xor "((a, b) => new alan_std.I8(a ^ b))" <- RootBacking :: (i8, i8) -> i8;
fn{Rs} not Prefix{"!"} :: Deref{i8} -> i8;
fn{Js} not Method{"not"} :: i8 -> i8;
fn nand (a: i8, b: i8) = !(a & b);
fn nor (a: i8, b: i8) = !(a | b);
fn xnor (a: i8, b: i8) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i8, i8) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i8, i8) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i8, i8) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i8, i8) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i8, i8) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{i8}, Deref{i8}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i8, i8) -> bool;
fn min (a: i8, b: i8) = if(a <= b, a, b);
fn max (a: i8, b: i8) = if(a >= b, a, b);
fn clamp(v: i8, l: i8, h: i8) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: i8, b: i8) = {Method{"wrapping_shl"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (i8, i8) -> i8;
fn{Rs} shr (a: i8, b: i8) = {Method{"wrapping_shr"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (i8, i8) -> i8;
fn{Rs} wrl (a: i8, b: i8) = {Method{"rotate_left"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (i8, i8) -> i8;
fn{Rs} wrr (a: i8, b: i8) = {Method{"rotate_right"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (i8, i8) -> i8;
fn{Rs} clz (a: i8) = {Method{"leading_zeros"} :: i8 -> u32}(a).i8;
fn{Js} clz Method{"clz"} :: i8 -> i8;
fn{Rs} ones (a: i8) = {Method{"count_ones"} :: i8 -> u32}(a).i8;
fn{Js} ones Method{"ones"} :: i8 -> i8;
fn{Rs} ctz (a: i8) = {Method{"trailing_zeros"} :: i8 -> u32}(a).i8;
fn{Js} ctz Method{"ctz"} :: i8 -> i8;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{i8} -> i8;
fn{Js} reverseBits Method{"reverseBits"} :: i8 -> i8;
fn insertBits(v: i8, newbits: i8, offset: i8, count: i8) =
  ((newbits & (2.i8 ** count - 1.i8)) << offset) + (v & !((2.i8 ** count - 1.i8) << offset));
fn flb (a: i8) = 7.i8 - a.clz;
fn ftb (a: i8) {
  let val = a.ctz;
  return if(val == 8.i8, (-1).i8, val);
}

fn{Rs} add Method{"wrapping_add"} :: (i16, Deref{i16}) -> i16;
fn{Js} add Method{"wrappingAdd"} :: (i16, i16) -> i16;
fn{Rs} sub Method{"wrapping_sub"} :: (i16, Deref{i16}) -> i16;
fn{Js} sub Method{"wrappingSub"} :: (i16, i16) -> i16;
fn{Rs} mul Method{"wrapping_mul"} :: (i16, Deref{i16}) -> i16;
fn{Js} mul Method{"wrappingMul"} :: (i16, i16) -> i16;
fn{Rs} div Method{"wrapping_div"} :: (i16, Deref{i16}) -> i16;
fn{Js} div Method{"wrappingDiv"} :: (i16, i16) -> i16;
fn{Rs} mod Method{"wrapping_rem"} :: (i16, Deref{i16}) -> i16;
fn{Js} mod Method{"wrappingMod"} :: (i16, i16) -> i16;
fn{Rs} pow (a: i16, b: i16) = {Method{"wrapping_pow"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (i16, i16) -> i16;
fn{Rs} abs Method{"abs"} :: i16 -> i16;
fn{Js} abs "((a) => new alan_std.I16(Math.abs(a.val)))" <- RootBacking :: i16 -> i16;
fn{Rs} neg Prefix{"-"} :: Deref{i16} -> i16;
fn{Js} neg "((a) => new alan_std.I16(-a))" <- RootBacking :: i16 -> i16;
fn{Rs} and Infix{"&"} :: (Deref{i16}, Deref{i16}) -> i16;
fn{Js} and "((a, b) => new alan_std.I16(a & b))" <- RootBacking :: (i16, i16) -> i16;
fn{Rs} or Infix{"|"} :: (Deref{i16}, Deref{i16}) -> i16;
fn{Js} or "((a, b) => new alan_std.I16(a | b))" <- RootBacking :: (i16, i16) -> i16;
fn{Rs} xor Infix{"^"} :: (Deref{i16}, Deref{i16}) -> i16;
fn{Js} xor "((a, b) => new alan_std.I16(a ^ b))" <- RootBacking :: (i16, i16) -> i16;
fn{Rs} not Prefix{"!"} :: Deref{i16} -> i16;
fn{Js} not Method{"not"} :: i16 -> i16;
fn nand (a: i16, b: i16) = !(a & b);
fn nor (a: i16, b: i16) = !(a | b);
fn xnor (a: i16, b: i16) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i16, i16) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i16, i16) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i16, i16) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i16, i16) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i16, i16) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{i16}, Deref{i16}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i16, i16) -> bool;
fn min (a: i16, b: i16) = if(a <= b, a, b);
fn max (a: i16, b: i16) = if(a >= b, a, b);
fn clamp(v: i16, l: i16, h: i16) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: i16, b: i16) = {Method{"wrapping_shl"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (i16, i16) -> i16;
fn{Rs} shr (a: i16, b: i16) = {Method{"wrapping_shr"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (i16, i16) -> i16;
fn{Rs} wrl (a: i16, b: i16) = {Method{"rotate_left"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (i16, i16) -> i16;
fn{Rs} wrr (a: i16, b: i16) = {Method{"rotate_right"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (i16, i16) -> i16;
fn{Rs} clz (a: i16) = {Method{"leading_zeros"} :: i16 -> u32}(a).i16;
fn{Js} clz Method{"clz"} :: i16 -> i16;
fn{Rs} ones (a: i16) = {Method{"count_ones"} :: i16 -> u32}(a).i16;
fn{Js} ones Method{"ones"} :: i16 -> i16;
fn{Rs} ctz (a: i16) = {Method{"trailing_zeros"} :: i16 -> u32}(a).i16;
fn{Js} ctz Method{"ctz"} :: i16 -> i16;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{i16} -> i16;
fn{Js} reverseBits Method{"reverseBits"} :: i16 -> i16;
fn insertBits(v: i16, newbits: i16, offset: i16, count: i16) =
  ((newbits & (2.i16 ** count - 1.i16)) << offset) + (v & !((2.i16 ** count - 1.i16) << offset));
fn flb (a: i16) = 15.i16 - a.clz;
fn ftb (a: i16) {
  let val = a.ctz;
  return if(val == 16.i16, (-1).i16, val);
}

fn{Rs} add Method{"wrapping_add"} :: (i32, Deref{i32}) -> i32;
fn{Js} add Method{"wrappingAdd"} :: (i32, i32) -> i32;
fn{Rs} sub Method{"wrapping_sub"} :: (i32, Deref{i32}) -> i32;
fn{Js} sub Method{"wrappingSub"} :: (i32, i32) -> i32;
fn{Rs} mul Method{"wrapping_mul"} :: (i32, Deref{i32}) -> i32;
fn{Js} mul Method{"wrappingMul"} :: (i32, i32) -> i32;
fn{Rs} div Method{"wrapping_div"} :: (i32, Deref{i32}) -> i32;
fn{Js} div Method{"wrappingDiv"} :: (i32, i32) -> i32;
fn{Rs} mod Method{"wrapping_rem"} :: (i32, Deref{i32}) -> i32;
fn{Js} mod Method{"wrappingMod"} :: (i32, i32) -> i32;
fn{Rs} pow (a: i32, b: i32) = {Method{"wrapping_pow"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (i32, i32) -> i32;
fn{Rs} abs Method{"abs"} :: i32 -> i32;
fn{Js} abs "((a) => new alan_std.I32(Math.abs(a.val)))" <- RootBacking :: i32 -> i32;
fn{Rs} neg Prefix{"-"} :: Deref{i32} -> i32;
fn{Js} neg "((a) => new alan_std.I32(-a))" <- RootBacking :: i32 -> i32;
fn{Rs} and Infix{"&"} :: (Deref{i32}, Deref{i32}) -> i32;
fn{Js} and "((a, b) => new alan_std.I32(a & b))" <- RootBacking :: (i32, i32) -> i32;
fn{Rs} or Infix{"|"} :: (Deref{i32}, Deref{i32}) -> i32;
fn{Js} or "((a, b) => new alan_std.I32(a | b))" <- RootBacking :: (i32, i32) -> i32;
fn{Rs} xor Infix{"^"} :: (Deref{i32}, Deref{i32}) -> i32;
fn{Js} xor "((a, b) => new alan_std.I32(a ^ b))" <- RootBacking :: (i32, i32) -> i32;
fn{Rs} not Prefix{"!"} :: Deref{i32} -> i32;
fn{Js} not Method{"not"} :: i32 -> i32;
fn nand (a: i32, b: i32) = !(a & b);
fn nor (a: i32, b: i32) = !(a | b);
fn xnor (a: i32, b: i32) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i32, i32) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i32, i32) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i32, i32) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i32, i32) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" :: (i32, i32) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{i32}, Deref{i32}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" :: (i32, i32) -> bool;
fn min (a: i32, b: i32) = if(a <= b, a, b);
fn max (a: i32, b: i32) = if(a >= b, a, b);
fn clamp(v: i32, l: i32, h: i32) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: i32, b: i32) = {Method{"wrapping_shl"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (i32, i32) -> i32;
fn{Rs} shr (a: i32, b: i32) = {Method{"wrapping_shr"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (i32, i32) -> i32;
fn{Rs} wrl (a: i32, b: i32) = {Method{"rotate_left"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (i32, i32) -> i32;
fn{Rs} wrr (a: i32, b: i32) = {Method{"rotate_right"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (i32, i32) -> i32;
fn{Rs} clz (a: i32) = {Method{"leading_zeros"} :: i32 -> u32}(a).i32;
fn{Js} clz Method{"clz"} :: i32 -> i32;
fn{Rs} ones (a: i32) = {Method{"count_ones"} :: i32 -> u32}(a).i32;
fn{Js} ones Method{"ones"} :: i32 -> i32;
fn{Rs} ctz (a: i32) = {Method{"trailing_zeros"} :: i32 -> u32}(a).i32;
fn{Js} ctz Method{"ctz"} :: i32 -> i32;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{i32} -> i32;
fn{Js} reverseBits Method{"reverseBits"} :: i32 -> i32;
fn insertBits(v: i32, newbits: i32, offset: i32, count: i32) =
  ((newbits & (2.i32 ** count - 1.i32)) << offset) + (v & !((2.i32 ** count - 1.i32) << offset));
fn flb (a: i32) = 31.i32 - a.clz;
fn ftb (a: i32) {
  let val = a.ctz;
  return if(val == 32.i32, (-1).i32, val);
}

fn{Rs} add Method{"wrapping_add"} :: (i64, Deref{i64}) -> i64;
fn{Js} add Method{"wrappingAdd"} :: (i64, i64) -> i64;
fn{Rs} sub Method{"wrapping_sub"} :: (i64, Deref{i64}) -> i64;
fn{Js} sub Method{"wrappingSub"} :: (i64, i64) -> i64;
fn{Rs} mul Method{"wrapping_mul"} :: (i64, Deref{i64}) -> i64;
fn{Js} mul Method{"wrappingMul"} :: (i64, i64) -> i64;
fn{Rs} div Method{"wrapping_div"} :: (i64, Deref{i64}) -> i64;
fn{Js} div Method{"wrappingDiv"} :: (i64, i64) -> i64;
fn{Rs} mod Method{"wrapping_rem"} :: (i64, Deref{i64}) -> i64;
fn{Js} mod Method{"wrappingMod"} :: (i64, i64) -> i64;
fn{Rs} pow (a: i64, b: i64) = {Method{"wrapping_pow"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
fn{Js} pow Method{"wrappingPow"} :: (i64, i64) -> i64;
fn{Rs} abs Method{"abs"} :: i64 -> i64;
fn{Js} abs "((a) => new alan_std.I64(a < 0n ? -a : a))" <- RootBacking :: i64 -> i64;
fn{Rs} neg Prefix{"-"} :: Deref{i64} -> i64;
fn{Js} neg "((a) => new alan_std.I64(-a))" <- RootBacking :: i64 -> i64;
fn{Rs} and Infix{"&"} :: (Deref{i64}, Deref{i64}) -> i64;
fn{Js} and "((a, b) => new alan_std.I64(a & b))" <- RootBacking :: (i64, i64) -> i64;
fn{Rs} or Infix{"|"} :: (Deref{i64}, Deref{i64}) -> i64;
fn{Js} or "((a, b) => new alan_std.I64(a | b))" <- RootBacking :: (i64, i64) -> i64;
fn{Rs} xor Infix{"^"} :: (Deref{i64}, Deref{i64}) -> i64;
fn{Js} xor "((a, b) => new alan_std.I64(a ^ b))" <- RootBacking :: (i64, i64) -> i64;
fn{Rs} not Prefix{"!"} :: Deref{i64} -> i64;
fn{Js} not Method{"not"} :: i64 -> i64;
fn nand (a: i64, b: i64) = !(a & b);
fn nor (a: i64, b: i64) = !(a | b);
fn xnor (a: i64, b: i64) = !(a ^ b);
fn{Rs} eq Infix{"=="} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i64, i64) -> bool;
fn{Rs} neq Infix{"!="} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i64, i64) -> bool;
fn{Rs} lt Infix{"<"} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i64, i64) -> bool;
fn{Rs} lte Infix{"<="} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i64, i64) -> bool;
fn{Rs} gt Infix{">"} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i64, i64) -> bool;
fn{Rs} gte Infix{">="} :: (Deref{i64}, Deref{i64}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i64, i64) -> bool;
fn min (a: i64, b: i64) = if(a <= b, a, b);
fn max (a: i64, b: i64) = if(a >= b, a, b);
fn clamp(v: i64, l: i64, h: i64) = if(v <= l, l, if(v >= h, h, v));
fn{Rs} shl (a: i64, b: i64) = {Method{"wrapping_shl"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
fn{Js} shl Method{"wrappingShl"} :: (i64, i64) -> i64;
fn{Rs} shr (a: i64, b: i64) = {Method{"wrapping_shr"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
fn{Js} shr Method{"wrappingShr"} :: (i64, i64) -> i64;
fn{Rs} wrl (a: i64, b: i64) = {Method{"rotate_left"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
fn{Js} wrl Method{"rotateLeft"} :: (i64, i64) -> i64;
fn{Rs} wrr (a: i64, b: i64) = {Method{"rotate_right"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
fn{Js} wrr Method{"rotateRight"} :: (i64, i64) -> i64;
fn{Rs} clz (a: i64) = {Method{"leading_zeros"} :: i64 -> u32}(a).i64;
fn{Js} clz Method{"clz"} :: i64 -> i64;
fn{Rs} ones (a: i64) = {Method{"count_ones"} :: i64 -> u32}(a).i64;
fn{Js} ones Method{"ones"} :: i64 -> i64;
fn{Rs} ctz (a: i64) = {Method{"trailing_zeros"} :: i64 -> u32}(a).i64;
fn{Js} ctz Method{"ctz"} :: i64 -> i64;
fn{Rs} reverseBits Method{"reverse_bits"} :: Deref{i64} -> i64;
fn{Js} reverseBits Method{"reverseBits"} :: i64 -> i64;
fn insertBits(v: i64, newbits: i64, offset: i64, count: i64) =
  ((newbits & (2 ** count - 1)) << offset) + (v & !((2 ** count - 1) << offset));
fn flb (a: i64) = 63.i64 - a.clz;
fn ftb (a: i64) {
  let val = a.ctz;
  return if(val == 64.i64, (-1).i64, val);
}

/// String-related functions
fn{Rs} string "format!" :: ("{}", f32) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: f32 -> string;
fn{Rs} string "format!" :: ("{}", f64) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: f64 -> string;
fn{Rs} string "format!" :: ("{}", u8) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: u8 -> string;
fn{Rs} string "format!" :: ("{}", u16) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: u16 -> string;
fn{Rs} string "format!" :: ("{}", u32) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: u32 -> string;
fn{Rs} string "format!" :: ("{}", u64) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: u64 -> string;
fn{Rs} string "format!" :: ("{}", i8) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: i8 -> string;
fn{Rs} string "format!" :: ("{}", i16) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: i16 -> string;
fn{Rs} string "format!" :: ("{}", i32) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: i32 -> string;
fn{Rs} string "format!" :: ("{}", i64) -> string;
fn{Js} string "new alan_std.Str" <- RootBacking :: i64 -> string;
// TODO: Until better printing is ready? Or perhaps this is a better fit for Alan
fn{Rs} string (f: f32, p: i64) = {"format!" :: ("{0:.1$}", f32, Deref{Binds{"usize"}}) -> string}(
  f,
  {Cast{"usize"} :: Deref{i64} -> Binds{"usize"}}(p));
fn{Js} string "((v, p) => new alan_std.Str(v.valueOf().toFixed(Number(p))))" <- RootBacking :: (f32, i64) -> string;
fn{Rs} string (f: f64, p: i64) = {"format!" :: ("{0:.1$}", f64, Deref{Binds{"usize"}}) -> string}(
  f,
  {Cast{"usize"} :: Deref{i64} -> Binds{"usize"}}(p));
fn{Js} string "((v, p) => new alan_std.Str(v.valueOf().toFixed(Number(p))))" <- RootBacking :: (f64, i64) -> string;
fn string(b: bool) = if(b, "true", "false");
fn string(s: string) = s;
fn{Rs} concat "format!" :: ("{}{}", string, string) -> string;
fn{Js} concat "((a, b) => new alan_std.Str(a.val + b.val))" <- RootBacking :: (string, string) -> string;
fn{Rs} repeat (a: string, n: i64) = {Method{"repeat"} :: (string, Deref{Binds{"usize"}}) -> string}(
  a,
  {Cast{"usize"} :: Deref{i64} -> Binds{"usize"}}(n));
fn{Js} repeat "((s, n) => new alan_std.Str(s.val.repeat(Number(n.val))))" <- RootBacking :: (string, i64) -> string;
fn{Rs} replace Method{"replace"} :: (string, string, string) -> string;
fn{Js} replace "((s, o, n) => new alan_std.Str(s.valueOf().replaceAll(o.valueOf(), n.valueOf())))" :: (string, string, string) -> string;
fn{Rs} split "alan_std::splitstring" <- RootBacking :: (string, string) -> string[];
fn{Js} split "((a, b) => a.val.split(b.val).map(v => new alan_std.Str(v)))" <- RootBacking :: (string, string) -> string[];
fn{Rs} len (s: string) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Array{Binds{"char"}} -> Binds{"usize"}}(
    {Method{"collect::<Vec<char>>"} :: Own{Binds{"std::str::Chars"}} -> Array{Binds{"char"}}}(
      {Method{"chars"} :: string -> Binds{"std::str::Chars"}}(s))));
fn{Js} len "((s) => new alan_std.I64(s.val.length))" :: string -> i64;
fn{Rs} get "alan_std::getstring" <- RootBacking :: (string, i64) -> string!;
fn{Js} get "((s, i) => { let idx = Number(i.val); if (idx >= 0 && idx < s.val.length) { return new alan_std.Str(s.val[idx]); } else { return new alan_std.AlanError(new alan_std.Str(`Index ${idx} is out-of-bounds for a string length of ${s.val.length}`)); } })" :: (string, i64) -> string!;
fn{Rs} trim Method{"trim"} :: string -> string;
fn{Js} trim "((s) => new alan_std.Str(s.val.trim()))" <- RootBacking :: string -> string;
fn{Rs} index "alan_std::indexstring" <- RootBacking :: (string, string) -> i64!;
fn{Js} index "((a, b) => { let idx = a.val.indexOf(b.val); if (idx < 0) { return new alan_std.AlanError(new alan_std.Str(`Could not find ${b.val} in ${a.val}`)); } else { return new alan_std.I64(idx); } })" <- RootBacking :: (string, string) -> i64!;
fn{Rs} eq (a: string, b: string) = {Infix{"=="} :: (string, string) -> bool}({Method{"as_str"} :: string -> string}(a), {Method{"as_str"} :: string -> string}(b));
fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (string, string) -> bool;
fn{Rs} neq Infix{"!="} :: (Own{string}, Own{string}) -> bool;
fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (string, string) -> bool;
fn{Rs} lt Infix{"<"} :: (Own{string}, Own{string}) -> bool;
fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (string, string) -> bool;
fn{Rs} lte Infix{"<="} :: (Own{string}, Own{string}) -> bool;
fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (string, string) -> bool;
fn{Rs} gt Infix{">"} :: (Own{string}, Own{string}) -> bool;
fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (string, string) -> bool;
fn{Rs} gte Infix{">="} :: (Own{string}, Own{string}) -> bool;
fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (string, string) -> bool;
fn min (a: string, b: string) = if(a <= b, fn () = a.clone(), fn () = b.clone());
fn max (a: string, b: string) = if(a >= b, fn () = a.clone(), fn () = b.clone());
fn{Rs} join Method{"join"} :: (string[], string) -> string;
fn{Js} join "((a, b) => new alan_std.Str([...a.map(v => v.val)].join(b.val)))" <- RootBacking :: (string[], string) -> string;
fn{Rs} join{S}(a: string[S], s: string) = {Method{"join"} :: (string[S], string) -> string}(a, s);
fn{Js} join{S}(a: string[S], s: string) = {"((a, s) => new alan_std.Str(a.map(v => v.val).join(s.val)))" <- RootBacking :: (string[S], string) -> string}(a, s);

/// Array-related functions
fn{Rs} len{T} (a: T[]) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: T[] -> Binds{"usize"}}(a));
fn{Js} len{T} (a: T[]) = {Property{"length"} :: T[] -> i32}(a).i64;
fn{Rs} get{T} "alan_std::getarray" <- RootBacking :: (T[], i64) -> T?;
fn{Js} get{T} (a: T[], i: i64) = if((i >= 0) & (i < a.len),
  fn = {Method{"at"} :: (T[], i32) -> T}(a, i.i32));
fn get{T} (a: Maybe{T[]}, i: i64) = if(a.exists, fn = (a!!).get(i), fn = {T?}());
fn push{T} (a: Mut{T[]}, v: T) = {Method{"push"} :: (Mut{T[]}, Own{T})}(a, v);
fn{Rs} pop{T} (a: Mut{T[]}) -> T? = {Method{"pop"} :: Mut{T[]} -> T?}(a);
fn{Js} pop{T} (a: Mut{T[]}) -> T? = {"((a) => a || null)" :: T? -> T?}({Method{"pop"} :: Mut{T[]} -> T?}(a));
fn{Rs} map{T, U} "alan_std::map_onearg" <- RootBacking :: (T[], T -> U) -> U[];
fn{Js} map{T, U} "(async (a, f) => { let out = []; for (let v of a) { out.push(await f(v)); } return out; })" :: (T[], f: T -> U) -> U[];
fn{Rs} map{T, U} "alan_std::map_twoarg" <- RootBacking :: (T[], (T, i64) -> U) -> U[];
fn{Js} map{T, U} "(async (a, f) => { let out = []; for (let i = 0; i < a.length; i++) { out.push(await f(a[i], new alan_std.I64(i))); } return out; })" <- RootBacking :: (T[], f: (T, i64) -> U) -> U[];
fn{Rs} parmap{T, U} "alan_std::parmap_onearg" <- RootBacking :: (T[], T -> U) -> U[];
fn{Rs} filter{T} "alan_std::filter_onearg" <- RootBacking :: (T[], T -> bool) -> T[];
fn{Js} filter{T} (a: T[], f: T -> bool) = {"(async (a, f) => { let out = []; for (let v of a) { if ((await f(v)).val) { out.push(v); } } return out; })" :: (T[], T -> bool) -> T[]}(a, f);
fn{Rs} filter{T} "alan_std::filter_twoarg" <- RootBacking :: (T[], (T, i64) -> bool) -> T[];
fn{Js} filter{T} (a: T[], f: (T, i64) -> bool) = {"(async (a, f) => { let out = []; for (let i = 0; i < a.length; i++) { if ((await f(a[i], new alan_std.I64(i))).val) { out.push(a[i]); } } return out; })" <- RootBacking :: (T[], (T, i64) -> bool) -> T[]}(a, f);
fn{Rs} reduce{T} "alan_std::reduce_sametype" <- RootBacking :: (T[], (T, T) -> T) -> T?;
fn{Js} reduce{T} "(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[], (T, T) -> T) -> T?;
fn{Rs} reduce{T} "alan_std::reduce_sametype_idx" <- RootBacking :: (T[], (T, T, i64) -> T) -> T?;
fn{Js} reduce{T} "(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i], new alan_std.I64(i)); } return out; })" <- RootBacking :: (T[], (T, T, i64) -> T) -> T?;
fn{Rs} reduce{T, U} "alan_std::reduce_difftype" <- RootBacking :: (T[], U, (U, T) -> U) -> U;
fn{Js} reduce{T, U} "(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[], U, (U, T) -> U) -> U;
fn{Rs} reduce{T, U} "alan_std::reduce_difftype_idx" <- RootBacking :: (T[], U, (U, T, i64) -> U) -> U;
fn{Js} reduce{T, U} "(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i], new alan_std.I64(i)); } return out; })" <- RootBacking :: (T[], U, (U, T, i64) -> U) -> U;
fn{Rs} concat{T} "alan_std::concat" <- RootBacking :: (T[], T[]) -> T[];
fn{Js} concat{T} (a: T[], b: T[]) -> T[] = {Method{"concat"} :: (T[], T[]) -> T[]}(a, b);
fn{Rs} append{T} "alan_std::append" <- RootBacking :: (Mut{T[]}, T[]);
fn{Js} append{T} "((a, b) => { for (let v in b) { a.push(v); } })" :: (Mut{T[]}, T[]);
fn{Rs} filled{T} "alan_std::filled" <- RootBacking :: (T, i64) -> T[];
fn{Js} filled{T} "((v, c) => { let out = []; for (let i = 0n; i < c; i++) { out.push(v); } return out; })" :: (T, i64) -> T[];
fn{Rs} has{T} (a: T[], v: T) = {Method{"contains"} :: (T[], T) -> bool}(a, v);
fn{Js} has{T} (a: T[], v: T) = a.reduce(false, fn (out: bool, t: T) = if(out, true, t == v));
fn{Rs} has{T} "alan_std::hasfnarray" <- RootBacking :: (T[], T -> bool) -> bool;
fn{Js} has{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return new alan_std.Bool(true); } } return new alan_std.Bool(false); })" <- RootBacking :: (T[], T -> bool) -> bool}(a, f);
fn{Rs} find{T} "alan_std::findarray" <- RootBacking :: (T[], T -> bool) -> T?;
fn{Js} find{T} (a: T[], f: T -> bool) -> T? = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return v; } } return null; })" :: (T[], T -> bool) -> T?}(a, f);
// TODO: The `if` syntactic sugar will make these `if` calls much nicer
fn index{T}(a: Array{T}, v: T) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(val == v, Maybe(idx), out)));
fn index{T}(a: Array{T}, f: T -> bool) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(f(val), idx)));
fn index{T}(a: Array{T}, f: (T, i64) -> bool) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(f(val, idx), idx)));
fn{Rs} every{T} "alan_std::everyarray" <- RootBacking :: (T[], T -> bool) -> bool;
fn{Js} every{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if (!(await f(v)).val) { return new alan_std.Bool(false); } } return new alan_std.Bool(true); })" <- RootBacking :: (T[], T -> bool) -> bool}(a, f);
fn{Rs} some{T} "alan_std::somearray" <- RootBacking :: (T[], T -> bool) -> bool;
fn{Js} some{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return new alan_std.Bool(true); } } return new alan_std.Bool(false); })" <- RootBacking :: (T[], T -> bool) -> bool}(a, f);
fn{Rs} repeat{T} "alan_std::repeatarray" <- RootBacking :: (T[], i64) -> T[];
fn{Js} repeat{T} (a: T[], c: i64) = {"((a, c) => { let out = []; for (let i = 0n; i < c; i++) { out.push(...a); } return out; })" :: (T[], i64) -> T[]}(a, c);
fn{Rs} store{T} "alan_std::storearray" <- RootBacking :: (Mut{T[]}, i64, T) -> void!;
fn{Js} store{T} (a: T[], i: i64, v: T) = {"((a, i, v) => { if (i < 0n || i > BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is greater than the length of the array`)); } else { a.splice(Number(i), 0, v); } })" :: (T[], i64, T) -> void!}(a, i, v);
fn{Rs} delete{T} "alan_std::deletearray" <- RootBacking :: (Mut{T[]}, i64) -> T!;
fn{Js} delete{T} (a: T[], i: i64) = {"((a, i) => { if (i < 0n || i >= BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is beyond the bounds of the array`)); } else { return a.splice(Number(i), 1)[0]; } })" :: (T[], i64) -> T!}(a, i);
fn{Rs} last{T} (v: T[]) = {Method{"cloned"} :: T? -> T?}({Method{"last"} :: T[] -> T?}(v));
fn{Js} last{T} (v: T[]) = {Method{"at"} :: (T[], -1) -> T?}(v);
fn{Rs} swap{T} "alan_std::swaparray" <- RootBacking :: (Mut{T[]}, i64, i64) -> void!;
fn{Js} swap{T} "alan_std.swap" <- RootBacking :: (T[], i64, i64) -> void!;
fn{Rs} sort{T} "alan_std::sortarray" <- RootBacking :: (Mut{T[]}, (T, T) -> i8) -> void;
fn{Js} sort{T} "alan_std.sort" <- RootBacking :: (Mut{T[]}, (T, T) -> i8) -> void;
fn sort{T} (arr: Mut{T[]}) = sort(arr, fn (a: T, b: T) = if(a == b, 0.i8, if(a < b, -1.i8, 1.i8)));
fn magnitude (arr: f32[]) = (arr.map(fn (v: f32) = v ** 2.0.f32).reduce(add) ?? 0.0.f32).sqrt;
fn magnitude (arr: f64[]) = (arr.map(fn (v: f64) = v ** 2.0).reduce(add) ?? 0.0).sqrt;
fn normalize (arr: f32[]) {
  let mag = magnitude(arr);
  let arr1 = arr.clone; // TODO: Needed for Rust codegen, but should not
  return if(mag == 0.0.f32, fn = arr1.clone, fn = arr.map(fn (v: f32) = v / mag));
}
fn normalize (arr: f64[]) {
  let mag = magnitude(arr);
  let arr1 = arr.clone; // TODO: Needed for Rust codegen, but should not
  return if(mag == 0.0, fn = arr1.clone, fn = arr.map(fn (v: f64) = v / mag));
}
fn inverseSqrt(arr: f32[]) = arr.map(inverseSqrt);
fn inverseSqrt(arr: f64[]) = arr.map(inverseSqrt);
fn fma(a: f32[], b: f32[], c: f32[]) -> Fallible{f32[]} {
  return if(a.len == b.len && b.len == c.len, fn {
    // TODO: Figure out why I need to explicitly wrap this in `Fallible{f32[]}(...)` instead of just
    // using the `!` postfix operator
    return Fallible{f32[]}(a.map(fn (v: f32, i: i64) = v.fma(b[i]!!, c[i]!!)));
  }, fn {
    return Error{f32[]}("Fused multiply-add on arrays requires equal-length arrays");
  });
}
fn fma(a: f64[], b: f64[], c: f64[]) -> Fallible{f64[]} {
  return if(a.len == b.len && b.len == c.len, fn {
    return Fallible{f64[]}(a.map(fn (v: f64, i: i64) = v.fma(b[i]!!, c[i]!!)));
  }, fn {
    return Error{f64[]}("Fused multiply-add on arrays requires equal-length arrays");
  });
}
fn fract(a: f32[]) = a.map(fract);
fn fract(a: f64[]) = a.map(fract);

/// Buffer-related functions
fn{Rs} get{T, S} "alan_std::getbuffer" <- RootBacking :: (T[S], i64) -> T?;
fn len{T, S}(T[S]) = {S}();
fn{Js} get{T, S} "((b, i) => { let idx = Number(i.val); if (idx >= 0 && idx < b.length) { return b[idx]; } else { return null; } })" :: (T[S], i64) -> T?;
fn{Rs} map{T, S, U} "alan_std::mapbuffer_onearg" <- RootBacking :: (T[S], T -> U) -> (U[S]);
fn{Js} map{T, S, U} (a: T[S], f: T -> U) = {"Promise.all" :: Buffer{U, S} -> Buffer{U, S}}({Method{"map"} :: (Buffer{T, S}, T -> U) -> Buffer{U, S}}(a, f));
fn{Rs} map{T, S, U} "alan_std::mapbuffer_twoarg" <- RootBacking :: (Buffer{T, S}, (T, i64) -> U) -> Buffer{U, S};
fn{Js} map{T, S, U} (a: T[S], f: (T, i64) -> U) = {"Promise.all" :: Buffer{U, S} -> Buffer{U, S}}({Method{"map"} :: (Buffer{T, S}, (T, i32) -> U) -> Buffer{U, S}}(a, fn (v: T, i: i32) = f(v, i.i64)));
fn{Rs} reduce{T, S} "alan_std::reducebuffer_sametype" <- RootBacking :: (T[S], (T, T) -> T) -> T?;
fn{Js} reduce{T, S} (a: T[S], f: (T, T) -> T) = {"(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[S], (T, T) -> T) -> T?}(a, f);
fn{Rs} reduce{T, S, U} "alan_std::reducebuffer_difftype" <- RootBacking :: (T[S], U, (U, T) -> U) -> U;
fn{Js} reduce{T, S, U} (a: T[S], i: U, f: (U, T) -> U) = {"(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[S], U, (U, T) -> U) -> U}(a, i, f);
fn{Rs} has{T, S} "alan_std::hasbuffer" <- RootBacking :: (T[S], T) -> bool;
fn{Js} has{T, S} (a: T[S], v: T) = a.reduce(false, fn (out: bool, t: T) = if(out, true, t == v));
fn{Rs} has{T, S} "alan_std::hasfnbuffer" <- RootBacking :: (T[S], T -> bool) -> bool;
fn{Js} has{T, S} (a: T[S], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return new alan_std.Bool(true); } } return new alan_std.Bool(false); })" <- RootBacking :: (T[S], T -> bool) -> bool}(a, f);
fn{Rs} find{T, S} "alan_std::findbuffer" <- RootBacking :: (T[S], T -> bool) -> T?;
fn{Js} find{T, S} (a: T[S], f: T -> bool) -> T? = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return v; } } return null; })" :: (T[S], T -> bool) -> T?}(a, f);
fn{Rs} every{T, S} "alan_std::everybuffer" <- RootBacking :: (T[S], T -> bool) -> bool;
fn{Js} every{T, S} (a: T[S], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if (!(await f(v)).val) { return new alan_std.Bool(false); } } return new alan_std.Bool(true); })" <- RootBacking :: (T[S], T -> bool) -> bool}(a, f);
fn{Rs} concatInner{T, S, N} "alan_std::concatbuffer" <- RootBacking :: (Mut{T[S + N]}, T[S], T[N]);
fn{Js} concatInner{T, S, N} "((o, a, b) => { for (let i = 0; i < a.length; i++) { o[i] = a[i]; } for (let i = 0; i < b.length; i++) { o[i+a.length] = b[i]; } })" :: (Mut{T[S + N]}, T[S], T[N]);
fn concat{T, S, N}(a: T[S], b: T[N]) {
  // I can't bind directly into Rust because Rust can't add const integer type parameters together.
  // It's *theoretically* possible to generate a new Rust function in each case with the required
  // sizes, but it will be really difficult, so I'm implementing this for now with the intent to
  // eventually replace it.
  let o = {T[S + N]}(a.0);
  concatInner(o, a, b);
  return o;
}
fn{Rs} repeat{T, S} "alan_std::repeatbuffertoarray" <- RootBacking :: (T[S], i64) -> T[];
fn{Js} repeat{T, S} (a: T[S], c: i64) = {"((a, c) => { let out = []; for (let i = 0n; i < c; i++) { out.push(...a); } return out; })" :: (T[S], i64) -> T[]}(a, c);
fn{Rs} store{T, S} "alan_std::storebuffer" <- RootBacking :: (Mut{T[S]}, i64, T) -> T!;
fn{Js} store{T, S} (a: T[S], i: i64, v: T) = {"((a, i, v) => { if (i < 0n || i > BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is greater than the length of the array`)); } else { let out = a[Number(i)]; a[Number(i)] = v; return out; } })" :: (T[S], i64, T) -> T!}(a, i, v);
fn{Rs} cross "alan_std::cross_f32" <- RootBacking :: (Buffer{f32, 3}, Buffer{f32, 3}) -> Buffer{f32, 3};
fn{Rs} cross "alan_std::cross_f64" <- RootBacking :: (Buffer{f64, 3}, Buffer{f64, 3}) -> Buffer{f64, 3};
fn{Js} cross{T} "alan_std.cross" <- RootBacking :: (Buffer{T, 3}, Buffer{T, 3}) -> Buffer{T, 3};
fn{Js} cross(a: Buffer{f32, 3}, b: Buffer{f32, 3}) = cross{f32}(a, b);
fn{Js} cross(a: Buffer{f64, 3}, b: Buffer{f64, 3}) = cross{f64}(a, b);
fn dot{I}(a: Buffer{I, 2}, b: Buffer{I, 2}) = a.0 * b.0 + a.1 * b.1;
fn dot{I}(a: Buffer{I, 3}, b: Buffer{I, 3}) = a.0 * b.0 + a.1 * b.1 + a.2 * b.2;
fn dot{I}(a: Buffer{I, 4}, b: Buffer{I, 4}) = a.0 * b.0 + a.1 * b.1 + a.2 * b.2 + a.3 * b.3;
fn{Rs} swap{T, S} "alan_std::swapbuffer" <- RootBacking :: (Mut{Buffer{T, S}}, i64, i64) -> void!;
fn{Js} swap{T, S} "alan_std.swap" <- RootBacking :: (Buffer{T, S}, i64, i64) -> void!;
fn{Rs} sort{T, S} "alan_std::sortbuffer" <- RootBacking :: (Mut{Buffer{T, S}}, (T, T) -> i8) -> void;
fn{Js} sort{T, S} "alan_std.sort" <- RootBacking :: (Mut{Buffer{T, S}}, (T, T) -> i8) -> void;
fn sort{T, S} (arr: Mut{Buffer{T, S}}) = sort(arr, fn (a: T, b: T) = if(a == b, 0.i8, if(a < b, -1.i8, 1.i8)));
fn magnitude{S} (buf: f32[S]) = (buf.map(fn (v: f32) = v ** 2.0.f32).reduce(add) ?? 0.0.f32).sqrt;
fn magnitude{S} (buf: f64[S]) = (buf.map(fn (v: f64) = v ** 2.0).reduce(add) ?? 0.0).sqrt;
fn normalize{S} (arr: f32[S]) {
  let mag = magnitude(arr);
  let arr1 = arr.clone; // TODO: Needed for Rust codegen, but should not
  return if(mag == 0.0.f32, fn = arr1.clone, fn = arr.map(fn (v: f32) = v / mag));
}
fn normalize{S} (arr: f64[S]) {
  let mag = magnitude(arr);
  let arr1 = arr.clone; // TODO: Needed for Rust codegen, but should not
  return if(mag == 0.0, fn = arr1.clone, fn = arr.map(fn (v: f64) = v / mag));
}
fn inverseSqrt{S}(buf: f32[S]) = buf.map(inverseSqrt);
fn inverseSqrt{S}(buf: f64[S]) = buf.map(inverseSqrt);
fn fma{S}(a: Buffer{f32, S}, b: Buffer{f32, S}, c: Buffer{f32, S}) = a.map(fn (v: f32, i: i64) = v.fma(b[i]!!, c[i]!!));
fn fma{S}(a: Buffer{f64, S}, b: Buffer{f64, S}, c: Buffer{f64, S}) = a.map(fn (v: f64, i: i64) = v.fma(b[i]!!, c[i]!!));
fn fract{S}(a: Buffer{f32, S}) = a.map(fract);
fn fract{S}(a: Buffer{f64, S}) = a.map(fract);
fn determinant{T}(m: Buffer{T, 4}) = m.0 * m.3 - m.2 * m.1;
fn determinant{T}(m: Buffer{T, 9}) =
  m.0 * m.4 * m.8 +
  m.3 * m.7 * m.2 +
  m.6 * m.1 * m.5 -
  m.6 * m.4 * m.2 -
  m.3 * m.1 * m.8 -
  m.0 * m.7 * m.5;
fn determinant{T}(m: Buffer{T, 16}) =
  m.0 * m.5 * m.10 * m.15 +
  m.4 * m.9 * m.14 * m.3 +
  m.8 * m.13 * m.2 * m.7 +
  m.12 * m.1 * m.6 * m.11 -
  m.12 * m.9 * m.6 * m.3 -
  m.8 * m.5 * m.2 * m.15 -
  m.4 * m.1 * m.14 * m.11 -
  m.0 * m.13 * m.10 * m.7;

/// Dictionary-related functions
fn{Rs} Dict{K, V} "alan_std::OrderedHashMap::new" <- RootBacking :: () -> Dict{K, V};
fn{Js} Dict{K, V} "new Map" :: () -> Dict{K, V};
fn Dict{K, V}(k: K, v: V) {
  let out = Dict{K, V}();
  out.store(k, v);
  return out;
}
fn Dict{K, V}(a: Array{(K, V)}) = a.reduce(Dict{K, V}(), fn (d: Dict{K, V}, v: (K, V)) {
  d.store(v.0, v.1);
  return d;
});
fn{Rs} has{K, V} (d: Dict{K, V}, k: K) = {Method{"contains_key"} :: (Dict{K, V}, K) -> bool}(d, k);
fn{Js} has{K, V} (d: Dict{K, V}, k: K) = {"((d, k) => new alan_std.Bool(d.has(k?.val ?? k)))" <- RootBacking :: (Dict{K, V}, K) -> bool}(d, k);
fn{Rs} get{K, V} "alan_std::getdict" <- RootBacking :: (Dict{K, V}, K) -> V?;
fn{Js} get{K, V} (d: Dict{K, V}, k: K) = {"((d, k) => d.get(k?.val ?? k) || null)" :: (Dict{K, V}, K) -> V?}(d, k);
fn{Rs} store{K, V} (d: Mut{Dict{K, V}}, k: K, v: V) {
  {Method{"insert"} :: (Mut{Dict{K, V}}, Own{K}, Own{V}) -> V?}(d, k, v);
}
fn{Js} store{K, V} (d: Mut{Dict{K, V}}, k: K, v: V) {
  let out = d[k];
  {"((s, k, v) => s.set(k?.val ?? k, v))" :: (Dict{K, V}, K, V) -> void}(d, k, v);
  return out;
}
fn{Rs} len{K, V} (d: Dict{K, V}) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Dict{K, V} -> Binds{"usize"}}(d));
fn{Js} len{K, V} (d: Dict{K, V}) = {Property{"size"} :: Dict{K, V} -> i32}(d).i64;
fn{Rs} keys{K, V} "alan_std::keysdict" <- RootBacking :: Dict{K, V} -> K[];
fn{Js} keys{K, V} (d: Dict{K, V}) = {"Array.from" :: K[] -> K[]}({Method{"keys"} :: Dict{K, V} -> K[]}(d));
// TODO: Figure out how to eliminate this weirdness
fn{Js} keys{V} (d: Dict{i8, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.I8(k)))" :: Dict{i8, V} -> i8[]}(d);
fn{Js} keys{V} (d: Dict{i16, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.I16(k)))" :: Dict{i16, V} -> i16[]}(d);
fn{Js} keys{V} (d: Dict{i32, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.I32(k)))" :: Dict{i32, V} -> i32[]}(d);
fn{Js} keys{V} (d: Dict{i64, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.I64(k)))" :: Dict{i64, V} -> i64[]}(d);
fn{Js} keys{V} (d: Dict{u8, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.U8(k)))" :: Dict{u8, V} -> u8[]}(d);
fn{Js} keys{V} (d: Dict{u16, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.U16(k)))" :: Dict{u16, V} -> u16[]}(d);
fn{Js} keys{V} (d: Dict{u32, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.U32(k)))" :: Dict{u32, V} -> u32[]}(d);
fn{Js} keys{V} (d: Dict{u64, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.U64(k)))" :: Dict{u64, V} -> u64[]}(d);
fn{Js} keys{V} (d: Dict{f32, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.F32(k)))" :: Dict{f32, V} -> f32[]}(d);
fn{Js} keys{V} (d: Dict{f64, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.F64(k)))" :: Dict{f64, V} -> f64[]}(d);
fn{Js} keys{V} (d: Dict{bool, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.Bool(k)))" :: Dict{bool, V} -> bool[]}(d);
fn{Js} keys{V} (d: Dict{string, V}) = {"((d) => [...d.keys()].map((k) => new alan_std.Str(k)))" :: Dict{string, V} -> string[]}(d);
fn{Rs} vals{K, V} "alan_std::valsdict" <- RootBacking :: Dict{K, V} -> V[];
fn{Js} vals{K, V} (d: Dict{K, V}) = {"Array.from" :: V[] -> V[]}({Method{"values"} :: Dict{K, V} -> V[]}(d));
fn{Rs} Array{K, V} "alan_std::arraydict" <- RootBacking :: Dict{K, V} -> (K, V)[];
// export fn{Js} Array{K, V} "Array.from" :: Dict{K, V} -> (K, V)[];
// TODO: Figure out how to avoid this map
fn{Js} Array{K, V} "((d) => Array.from(d).map(kv => ({ arg0: kv[0], arg1: kv[1] })))" :: Dict{K, V} -> (K, V)[];
fn{Js} Array{V} (d: Dict{i8, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I8(kv[0]), arg1: kv[1] })))" :: Dict{i8, V} -> (i8, V)[]}(d);
fn{Js} Array{V} (d: Dict{i16, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I16(kv[0]), arg1: kv[1] })))" :: Dict{i16, V} -> (i16, V)[]}(d);
fn{Js} Array{V} (d: Dict{i32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I32(kv[0]), arg1: kv[1] })))" :: Dict{i32, V} -> (i32, V)[]}(d);
fn{Js} Array{V} (d: Dict{i64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I64(kv[0]), arg1: kv[1] })))" :: Dict{i64, V} -> (i64, V)[]}(d);
fn{Js} Array{V} (d: Dict{u8, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U8(kv[0]), arg1: kv[1] })))" :: Dict{u8, V} -> (u8, V)[]}(d);
fn{Js} Array{V} (d: Dict{u16, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U16(kv[0]), arg1: kv[1] })))" :: Dict{u16, V} -> (u16, V)[]}(d);
fn{Js} Array{V} (d: Dict{u32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U32(kv[0]), arg1: kv[1] })))" :: Dict{u32, V} -> (u32, V)[]}(d);
fn{Js} Array{V} (d: Dict{u64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U64(kv[0]), arg1: kv[1] })))" :: Dict{u64, V} -> (u64, V)[]}(d);
fn{Js} Array{V} (d: Dict{f32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.F32(kv[0]), arg1: kv[1] })))" :: Dict{f32, V} -> (f32, V)[]}(d);
fn{Js} Array{V} (d: Dict{f64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.F64(kv[0]), arg1: kv[1] })))" :: Dict{f64, V} -> (f64, V)[]}(d);
fn{Js} Array{V} (d: Dict{bool, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.Bool(kv[0]), arg1: kv[1] })))" :: Dict{bool, V} -> (bool, V)[]}(d);
fn{Js} Array{V} (d: Dict{string, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.Str(kv[0]), arg1: kv[1] })))" :: Dict{string, V} -> (string, V)[]}(d);
fn{Rs} concat{K, V} "alan_std::concatdict" <- RootBacking :: (Dict{K, V}, Dict{K, V}) -> Dict{K, V};
fn{Js} concat{K, V} "((a, b) => new Map([...a, ...b]))" :: (Dict{K, V}, Dict{K, V}) -> Dict{K, V};

/// Set-related functions
fn Set{V}(v: V) {
  let out = Set{V}();
  out.store(v);
  return out;
}
fn Set{V}(a: Array{V}) = a.reduce(Set{V}(), fn (s: Set{V}, v: V) {
  s.store(v);
  return s;
});
fn{Rs} Set{V} "std::collections::HashSet::new" :: () -> Set{V};
fn{Js} Set{V} "new alan_std.FuzzySet" <- RootBacking :: () -> Set{V};
fn{Rs} store{V} (s: Mut{Set{V}}, v: V) {
  {Method{"insert"} :: (Mut{Set{V}}, Own{V}) -> bool}(s, v);
}
fn{Js} store{V} (s: Set{V}, v: V) {
  {Method{"store"} :: (s: Set{V}, v: V) -> ()}(s, v);
}
fn{Rs} has{V} (s: Set{V}, v: V) = {Method{"contains"} :: (Set{V}, V) -> bool}(s, v);
fn{Js} has{V} (s: Set{V}, v: V) = {Method{"has"} :: (Set{V}, V) -> bool}(s, v);
fn{Rs} len{V} (s: Set{V}) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Set{V} -> Binds{"usize"}}(s));
fn{Js} len{V} (s: Set{V}) = {Method{"len"} :: Set{V} -> i64}(s);
fn{Rs} Array{V} "alan_std::arrayset" <- RootBacking :: Set{V} -> V[];
fn{Js} Array{V} (s: Set{V}) = {Method{"array"} :: Set{V} -> V[]}(s)
fn{Rs} union{V} "alan_std::unionset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
fn{Js} union{V} (a: Set{V}, b: Set{V}) = {Method{"union"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
fn or{V}(a: Set{V}, b: Set{V}) = union(a, b);
fn{Rs} intersect{V} "alan_std::intersectset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
fn{Js} intersect{V} (a: Set{V}, b: Set{V}) = {Method{"intersect"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
fn and{V}(a: Set{V}, b: Set{V}) = intersect(a, b);
fn{Rs} difference{V} "alan_std::differenceset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
fn{Js} difference{V} (a: Set{V}, b: Set{V}) = {Method{"difference"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
fn div{V}(a: Set{V}, b: Set{V}) = difference(a, b);
fn{Rs} symmetricDifference{V} "alan_std::symmetric_differenceset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
fn{Js} symmetricDifference{V} (a: Set{V}, b: Set{V}) = {Method{"symmetricDifference"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
fn xor{V}(a: Set{V}, b: Set{V}) = symmetricDifference(a, b);
fn{Rs} product{V} "alan_std::productset" <- RootBacking :: (Set{V}, Set{V}) -> Set{(V, V)};
fn{Js} product{V} (a: Set{V}, b: Set{V}) = {Method{"product"} :: (Set{V}, Set{V}) -> Set{(V, V)}}(a, b);
fn mul{V}(a: Set{V}, b: Set{V}) = product(a, b);

/// Tree implementation

// The Tree type houses all of the values attached to a tree in an array and two secondary arrays to
// hold the metadata on which value is the parent and which are children, if any. The parent value
// `void` if it has no parent and a positive integer otherwise.
type Tree{T} =
  vals: Array{T},
  parents: Array{Maybe{i64}},
  children: Array{Array{i64}};

// The Node type simply holds the index to look into the tree for a particular value-parent-children
// triplet, where that index is reffered to as a node ID. This allows node-based code to be written
// while not actually having a recursive data structure that a traditional Node type would defined.
type Node{T} =
  id: i64,
  tree: Tree{T};

fn Tree{T}(rootVal: T) = Tree{T}(
  Array{T}(rootVal),
  Array{Maybe{i64}}(Maybe{i64}()),
  Array{Array{i64}}(Array{i64}()));
fn Tree{T}(n: Node{T}) = n.tree;

// TODO: This is a more correct solution, but any Tree constructed by us will always have the root
// node be the first element of the array, so we're just doing that so we don't have a `Maybe` here
/*export fn rootNode{T}(t: Tree{T}) -> Maybe{Node{T}} {
  let rootIdx = t.parents.index(Maybe{i64}());
  return if(
    rootIdx.exists,
    fn () -> Node{T} = Node{T}(rootIdx.getOrExit, t)
  );
}*/
fn rootNode{T}(t: Tree{T}) = Node{T}(0, t);

fn len{T}(t: Tree{T}) = t.vals.len;

fn Node{T}(t: Tree{T}, i: i64) = if(t.len > i, fn () = Node{T}(i, t));

fn parent{T}(n: Node{T}) {
  let parentId = n.tree.parents[n.id];
  return if(parentId.exists,
    if(exists(parentId!!),
      fn () = Node{T}(parentId.getOrExit.getOrExit, n.tree)),
      Maybe{Node{T}}());
}

fn children{T}(n: Node{T}) = if(
  n.tree.len > n.id,
  fn () {
    let childIds = n.tree.children[n.id] ?? Array{i64}();
    return childIds
      .filter(fn (id: i64) = n.tree.parents[id] ?? -1 == n.id)
      .map(fn (id: i64) = Node{T}(id, n.tree));
  },
  fn () = Array{Node{T}}());

fn children{T}(t: Tree{T}) = t.rootNode.children;

fn addChild{T}(n: Node{T}, val: T) {
  let idx = n.tree.len;
  let parentIdx = n.id;
  n.tree.vals.push(val);
  n.tree.parents.push(Maybe{i64}(parentIdx));
  n.tree.children.push(Array{i64}());
  return Node{T}(idx, n.tree);
}
fn addChild{T}(n: Node{T}, t: Tree{T}) {
  let idxOffset = n.tree.len;
  let idx = idxOffset.clone(); // TODO: Lower stage of compiler should be doing this
  let parentIdx = n.id;
  n.tree.vals.append(t.vals);
  n.tree.parents.append(t.parents.map(fn (pId: Maybe{i64}) = if(pId.exists,
    fn () = Maybe{i64}(pId!! + idxOffset),
    fn () = Maybe{i64}(idx))));
  n.tree.children.append(
    t.children.map(
      fn (ids: Array{i64}) = ids.map(
        fn (id: i64) = id + idxOffset)));
  return Node{T}(idx, n.tree);
}
fn addChild{T}(t: Tree{T}, val: T) = t.rootNode.addChild(val);


// TODO: Implement `addChild` when the child is itself a `Node{T}`

// TODO: Implement `prune` to pull a node out of the tree and re-attach its children to its own
// parent.

// TODO: Implement `subtree` to create a new tree consisting of the specified node as its root and
// only its own children as the children of the tree.

fn getOr{T}(n: Node{T}, t: T) = n.tree.vals[n.id] ?? t;

fn Array{T}(t: Tree{T}) = t.vals.map(
  fn (_: T, i: i64) = Node{T}(t, i)!!);

fn map{T, U}(t: Tree{T}, mapper: (Node{T}) -> Node{U}) = Tree{U}(
  t.Array.map(mapper),
  t.parents.clone(),
  t.children.clone());
fn map{T, U}(t: Tree{T}, mapper: (Node{T}, i64) -> Node{U}) = Tree{U}(
  t.Array.map(mapper),
  t.parents,
  t.children);

fn every{T}(t: Tree{T}, f: (Node{T}) -> bool) = t.Array.every(f);

fn some{T}(t: Tree{T}, f: (Node{T}) -> bool) = t.Array.some(f);

fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}) -> Node{T}) = t.Array.reduce(f);
fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}, i64) -> Node{T}) = t.Array.reduce(f);
fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}) -> U) = t.Array.reduce(i, f);
fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}, i64) -> U) = t.Array.reduce(i, f);

fn find{T}(t: Tree{T}, f: (Node{T}) -> bool) = t.Array.find(f);

/// Thread-related functions
fn{Rs} wait (t: i64) = {"std::thread::sleep" :: Own{Duration}}(
  {"std::time::Duration::from_millis" :: Own{u64} -> Duration}(t.u64)
);
fn{Js} wait "((t) => new Promise((r) => setTimeout(() => { r(performance.now()) }, Number(t))))" :: i64 -> f64;

/// Time-related functions
fn{Rs} now "std::time::Instant::now" :: () -> Instant;
fn{Js} now "performance.now" :: () -> Performance;
fn{Rs} elapsed Method{"elapsed"} :: Instant -> Duration;
fn{Js} elapsed "((p) => (performance.now() - p) / 1000.0)" :: Performance -> f64;
fn{Rs} f64 Method{"as_secs_f64"} :: Duration -> f64;

/// Uuid-related functions
fn{Rs} uuid "alan_std::Uuid::new_v4" <- RootBacking :: () -> uuid;
fn{Js} uuid "alan_std.uuidv4" <- RootBacking :: () -> uuid;
fn{Rs} string "format!" :: ("{}", uuid) -> string;
fn{Js} string "new alan_std.Str" :: uuid -> string;

/// GPU-related functions

// The base types and functionsto create buffers of memory on the GPU, construct a plan for a
// compute shader, execute it, and read the buffer back to the CPU
type{Rs} BufferUsages = Binds{"alan_std::BufferUsages" <- RootBacking};
type{Js} BufferUsages = Binds{"GPUBufferUsage"};
type{Rs} GBufferRaw = Binds{"alan_std::GBuffer" <- RootBacking};
type{Js} GBufferRaw = Binds{"GPUBuffer"};
type GBuffer{T} = rawBuffer: GBufferRaw, innerTypeName: String{T};
type GBufferTagged = rawBuffer: GBufferRaw, gpuTypeName: string;
type{Rs} GPGPU = Binds{"alan_std::GPGPU" <- RootBacking};
type{Js} GPGPU = Binds{"alan_std.GPGPU" <- RootBacking};

fn{Rs} mapReadBuffer "alan_std::map_read_buffer_type" <- RootBacking :: () -> BufferUsages;
fn{Js} mapReadBuffer "alan_std.mapReadBufferType" <- RootBacking :: () -> BufferUsages;
fn{Rs} mapWriteBuffer "alan_std::map_write_buffer_type" <- RootBacking :: () -> BufferUsages;
fn{Js} mapWriteBuffer "alan_std.mapWriteBufferType" <- RootBacking :: () -> BufferUsages;
fn{Rs} storageBuffer "alan_std::storage_buffer_type" <- RootBacking :: () -> BufferUsages;
fn{Js} storageBuffer "alan_std.storageBufferType" <- RootBacking :: () -> BufferUsages;
fn{Rs} GBuffer{T}(bu: BufferUsages, arr: T[]) {
  let fallibleRawBuffer = {"alan_std::create_buffer_init" <- RootBacking :: (BufferUsages, T[], i8) -> Fallible{GBufferRaw}}(bu, arr, {Size{T}}().i8);
  return if(fallibleRawBuffer.exists,
    fn = Fallible{GBuffer{T}}(GBuffer{T}(fallibleRawBuffer.getOrExit)),
    fn = Error{GBuffer{T}}(fallibleRawBuffer.Error.getOrExit.string));
}
fn{Js} GBuffer{T}(bu: BufferUsages, arr: T[]) {
  let fallibleRawBuffer = {"alan_std.createBufferInit" <- RootBacking :: (BufferUsages, T[]) -> Fallible{GBufferRaw}}(bu, arr);
  return if(fallibleRawBuffer.exists,
    fn = Fallible{GBuffer{T}}(GBuffer{T}(fallibleRawBuffer.getOrExit)),
    fn = Error{GBuffer{T}}(fallibleRawBuffer.Error.getOrExit.string));
}
fn{Rs} GBuffer{T}(bu: BufferUsages, size: i64) {
  let fallibleRawBuffer = {"alan_std::create_empty_buffer" <- RootBacking :: (BufferUsages, i64, i8) -> GBufferRaw!}(bu, size, {Size{T}}().i8);
  return if(fallibleRawBuffer.exists,
    fn = Fallible{GBuffer{T}}(GBuffer{T}(fallibleRawBuffer.getOrExit)),
    fn = Error{GBuffer{T}}(fallibleRawBuffer.Error.getOrExit.string));
}
fn{Js} GBuffer{T}(bu: BufferUsages, size: i64) {
  let fallibleRawBuffer = {"alan_std.createEmptyBuffer" <- RootBacking :: (BufferUsages, i32) -> GBufferRaw!}(bu, size.i32);
  return if(fallibleRawBuffer.exists,
    fn = Fallible{GBuffer{T}}(GBuffer{T}(fallibleRawBuffer.getOrExit)),
    fn = Error{GBuffer{T}}(fallibleRawBuffer.Error.getOrExit.string));
}
fn GBuffer{T}(vals: T[]) = GBuffer{T}(storageBuffer(), vals);
fn GBuffer{T}(size: i64) = GBuffer{T}(storageBuffer(), size);
fn{Rs} cpulen{T}(b: GBuffer{T}) = {"alan_std::bufferlen" <- RootBacking :: GBufferRaw -> i64}(b.rawBuffer);
fn{Js} cpulen{T}(b: GBuffer{T}) = {"alan_std.bufferlen" <- RootBacking :: GBufferRaw -> i64}(b.rawBuffer);
fn{Rs} id(b: GBufferRaw) = {"alan_std::buffer_id" <- RootBacking :: GBufferRaw -> string}(b);
fn{Js} id(b: GBufferRaw) = {"alan_std.bufferid" <- RootBacking :: GBufferRaw -> string}(b);
fn id{T}(b: GBuffer{T}) = b.rawBuffer.id;
fn id(b: GBufferTagged) = b.rawBuffer.id;
fn{Rs} GPGPU "alan_std::GPGPU::new" <- RootBacking :: (Own{string}, Own{Array{Array{GBufferRaw}}}, Deref{i64[3]}) -> GPGPU;
fn{Js} GPGPU (src: string, gbuffers: Array{Array{GBufferRaw}}, idx: i64[3]) = {"new alan_std.GPGPU" <- RootBacking :: (string, Array{Array{GBufferRaw}}, i32[3]) -> GPGPU}(src, gbuffers, idx.map(i32));
fn GPGPU{T}(src: string, buf: GBuffer{T}) -> GPGPU {
  // In order to support larger arrays, we need to split the buffer length across them. Each of
  // indices is allowed to be up to 65535 (yes, a 16-bit integer) leading to a maximum length of
  // 65535^3, or about 2.815x10^14 elements (about 281 trillion elements). Not quite up to the
  // 64-bit address space limit 2^64 or about 1.845x10^19 or about 18 quintillion elements, but
  // enough for exactly 1PB of 32-bit numbers in an array, so we should be good.
  // For now, the 65535 limit should be hardcoded by the shader author and an early exit
  // conditional check if the shader is operating on a nonexistent array index. This may change
  // in the future if the performance penalty of the bounds check is considered too high.
  //
  // Explaining the equation itself, the array length, L, needs to be split into X, Y, and Z
  // parts where L = X + A*Y + B*Z, with X, Y, and Z bound between 0 and 65534 (inclusive) while
  // A is 65535 and B is 65535^2 or 4294836225. Computing each dimension is to take the original
  // length of the array (which is the buffer size divided by 4 because we're only supporting
  // 32-bit numbers for now) and then getting the division and remainder first by the B constant,
  // and the Z limit becomes the division + 1, while the remainder is executed division and
  // remainder on the A constant, division + 1, and this remainder becomes the X limit (plus 1).
  // Including this big explanation in case I've made an off-by-one error here ;)
  let l = buf.cpulen;
  let zDiv = l / 4_294_836_225;
  let z = zDiv + 1;
  let zRem = l % 4_294_836_225;
  let yDiv = zRem / 65_535;
  let y = yDiv + 1;
  let yRem = zRem % 65_535;
  let x = max(yRem, 1);
  return GPGPU(src, [[buf.rawBuffer]], {i64[3]}(x, y, z));
}
fn{Rs} run "alan_std::gpu_run" <- RootBacking :: Mut{GPGPU};
fn{Js} run "alan_std.gpuRun" <- RootBacking :: GPGPU;
fn{Rs} run "alan_std::gpu_run_list" <- RootBacking :: Mut{GPGPU[]};
fn{Js} run "alan_std.gpuRunList" <- RootBacking :: GPGPU[];
fn{Rs} shader Property{"source.clone()"} :: GPGPU -> string;
fn{Js} shader Property{"source"} :: GPGPU -> string;
// TODO: Modify the `readBuffer` binding to pass the relevant type to it and remove the magic guess logic
fn{Rs} read{T}(gb: GBuffer{T}) = {"alan_std::read_buffer" <- RootBacking :: GBufferRaw -> T[]}(gb.rawBuffer);
fn{Js} read{T}(gb: GBuffer{T}) = {"alan_std.readBuffer" <- RootBacking :: (GBufferRaw, string) -> T[]}(gb.rawBuffer, String{T}());
// TODO: Same here
fn{Rs} replace{T}(gb: GBuffer{T}, vals: T[]) = {"alan_std::replace_buffer" <- RootBacking :: (GBufferRaw, T[]) -> ()!}(gb.rawBuffer, vals);
fn{Js} replace{T}(gb: GBuffer{T}, vals: T[]) = {"alan_std.replaceBuffer" <- RootBacking :: (GBufferRaw, T[]) -> ()!}(gb.rawBuffer, vals);

/// Ergonomic GPGPU-related types and functions

// The WgpuType provides a mechanism to build up the logic for a compute shader with normal-looking
// Alan code, not requiring to think in two different languages at the same time. All of the GPU
// types hereafter are derivative of this type
type WgpuType{N} =
  typeName: N,
  varName: string, // Key to the next field
  statements: Dict{string, string},
  buffers: Set{GBufferTagged};

// TODO: Better constraining on the input types allowed. It will still fail to compile, but the
// error message isn't great at the moment.
fn build{N}(ret: N) {
  // TODO: Don't assume all of the buffers involved here are storage buffers
  // Also TODO: Support other buffer types than i32
  let bufferArray = ret.buffers.Array;
  let wgslHeader = bufferArray.map(fn (gb: GBufferTagged, i: i64) {
    return "@group(0)\n@binding("
      .concat(i.string)
      .concat(")\nvar<storage, read_write> ")
      .concat(gb.id)
      .concat(": array<")
      .concat(gb.gpuTypeName)
      .concat(">;\n");
  }).join("\n");
  let wgslFunctionHeader = "@compute\n@workgroup_size(1)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n";
  let wgslFunctionBody = ret.statements.Array.map(fn (kv: (string, string)) {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () = "", fn () {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let wgsl = wgslHeader.concat(wgslFunctionHeader).concat(wgslFunctionBody).concat("}");
  let maxGlobalIdArray = ret
    .statements['@builtin(global_invocation_id) id: vec3u']
    .getOr('0,0,0')
    .split(',')
    .map(fn (s: string) = s.i64 ?? 0);
  let maxGlobalId = {i64[3]}(
    maxGlobalIdArray[0] ?? 0,
    maxGlobalIdArray[1] ?? 0,
    maxGlobalIdArray[2] ?? 0
  );
  let buffers = Array{Array{GBufferRaw}}();
  buffers.push(bufferArray.map(fn (gb: GBufferTagged) = gb.rawBuffer));
  return GPGPU(wgsl, buffers, maxGlobalId);
}
fn build{N}(ret: N[]) {
  // Array form to allow multiple side-effects to be computed in the same shader
  // We do this by simply merging all of the statements and buffers into a single instance of `N`
  // and then pass that up into the normal build function
  let statements = ret
    .reduce(Dict{string, string}(), fn (o: Dict{string, string}, r: N) = o.concat(r.statements));
  let buffers = ret.reduce(Set{GBufferTagged}(), fn (o: Set{GBufferTagged}, r: N) = o.union(r.buffers));
  return build({N}("", statements, buffers));
}

/// GPGPU primitive type functions

// Scalar types and constructors
type gu32 = WgpuType{"u32"};
type gi32 = WgpuType{"i32"};
type gf32 = WgpuType{"f32"};
type gbool = WgpuType{"bool"};

// Now that we have some GPGPU types, let's create the initial version of a "type map" that lets us
// look up the GPGPU type for its relevant CPU type. We'll update this along the way as needed
type WgpuTypeMap = String{u32}: gu32, String{i32}: gi32, String{f32}: gf32, String{bool}: gbool;

fn GBufferTagged{T}(b: GBuffer{T}) = GBufferTagged(b.rawBuffer, {Prop{WgpuTypeMap, String{T}}.typeName}());

// Utility functions for defining the various wgsl functions, operators, and properties
fn gProp{A, O}(propName: string, a: A) {
  let typename = {O.typeName}();
  let varName = propName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(a.varName)
    .concat('.')
    .concat(propName);
  let statements = a.statements.concat(Dict(varName, statement));
  let buffers = a.buffers.clone();
  return {O}(varName, statements, buffers);
}
fn gProp{A}(propName: string, a: A) = gProp{A, A}(propName, a);

fn gPrefix{A, O}(op: string, opName: string, a: A) {
  let typename = {O.typeName}();
  let varName = opName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(op)
    .concat(" ")
    .concat(a.varName);
  let statements = a.statements.concat(Dict(varName, statement));
  let buffers = a.buffers.clone();
  return {O}(varName, statements, buffers);
}
fn gPrefix{A}(op: string, opName: string, a: A) = gPrefix{A, A}(op, opName, a);

fn gInfix{A, B, O}(op: string, opName: string, a: A, b: B) {
  let typename = {O.typeName}();
  let varName = opName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(a.varName)
    .concat(" ")
    .concat(op)
    .concat(" ")
    .concat(b.varName);
  let statements = a.statements.concat(b.statements).concat(Dict(varName, statement));
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
fn gInfix{A, B}(op: string, opName: string, a: A, b: B) = gInfix{A, B, A}(op, opName, a, b);
fn gInfix{A, B}(op: string, opName: string, a: A, b: B) = gInfix{A, B, A}(op, opName, a, b);
fn gInfixRev{A, B}(op: string, opName: string, a: A, b: B) = gInfix{A, B, B}(op, opName, a, b);

fn gFn0{O}(funcName: string) { // TODO: Fix parser issue with variables beginning with `fn`
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat("()");
  let statements = Dict(varName, statement);
  let buffers = Set{GBufferTagged}();
  return {O}(varName, statements, buffers);
}

fn gFn1{A, O}(funcName: string, a: A) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(')');
  let statements = a.statements.concat(Dict(varName, statement));
  let buffers = a.buffers.clone();
  return {O}(varName, statements, buffers);
}
fn gFn1{A}(funcName: string, a: A) = gFn1{A, A}(funcName, a);

fn gFn2{A, B, O}(funcName: string, a: A, b: B) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements).concat(Dict(varName, statement));
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn2{A, O}(funcName: string, a: A, b: A) = gFn2{A, A, O}(funcName, a, b);
fn gFn2{A}(funcName: string, a: A, b: A) = gFn2{A, A, A}(funcName, a, b);

fn gFn3{A, B, C, O}(funcName: string, a: A, b: B, c: C) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn3{A, O}(funcName: string, a: A, b: A, c: A) = gFn3{A, A, A, O}(funcName, a, b, c);
fn gFn3{A}(funcName: string, a: A, b: A, c: A) = gFn3{A, A, A, A}(funcName, a, b, c);

fn gFn4{A, B, C, D, O}(funcName: string, a: A, b: B, c: C, d: D) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn4{A, O}(funcName: string, a: A, b: A, c: A, d: A) = gFn4{A, A, A, A, O}(funcName, a, b, c, d);
fn gFn4{A}(funcName: string, a: A, b: A, c: A, d: A) = gFn4{A, A, A, A}(funcName, a, b, c, d);

// Matrix constructors are crazy. The following are only included because of how crazy they are, and
// skipping any sizes that aren't used anywhere else
fn gFn6{A, B, C, D, E, F, O}(funcName: string, a: A, b: B, c: C, d: D, e: E, f: F) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(', ')
    .concat(e.varName)
    .concat(', ')
    .concat(f.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn6{A, O}(funcName: string, a: A, b: A, c: A, d: A, e: A, f: A) = 
  gFn6{A, A, A, A, A, A, O}(funcName, a, b, c, d, e, f);

fn gFn8{A, B, C, D, E, F, G, H, O}(
  funcName: string,
  a: A,
  b: B,
  c: C,
  d: D,
  e: E,
  f: F,
  g: G,
  h: H
) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(', ')
    .concat(e.varName)
    .concat(', ')
    .concat(f.varName)
    .concat(', ')
    .concat(g.varName)
    .concat(', ')
    .concat(h.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn8{A, O}(funcName: string, a: A, b: A, c: A, d: A, e: A, f: A, g: A, h: A) = 
  gFn8{A, A, A, A, A, A, A, A, O}(funcName, a, b, c, d, e, f, g, h);

fn gFn9{A, B, C, D, E, F, G, H, I, O}(
  funcName: string,
  a: A,
  b: B,
  c: C,
  d: D,
  e: E,
  f: F,
  g: G,
  h: H,
  i: I
) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(', ')
    .concat(e.varName)
    .concat(', ')
    .concat(f.varName)
    .concat(', ')
    .concat(g.varName)
    .concat(', ')
    .concat(h.varName)
    .concat(', ')
    .concat(i.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn9{A, O}(funcName: string, a: A, b: A, c: A, d: A, e: A, f: A, g: A, h: A, i: A) = 
  gFn9{A, A, A, A, A, A, A, A, A, O}(funcName, a, b, c, d, e, f, g, h, i);

fn gFn12{A, B, C, D, E, F, G, H, I, J, K, L, O}(
  funcName: string,
  a: A,
  b: B,
  c: C,
  d: D,
  e: E,
  f: F,
  g: G,
  h: H,
  i: I,
  j: J,
  k: K,
  l: L
) {
  let typename = {O.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(', ')
    .concat(e.varName)
    .concat(', ')
    .concat(f.varName)
    .concat(', ')
    .concat(g.varName)
    .concat(', ')
    .concat(h.varName)
    .concat(', ')
    .concat(i.varName)
    .concat(', ')
    .concat(j.varName)
    .concat(', ')
    .concat(k.varName)
    .concat(', ')
    .concat(l.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return {O}(varName, statements, buffers);
}
fn gFn12{A, O}(
  funcName: string,
  a: A,
  b: A,
  c: A,
  d: A,
  e: A,
  f: A,
  g: A,
  h: A,
  i: A,
  j: A,
  k: A,
  l: A
) = gFn12{A, A, A, A, A, A, A, A, A, A, A, A, O}(funcName, a, b, c, d, e, f, g, h, i, j, k, l);

fn gFn16{A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Z}(
  funcName: string,
  a: A,
  b: B,
  c: C,
  d: D,
  e: E,
  f: F,
  g: G,
  h: H,
  i: I,
  j: J,
  k: K,
  l: L,
  m: M,
  n: N,
  o: O,
  p: P
) {
  let typename = {Z.typeName}();
  let varName = funcName
    .concat('_')
    .concat(typename)
    .concat('_')
    .concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(funcName)
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(', ')
    .concat(e.varName)
    .concat(', ')
    .concat(f.varName)
    .concat(', ')
    .concat(g.varName)
    .concat(', ')
    .concat(h.varName)
    .concat(', ')
    .concat(i.varName)
    .concat(', ')
    .concat(j.varName)
    .concat(', ')
    .concat(k.varName)
    .concat(', ')
    .concat(l.varName)
    .concat(', ')
    .concat(m.varName)
    .concat(', ')
    .concat(n.varName)
    .concat(', ')
    .concat(o.varName)
    .concat(', ')
    .concat(p.varName)
    .concat(')');
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements)
    .concat(m.statements)
    .concat(n.statements)
    .concat(o.statements)
    .concat(p.statements)
    .concat(Dict(varName, statement));
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers)
    .union(m.buffers)
    .union(n.buffers)
    .union(o.buffers)
    .union(p.buffers);
  return {Z}(varName, statements, buffers);
}
fn gFn16{A, O}(
  funcName: string,
  a: A,
  b: A,
  c: A,
  d: A,
  e: A,
  f: A,
  g: A,
  h: A,
  i: A,
  j: A,
  k: A,
  l: A,
  m: A,
  n: A,
  o: A,
  p: A
) = gFn16{A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, O}(
  funcName,
  a,
  b,
  c,
  d,
  e,
  f,
  g,
  h,
  i,
  j,
  k,
  l,
  m,
  n,
  o,
  p
);

fn gPrimitiveConvert{A, O}(a: A) = gFn1{A, O}({O.typeName}(), a);

fn gu32(u: u32) = gu32(u.string.concat('u'), Dict{string, string}(), Set{GBufferTagged}());
fn gu32(gu: gu32) = gu;
fn gu32(gi: gi32) = gPrimitiveConvert{gi32, gu32}(gi);
fn gu32(gf: gf32) = gPrimitiveConvert{gf32, gu32}(gf);
fn gu32(gb: gbool) = gPrimitiveConvert{gbool, gu32}(gb);
fn gu32{T}(u: T) = gu32(u.u32);

fn gi32(i: i32) = gi32(i.string, Dict{string, string}(), Set{GBufferTagged}());
fn gi32(gu: gu32) = gPrimitiveConvert{gu32, gi32}(gu);
fn gi32(gi: gi32) = gi;
fn gi32(gf: gf32) = gPrimitiveConvert{gf32, gi32}(gf);
fn gi32(gb: gbool) = gPrimitiveConvert{gbool, gi32}(gb);
fn gi32{T}(i: T) = gi32(i.i32);

fn gf32(f: f32) = gf32(if(f.string.eq(f.i32.string), f.string(1), f.string), Dict{string, string}(), Set{GBufferTagged}());
fn gf32(gu: gu32) = gPrimitiveConvert{gu32, gf32}(gu);
fn gf32(gi: gi32) = gPrimitiveConvert{gi32, gf32}(gi);
fn gf32(gf: gf32) = gf;
fn gf32(gb: gbool) = gPrimitiveConvert{gbool, gf32}(gb);
fn gf32{T}(f: T) = gf32(f.f32);

fn gbool(b: bool) = gbool(b.string, Dict{string, string}(), Set{GBufferTagged}());
fn gbool(gu: gu32) = gPrimitiveConvert{gu32, gbool}(gu);
fn gbool(gi: gi32) = gPrimitiveConvert{gi32, gbool}(gi);
fn gbool(gf: gf32) = gPrimitiveConvert{gf32, gbool}(gf);
fn gbool(gb: gbool) = gb;
fn gbool{T}(b: T) = gbool(b.bool);

fn len{T}(gb: GBuffer{T}) = gu32(
  'arrayLength(&'.concat(gb.id).concat(')'),
  Dict{string, string}(),
  Set(GBufferTagged(gb))
);

/// GPGPU Vector types functions
type gvec2u = WgpuType{"vec2u"};
type gvec2i = WgpuType{"vec2i"};
type gvec2f = WgpuType{"vec2f"};
type gvec2b = WgpuType{"vec2<bool>"};
type gvec3u = WgpuType{"vec3u"};
type gvec3i = WgpuType{"vec3i"};
type gvec3f = WgpuType{"vec3f"};
type gvec3b = WgpuType{"vec3<bool>"};
type gvec4u = WgpuType{"vec4u"};
type gvec4i = WgpuType{"vec4i"};
type gvec4f = WgpuType{"vec4f"};
type gvec4b = WgpuType{"vec4<bool>"};

// We're unwrapping the prior definition and appending new values to this lookup type
type WgpuTypeMap = 
  Unwrap{WgpuTypeMap},
  String{Buffer{u32, 2}}: gvec2u,
  String{Buffer{i32, 2}}: gvec2i,
  String{Buffer{f32, 2}}: gvec2f,
  String{Buffer{bool, 2}}: gvec2b,
  String{Buffer{u32, 3}}: gvec3u,
  String{Buffer{i32, 3}}: gvec3i,
  String{Buffer{f32, 3}}: gvec3f,
  String{Buffer{bool, 3}}: gvec3b,
  String{Buffer{u32, 4}}: gvec4u,
  String{Buffer{i32, 4}}: gvec4i,
  String{Buffer{f32, 4}}: gvec4f,
  String{Buffer{bool, 4}}: gvec4b;

fn gvec2Primitive{I, O}(a: I, b: I) = gFn2{I, O}({O.typeName}(), a, b);

fn gvec2u() = gFn0{gvec2u}({gvec2u.typeName}());
fn gvec2u(a: gu32, b: gu32) = gvec2Primitive{gu32, gvec2u}(a, b);
fn gvec2u{T}(a: T, b: T) = gvec2u(a.gu32, b.gu32);
fn gvec2u{T}(a: T) = gvec2u(a, a);

fn gvec2i() = gFn0{gvec2i}({gvec2i.typeName}());
fn gvec2i() = gvec2i("vec2i()", Dict{string, string}(), Set{GBufferTagged}());
fn gvec2i(a: gi32, b: gi32) = gvec2Primitive{gi32, gvec2i}(a, b);
fn gvec2i{T}(a: T, b: T) = gvec2i(a.gi32, b.gi32);
fn gvec2i{T}(a: T) = gvec2i(a, a);

fn gvec2f() = gFn0{gvec2f}({gvec2f.typeName}());
fn gvec2f(a: gf32, b: gf32) = gvec2Primitive{gf32, gvec2f}(a, b);
fn gvec2f{T}(a: T, b: T) = gvec2f(a.gf32, b.gf32);
fn gvec2f{T}(a: T) = gvec2f(a, a);

fn gvec2b() = gFn0{gvec2b}({gvec2b.typeName}());
fn gvec2b(a: gbool, b: gbool) = gvec2Primitive{gbool, gvec2b}(a, b);
fn gvec2b{T}(a: T, b: T) = gvec2b(a.gbool, b.gbool);
fn gvec2b{T}(a: T) = gvec2b(a, a);

fn gvec3Primitive{I, O}(a: I, b: I, c: I) = gFn3{I, O}({O.typeName}(), a, b, c);

fn gvec3u() = gFn0{gvec3u}({gvec3u.typeName}());
fn gvec3u(a: gu32, b: gu32, c: gu32) = gvec3Primitive{gu32, gvec3u}(a, b, c);
fn gvec3u{T}(a: T, b: T, c: T) = gvec3u(a.gu32, b.gu32, c.gu32);
fn gvec3u{T}(a: T) = gvec3u(a, a, a);

fn gvec3i() = gFn0{gvec3i}({gvec3i.typeName}());
fn gvec3i(a: gi32, b: gi32, c: gi32) = gvec3Primitive{gi32, gvec3i}(a, b, c);
fn gvec3i{T}(a: T, b: T, c: T) = gvec3i(a.gi32, b.gi32, c.gi32);
fn gvec3i{T}(a: T) = gvec3i(a, a, a);

fn gvec3f() = gFn0{gvec3f}({gvec3f.typeName}());
fn gvec3f(a: gf32, b: gf32, c: gf32) = gvec3Primitive{gf32, gvec3f}(a, b, c);
fn gvec3f{T}(a: T, b: T, c: T) = gvec3f(a.gf32, b.gf32, c.gf32);
fn gvec3f{T}(a: T) = gvec3f(a, a, a);

fn gvec3b() = gFn0{gvec4b}({gvec3b.typeName}());
fn gvec3b(a: gbool, b: gbool, c: gbool) = gvec3Primitive{gbool, gvec3b}(a, b, c);
fn gvec3b{T}(a: T, b: T, c: T) = gvec3b(a.gbool, b.gbool, c.gbool);
fn gvec3b{T}(a: T) = gvec3b(a, a, a);

fn gvec4Primitive{I, O}(a: I, b: I, c: I, d: I) = gFn4{I, O}({O.typeName}(), a, b, c, d);

fn gvec4u() = gFn0{gvec4u}({gvec4u.typeName}());
fn gvec4u(a: gu32, b: gu32, c: gu32, d: gu32) = gvec4Primitive{gu32, gvec4u}(
  a, b, c, d
);
fn gvec4u{T}(a: T, b: T, c: T, d: T) = gvec4u(a.gu32, b.gu32, c.gu32, d.gu32);
fn gvec4u{T}(a: T) = gvec4u(a, a, a, a);

fn gvec4i() = gFn0{gvec4i}({gvec4i.typeName}());
fn gvec4i(a: gi32, b: gi32, c: gi32, d: gi32) = gvec4Primitive{gi32, gvec4i}(
  a, b, c, d
);
fn gvec4i{T}(a: T, b: T, c: T, d: T) = gvec4i(a.gi32, b.gi32, c.gi32, d.gi32);
fn gvec4i{T}(a: T) = gvec4i(a, a, a, a);

fn gvec4f() = gFn0{gvec4f}({gvec4f.typeName}());
fn gvec4f{A, B, C, D}(a: A, b: B, c: C, d: D) = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);
fn gvec4f(a: gf32, b: gf32, c: gf32, d: gf32) = gvec4Primitive{gf32, gvec4f}(
  a, b, c, d
);
fn gvec4f{T}(a: T, b: T, c: T, d: T) = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);
fn gvec4f{T}(a: T) = gvec4f(a, a, a, a);

fn gvec4b() = gFn0{gvec4b}({gvec4b.typeName}());
fn gvec4b(a: gbool, b: gbool, c: gbool, d: gbool) = gvec4Primitive{gbool, gvec4b}(
  a, b, c, d
);
fn gvec4b{T}(a: T, b: T, c: T, d: T) = gvec4b(a.gbool, b.gbool, c.gbool, d.gbool);
fn gvec4b{T}(a: T) = gvec4b(a, a, a, a);

// The global_invocation_id; the entry value to a compute shader, and it's constructor, a
// specialized version of gvec3u that initializes a bit differently.
fn gFor(x: u32, y: u32, z: u32) {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',').concat(z.string));
  return gvec3u('id', statements, Set{GBufferTagged}());
}
fn gFor{T}(x: T, y: T, z: T) = gFor(x.u32, y.u32, z.u32);
fn gFor{T}(x: T, y: T) = gFor(x.u32, y.u32, 1.u32);
fn gFor{T}(x: T) = gFor(x.u32, 1.u32, 1.u32).x;
// TODO: More hackery to eliminate
fn gFor(x: i64, y: i64) {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',1'));
  return gvec3u('id', statements, Set{GBufferTagged}());
}

/// GPGPU Matrix types and functions
type gmat2x2f = WgpuType{"mat2x2f"};
type gmat2x3f = WgpuType{"mat2x3f"};
type gmat2x4f = WgpuType{"mat2x4f"};
type gmat3x2f = WgpuType{"mat3x2f"};
type gmat3x3f = WgpuType{"mat3x3f"};
type gmat3x4f = WgpuType{"mat3x4f"};
type gmat4x2f = WgpuType{"mat4x2f"};
type gmat4x3f = WgpuType{"mat4x3f"};
type gmat4x4f = WgpuType{"mat4x4f"};

// And the last of the type mapping we're going to define, matrices. Wgpu uses column-order for the
// definition, so 2x3 is a buffer of 3 sets of buffers of 2 floats, btw.
type WgpuTypeMap =
  Unwrap{WgpuTypeMap},
  String{Buffer{Buffer{f32, 2}, 2}}: gmat2x2f,
  String{Buffer{Buffer{f32, 2}, 3}}: gmat2x3f,
  String{Buffer{Buffer{f32, 2}, 4}}: gmat2x4f,
  String{Buffer{Buffer{f32, 3}, 2}}: gmat3x2f,
  String{Buffer{Buffer{f32, 3}, 3}}: gmat3x3f,
  String{Buffer{Buffer{f32, 3}, 4}}: gmat3x4f,
  String{Buffer{Buffer{f32, 4}, 2}}: gmat4x2f,
  String{Buffer{Buffer{f32, 4}, 3}}: gmat4x3f,
  String{Buffer{Buffer{f32, 4}, 4}}: gmat4x4f;

fn gmat2x2f() = gFn0{gmat2x2f}({gmat2x2f.typeName}());
fn gmat2x2f(a: gvec2f, b: gvec2f) = gFn2{gvec2f, gmat2x2f}({gmat2x2f.typeName}(), a, b);
fn gmat2x2f{I}(a: I, b: I, c: I, d: I) = gmat2x2f(a.gf32, b.gf32, c.gf32, d.gf32);
fn gmat2x2f(a: gf32, b: gf32, c: gf32, d: gf32) = gFn4{gf32, gmat2x2f}({gmat2x2f.typeName}(), a, b, c, d);

fn gmat2x3f() = gFn0{gmat2x3f}({gmat2x2f.typeName}());
fn gmat2x3f(a: gvec3f, b: gvec3f) = gFn2{gvec3f, gmat2x3f}({gmat2x3f.typeName}(), a, b);
fn gmat2x3f{I}(a: I, b: I, c: I, d: I, e: I, f: I) = gmat2x3f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32
);
fn gmat2x3f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) =
  gFn6{gf32, gmat2x3f}({gmat2x3f.typeName}(), a, b, c, d, e, f);

fn gmat2x4f() = gFn0{gmat2x4f}({gmat2x4f.typeName}());
fn gmat2x4f(a: gvec4f, b: gvec4f) = gFn2{gvec4f, gmat2x4f}({gmat2x4f.typeName}(), a, b);
fn gmat2x4f{I}(a: I, b: I, c: I, d: I, e: I, f: I, g: gf32, h: gf32) = gmat2x4f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32, g.gf32, h.gf32
);
fn gmat2x4f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32) =
  gFn8{gf32, gmat2x4f}({gmat2x4f.typeName}(), a, b, c, d, e, f, g, h);

fn gmat3x3f() = gFn0{gmat3x2f}({gmat3x3f.typeName}());
fn gmat3x2f(a: gvec2f, b: gvec2f, c: gvec2f) =
  gFn3{gvec2f, gmat3x2f}({gmat3x2f.typeName}(), a, b, c);
fn gmat3x2f{I}(a: I, b: I, c: I, d: I, e: I, f: I) = gmat3x2f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32
);
fn gmat3x2f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) =
  gFn6{gf32, gmat3x2f}({gmat3x2f.typeName}(), a, b, c, d, e, f);

fn gmat3x3f() = gFn0{gmat3x3f}({gmat3x3f.typeName}());
fn gmat3x3f(a: gvec3f, b: gvec3f, c: gvec3f) =
  gFn3{gvec3f, gmat3x3f}({gmat3x3f.typeName}(), a, b, c);
fn gmat3x3f{I}(a: I, b: I, c: I, d: I, e: I, f: I, g: I, h: I, i: I) = gmat3x3f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32, g.gf32, h.gf32, i.gf32
);
fn gmat3x3f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32, i: gf32) =
  gFn9{gf32, gmat3x3f}({gmat3x3f.typeName}(), a, b, c, d, e, f, g, h, i);

fn gmat3x4f() = gFn0{gmat3x4f}({gmat3x4f.typeName}());
fn gmat3x4f(a: gvec4f, b: gvec4f, c: gvec4f) =
  gFn3{gvec4f, gmat3x4f}({gmat3x4f.typeName}(), a, b, c);
fn gmat3x4f{I}(a: I, b: I, c: I, d: I, e: I, f: I, g: I, h: I, i: I, j: I, k: I, l: I) = gmat3x4f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32, g.gf32, h.gf32, i.gf32, j.gf32, k.gf32, l.gf32
);
fn gmat3x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) = gFn12{gf32, gmat3x4f}({gmat3x4f.typeName}(), a, b, c, d, e, f, g, h, i, j, k, l);

fn gmat4x2f() = gFn0{gmat4x2f}({gmat4x2f.typeName}());
fn gmat4x2f(a: gvec2f, b: gvec2f, c: gvec2f, d: gvec2f) =
  gFn4{gvec2f, gmat4x2f}({gmat4x2f.typeName}(), a, b, c, d);
fn gmat4x2f{I}(a: I, b: I, c: I, d: I, e: I, f: I, g: I, h: I) = gmat4x2f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32, g.gf32, h.gf32
);
fn gmat4x2f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32) =
  gFn8{gf32, gmat4x2f}({gmat4x2f.typeName}(), a, b, c, d, e, f, g, h);

fn gmat4x3f() = gFn0{gmat4x3f}({gmat4x3f.typeName}());
fn gmat4x3f(a: gvec3f, b: gvec3f, c: gvec3f, d: gvec3f) =
  gFn4{gvec3f, gmat4x3f}({gmat4x2f.typeName}(), a, b, c, d);
fn gmat4x3f{I}(a: I, b: I, c: I, d: I, e: I, f: I, g: I, h: I, i: I, j: I, k: I, l: I) = gmat4x3f(
  a.gf32, b.gf32, c.gf32, d.gf32, e.gf32, f.gf32, g.gf32, h.gf32, i.gf32, j.gf32, k.gf32, l.gf32
);
fn gmat4x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) = gFn12{gf32, gmat4x3f}({gmat4x3f.typeName}(), a, b, c, d, e, f, g, h, i, j, k, l);

fn gmat4x4f() = gFn0{gmat4x4f}({gmat4x4f.typeName}());
fn gmat4x4f(a: gvec4f, b: gvec4f, c: gvec4f, d: gvec4f) =
  gFn4{gvec4f, gmat4x4f}({gmat4x4f.typeName}(), a, b, c, d);
fn gmat4x4f{I}(
  a: I,
  b: I,
  c: I,
  d: I,
  e: I,
  f: I,
  g: I,
  h: I,
  i: I,
  j: I,
  k: I,
  l: I,
  m: I,
  n: I,
  o: I,
  p: I
) = gmat4x4f(
  a.gf32,
  b.gf32,
  c.gf32,
  d.gf32,
  e.gf32,
  f.gf32,
  g.gf32,
  h.gf32,
  i.gf32,
  j.gf32,
  k.gf32,
  l.gf32,
  m.gf32,
  n.gf32,
  o.gf32,
  p.gf32
);
fn gmat4x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32,
  m: gf32,
  n: gf32,
  o: gf32,
  p: gf32
) = gFn16{gf32, gmat4x4f}({gmat4x4f.typeName}(), a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);

// TODO: Fixed-length buffers within wgsl

// TODO: How to handle structs?

/// GPGPU Accessor functions

fn x(v: gvec2u) = gProp{gvec2u, gu32}('x', v);
fn y(v: gvec2u) = gProp{gvec2u, gu32}('y', v);
fn i(v: gvec2u) = v.x;
fn j(v: gvec2u) = v.y;
fn r(v: gvec2u) = v.x;
fn g(v: gvec2u) = v.y;

fn xy(v: gvec2u) = gProp('xy', v);
fn yx(v: gvec2u) = gProp('yx', v);
fn ij(v: gvec2u) = v.xy;
fn ji(v: gvec2u) = v.yx;
fn rg(v: gvec2u) = v.xy;
fn gr(v: gvec2u) = v.yx;

fn x(v: gvec2i) = gProp{gvec2i, gi32}('x', v);
fn y(v: gvec2i) = gProp{gvec2i, gi32}('y', v);
fn i(v: gvec2i) = v.x;
fn j(v: gvec2i) = v.y;
fn r(v: gvec2i) = v.x;
fn g(v: gvec2i) = v.y;

fn xy(v: gvec2i) = gProp('xy', v);
fn yx(v: gvec2i) = gProp('yx', v);
fn ij(v: gvec2i) = v.xy;
fn ji(v: gvec2i) = v.yx;
fn rg(v: gvec2i) = v.xy;
fn gr(v: gvec2i) = v.yx;

fn x(v: gvec2f) = gProp{gvec2f, gf32}('x', v);
fn y(v: gvec2f) = gProp{gvec2f, gf32}('y', v);
fn i(v: gvec2f) = v.x;
fn j(v: gvec2f) = v.y;
fn r(v: gvec2f) = v.x;
fn g(v: gvec2f) = v.y;

fn xy(v: gvec2f) = gProp('xy', v);
fn yx(v: gvec2f) = gProp('yx', v);
fn ij(v: gvec2f) = v.xy;
fn ji(v: gvec2f) = v.yx;
fn rg(v: gvec2f) = v.xy;
fn gr(v: gvec2f) = v.yx;

fn x(v: gvec2b) = gProp{gvec2b, gbool}('x', v);
fn y(v: gvec2b) = gProp{gvec2b, gbool}('y', v);
fn i(v: gvec2b) = v.x;
fn j(v: gvec2b) = v.y;
fn r(v: gvec2b) = v.x;
fn g(v: gvec2b) = v.y;

fn xy(v: gvec2b) = gProp('xy', v);
fn yx(v: gvec2b) = gProp('yx', v);
fn ij(v: gvec2b) = v.xy;
fn ji(v: gvec2b) = v.yx;
fn rg(v: gvec2b) = v.xy;
fn gr(v: gvec2b) = v.yx;

fn x(v: gvec3u) = gProp{gvec3u, gu32}('x', v);
fn y(v: gvec3u) = gProp{gvec3u, gu32}('y', v);
fn z(v: gvec3u) = gProp{gvec3u, gu32}('z', v);
fn i(v: gvec3u) = v.x;
fn j(v: gvec3u) = v.y;
fn k(v: gvec3u) = v.z;
fn r(v: gvec3u) = v.x;
fn g(v: gvec3u) = v.y;
fn b(v: gvec3u) = v.z;

fn xy(v: gvec3u) = gProp{gvec3u, gvec2u}('xy', v);
fn yx(v: gvec3u) = gProp{gvec3u, gvec2u}('yx', v);
fn xz(v: gvec3u) = gProp{gvec3u, gvec2u}('xz', v);
fn zx(v: gvec3u) = gProp{gvec3u, gvec2u}('zx', v);
fn yz(v: gvec3u) = gProp{gvec3u, gvec2u}('yz', v);
fn zy(v: gvec3u) = gProp{gvec3u, gvec2u}('zy', v);
fn ij(v: gvec3u) = v.xy;
fn ji(v: gvec3u) = v.yx;
fn ik(v: gvec3u) = v.xz;
fn ki(v: gvec3u) = v.zx;
fn jk(v: gvec3u) = v.yz;
fn kj(v: gvec3u) = v.zy;
fn rg(v: gvec3u) = v.xy;
fn gr(v: gvec3u) = v.yx;
fn rb(v: gvec3u) = v.xz;
fn br(v: gvec3u) = v.zx;
fn gb(v: gvec3u) = v.yz;
fn bg(v: gvec3u) = v.zy;

fn xyz(v: gvec3u) = gProp('xyz', v);
fn xzy(v: gvec3u) = gProp('xzy', v);
fn yxz(v: gvec3u) = gProp('yxz', v);
fn yzx(v: gvec3u) = gProp('yzx', v);
fn zxy(v: gvec3u) = gProp('zxy', v);
fn zyx(v: gvec3u) = gProp('zyx', v);
fn ijk(v: gvec3u) = v.xyz;
fn ikj(v: gvec3u) = v.xzy;
fn jik(v: gvec3u) = v.yxz;
fn jki(v: gvec3u) = v.yzx;
fn kij(v: gvec3u) = v.zxy;
fn kji(v: gvec3u) = v.zyx;
fn rgb(v: gvec3u) = v.xyz;
fn rbg(v: gvec3u) = v.xzy;
fn grb(v: gvec3u) = v.yxz;
fn gbr(v: gvec3u) = v.yzx;
fn brg(v: gvec3u) = v.zxy;
fn bgr(v: gvec3u) = v.zyx;

fn x(v: gvec3i) = gProp{gvec3i, gi32}('x', v);
fn y(v: gvec3i) = gProp{gvec3i, gi32}('y', v);
fn z(v: gvec3i) = gProp{gvec3i, gi32}('z', v);
fn i(v: gvec3i) = v.x;
fn j(v: gvec3i) = v.y;
fn k(v: gvec3i) = v.z;
fn r(v: gvec3i) = v.x;
fn g(v: gvec3i) = v.y;
fn b(v: gvec3i) = v.z;

fn xy(v: gvec3i) = gProp{gvec3i, gvec2i}('xy', v);
fn yx(v: gvec3i) = gProp{gvec3i, gvec2i}('yx', v);
fn xz(v: gvec3i) = gProp{gvec3i, gvec2i}('xz', v);
fn zx(v: gvec3i) = gProp{gvec3i, gvec2i}('zx', v);
fn yz(v: gvec3i) = gProp{gvec3i, gvec2i}('yz', v);
fn zy(v: gvec3i) = gProp{gvec3i, gvec2i}('zy', v);
fn ij(v: gvec3i) = v.xy;
fn ji(v: gvec3i) = v.yx;
fn ik(v: gvec3i) = v.xz;
fn ki(v: gvec3i) = v.zx;
fn jk(v: gvec3i) = v.yz;
fn kj(v: gvec3i) = v.zy;
fn rg(v: gvec3i) = v.xy;
fn gr(v: gvec3i) = v.yx;
fn rb(v: gvec3i) = v.xz;
fn br(v: gvec3i) = v.zx;
fn gb(v: gvec3i) = v.yz;
fn bg(v: gvec3i) = v.zy;

fn xyz(v: gvec3i) = gProp('xyz', v);
fn xzy(v: gvec3i) = gProp('xzy', v);
fn yxz(v: gvec3i) = gProp('yxz', v);
fn yzx(v: gvec3i) = gProp('yzx', v);
fn zxy(v: gvec3i) = gProp('zxy', v);
fn zyx(v: gvec3i) = gProp('zyx', v);
fn ijk(v: gvec3i) = v.xyz;
fn ikj(v: gvec3i) = v.xzy;
fn jik(v: gvec3i) = v.yxz;
fn jki(v: gvec3i) = v.yzx;
fn kij(v: gvec3i) = v.zxy;
fn kji(v: gvec3i) = v.zyx;
fn rgb(v: gvec3i) = v.xyz;
fn rbg(v: gvec3i) = v.xzy;
fn grb(v: gvec3i) = v.yxz;
fn gbr(v: gvec3i) = v.yzx;
fn brg(v: gvec3i) = v.zxy;
fn bgr(v: gvec3i) = v.zyx;

fn x(v: gvec3f) = gProp{gvec3f, gf32}('x', v);
fn y(v: gvec3f) = gProp{gvec3f, gf32}('y', v);
fn z(v: gvec3f) = gProp{gvec3f, gf32}('z', v);
fn i(v: gvec3f) = v.x;
fn j(v: gvec3f) = v.y;
fn k(v: gvec3f) = v.z;
fn r(v: gvec3f) = v.x;
fn g(v: gvec3f) = v.y;
fn b(v: gvec3f) = v.z;

fn xy(v: gvec3f) = gProp{gvec3f, gvec2f}('xy', v);
fn yx(v: gvec3f) = gProp{gvec3f, gvec2f}('yx', v);
fn xz(v: gvec3f) = gProp{gvec3f, gvec2f}('xz', v);
fn zx(v: gvec3f) = gProp{gvec3f, gvec2f}('zx', v);
fn yz(v: gvec3f) = gProp{gvec3f, gvec2f}('yz', v);
fn zy(v: gvec3f) = gProp{gvec3f, gvec2f}('zy', v);
fn ij(v: gvec3f) = v.xy;
fn ji(v: gvec3f) = v.yx;
fn ik(v: gvec3f) = v.xz;
fn ki(v: gvec3f) = v.zx;
fn jk(v: gvec3f) = v.yz;
fn kj(v: gvec3f) = v.zy;
fn rg(v: gvec3f) = v.xy;
fn gr(v: gvec3f) = v.yx;
fn rb(v: gvec3f) = v.xz;
fn br(v: gvec3f) = v.zx;
fn gb(v: gvec3f) = v.yz;
fn bg(v: gvec3f) = v.zy;

fn xyz(v: gvec3f) = gProp('xyz', v);
fn xzy(v: gvec3f) = gProp('xzy', v);
fn yxz(v: gvec3f) = gProp('yxz', v);
fn yzx(v: gvec3f) = gProp('yzx', v);
fn zxy(v: gvec3f) = gProp('zxy', v);
fn zyx(v: gvec3f) = gProp('zyx', v);
fn ijk(v: gvec3f) = v.xyz;
fn ikj(v: gvec3f) = v.xzy;
fn jik(v: gvec3f) = v.yxz;
fn jki(v: gvec3f) = v.yzx;
fn kij(v: gvec3f) = v.zxy;
fn kji(v: gvec3f) = v.zyx;
fn rgb(v: gvec3f) = v.xyz;
fn rbg(v: gvec3f) = v.xzy;
fn grb(v: gvec3f) = v.yxz;
fn gbr(v: gvec3f) = v.yzx;
fn brg(v: gvec3f) = v.zxy;
fn bgr(v: gvec3f) = v.zyx;

fn x(v: gvec3b) = gProp{gvec3b, gbool}('x', v);
fn y(v: gvec3b) = gProp{gvec3b, gbool}('y', v);
fn z(v: gvec3b) = gProp{gvec3b, gbool}('z', v);
fn i(v: gvec3b) = v.x;
fn j(v: gvec3b) = v.y;
fn k(v: gvec3b) = v.z;
fn r(v: gvec3b) = v.x;
fn g(v: gvec3b) = v.y;
fn b(v: gvec3b) = v.z;

fn xy(v: gvec3b) = gProp{gvec3b, gvec2b}('xy', v);
fn yx(v: gvec3b) = gProp{gvec3b, gvec2b}('yx', v);
fn xz(v: gvec3b) = gProp{gvec3b, gvec2b}('xz', v);
fn zx(v: gvec3b) = gProp{gvec3b, gvec2b}('zx', v);
fn yz(v: gvec3b) = gProp{gvec3b, gvec2b}('yz', v);
fn zy(v: gvec3b) = gProp{gvec3b, gvec2b}('zy', v);
fn ij(v: gvec3b) = v.xy;
fn ji(v: gvec3b) = v.yx;
fn ik(v: gvec3b) = v.xz;
fn ki(v: gvec3b) = v.zx;
fn jk(v: gvec3b) = v.yz;
fn kj(v: gvec3b) = v.zy;
fn rg(v: gvec3b) = v.xy;
fn gr(v: gvec3b) = v.yx;
fn rb(v: gvec3b) = v.xz;
fn br(v: gvec3b) = v.zx;
fn gb(v: gvec3b) = v.yz;
fn bg(v: gvec3b) = v.zy;

fn xyz(v: gvec3b) = gProp('xyz', v);
fn xzy(v: gvec3b) = gProp('xzy', v);
fn yxz(v: gvec3b) = gProp('yxz', v);
fn yzx(v: gvec3b) = gProp('yzx', v);
fn zxy(v: gvec3b) = gProp('zxy', v);
fn zyx(v: gvec3b) = gProp('zyx', v);
fn ijk(v: gvec3b) = v.xyz;
fn ikj(v: gvec3b) = v.xzy;
fn jik(v: gvec3b) = v.yxz;
fn jki(v: gvec3b) = v.yzx;
fn kij(v: gvec3b) = v.zxy;
fn kji(v: gvec3b) = v.zyx;
fn rgb(v: gvec3b) = v.xyz;
fn rbg(v: gvec3b) = v.xzy;
fn grb(v: gvec3b) = v.yxz;
fn gbr(v: gvec3b) = v.yzx;
fn brg(v: gvec3b) = v.zxy;
fn bgr(v: gvec3b) = v.zyx;

fn x(v: gvec4u) = gProp{gvec4u, gu32}('x', v);
fn y(v: gvec4u) = gProp{gvec4u, gu32}('y', v);
fn z(v: gvec4u) = gProp{gvec4u, gu32}('z', v);
fn w(v: gvec4u) = gProp{gvec4u, gu32}('w', v);
fn i(v: gvec4u) = v.x;
fn j(v: gvec4u) = v.y;
fn k(v: gvec4u) = v.z;
fn l(v: gvec4u) = v.w;
fn r(v: gvec4u) = v.x;
fn g(v: gvec4u) = v.y;
fn b(v: gvec4u) = v.z;
fn a(v: gvec4u) = v.w;

fn xy(v: gvec4u) = gProp{gvec4u, gvec2u}('xy', v);
fn yx(v: gvec4u) = gProp{gvec4u, gvec2u}('yx', v);
fn xz(v: gvec4u) = gProp{gvec4u, gvec2u}('xz', v);
fn zx(v: gvec4u) = gProp{gvec4u, gvec2u}('zx', v);
fn xw(v: gvec4u) = gProp{gvec4u, gvec2u}('xw', v);
fn wx(v: gvec4u) = gProp{gvec4u, gvec2u}('wx', v);
fn yz(v: gvec4u) = gProp{gvec4u, gvec2u}('yz', v);
fn zy(v: gvec4u) = gProp{gvec4u, gvec2u}('zy', v);
fn yw(v: gvec4u) = gProp{gvec4u, gvec2u}('yw', v);
fn wy(v: gvec4u) = gProp{gvec4u, gvec2u}('wy', v);
fn zw(v: gvec4u) = gProp{gvec4u, gvec2u}('zw', v);
fn wz(v: gvec4u) = gProp{gvec4u, gvec2u}('wz', v);
fn ij(v: gvec4u) = v.xy;
fn ji(v: gvec4u) = v.yx;
fn ik(v: gvec4u) = v.xz;
fn ki(v: gvec4u) = v.zx;
fn il(v: gvec4u) = v.xw;
fn li(v: gvec4u) = v.wx;
fn jk(v: gvec4u) = v.yz;
fn kj(v: gvec4u) = v.zy;
fn jl(v: gvec4u) = v.yw;
fn lj(v: gvec4u) = v.wy;
fn kl(v: gvec4u) = v.zw;
fn lk(v: gvec4u) = v.wz;
fn rg(v: gvec4u) = v.xy;
fn gr(v: gvec4u) = v.yx;
fn rb(v: gvec4u) = v.xz;
fn br(v: gvec4u) = v.zx;
fn ra(v: gvec4u) = v.xw;
fn ar(v: gvec4u) = v.wx;
fn gb(v: gvec4u) = v.yz;
fn bg(v: gvec4u) = v.zy;
fn ga(v: gvec4u) = v.yw;
fn ag(v: gvec4u) = v.wy;
fn ba(v: gvec4u) = v.zw;
fn ab(v: gvec4u) = v.wz;

// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
fn xyz(v: gvec4u) = gProp{gvec4u, gvec3u}('xyz', v); // 123
fn xyw(v: gvec4u) = gProp{gvec4u, gvec3u}('xyw', v); // 124
fn xzy(v: gvec4u) = gProp{gvec4u, gvec3u}('xzy', v); // 132
fn xzw(v: gvec4u) = gProp{gvec4u, gvec3u}('xzw', v); // 134
fn xwy(v: gvec4u) = gProp{gvec4u, gvec3u}('xwy', v); // 142
fn xwz(v: gvec4u) = gProp{gvec4u, gvec3u}('xwz', v); // 143
fn yxz(v: gvec4u) = gProp{gvec4u, gvec3u}('yxz', v); // 213
fn yxw(v: gvec4u) = gProp{gvec4u, gvec3u}('yxw', v); // 214
fn yzx(v: gvec4u) = gProp{gvec4u, gvec3u}('yzx', v); // 231
fn yzw(v: gvec4u) = gProp{gvec4u, gvec3u}('yzw', v); // 234
fn ywx(v: gvec4u) = gProp{gvec4u, gvec3u}('ywx', v); // 241
fn ywz(v: gvec4u) = gProp{gvec4u, gvec3u}('ywz', v); // 243
fn zxy(v: gvec4u) = gProp{gvec4u, gvec3u}('zxy', v); // 312
fn zxw(v: gvec4u) = gProp{gvec4u, gvec3u}('zxw', v); // 314
fn zyx(v: gvec4u) = gProp{gvec4u, gvec3u}('zyx', v); // 321
fn zyw(v: gvec4u) = gProp{gvec4u, gvec3u}('zyw', v); // 324
fn zwx(v: gvec4u) = gProp{gvec4u, gvec3u}('zwx', v); // 341
fn zwy(v: gvec4u) = gProp{gvec4u, gvec3u}('zwy', v); // 342
fn wxy(v: gvec4u) = gProp{gvec4u, gvec3u}('wxy', v); // 412
fn wxz(v: gvec4u) = gProp{gvec4u, gvec3u}('wxz', v); // 413
fn wyx(v: gvec4u) = gProp{gvec4u, gvec3u}('wyx', v); // 421
fn wyz(v: gvec4u) = gProp{gvec4u, gvec3u}('wyz', v); // 423
fn wzx(v: gvec4u) = gProp{gvec4u, gvec3u}('wzx', v); // 431
fn wzy(v: gvec4u) = gProp{gvec4u, gvec3u}('wzy', v); // 432
fn ijk(v: gvec4u) = v.xyz;
fn ijl(v: gvec4u) = v.xyw;
fn ikj(v: gvec4u) = v.xzy;
fn ikl(v: gvec4u) = v.xzw;
fn ilj(v: gvec4u) = v.xwy;
fn ilk(v: gvec4u) = v.xwz;
fn jik(v: gvec4u) = v.yxz;
fn jil(v: gvec4u) = v.yxw;
fn jki(v: gvec4u) = v.yzx;
fn jkl(v: gvec4u) = v.yzw;
fn jli(v: gvec4u) = v.ywx;
fn jlk(v: gvec4u) = v.ywz;
fn kij(v: gvec4u) = v.zxy;
fn kil(v: gvec4u) = v.zxw;
fn kji(v: gvec4u) = v.zyx;
fn kjl(v: gvec4u) = v.zyw;
fn kli(v: gvec4u) = v.zwx;
fn klj(v: gvec4u) = v.zwy;
fn lij(v: gvec4u) = v.wxy;
fn lik(v: gvec4u) = v.wxz;
fn lji(v: gvec4u) = v.wyx;
fn ljk(v: gvec4u) = v.wyz;
fn lki(v: gvec4u) = v.wzx;
fn lkj(v: gvec4u) = v.wzy;
fn rgb(v: gvec4u) = v.xyz;
fn rga(v: gvec4u) = v.xyw;
fn rbg(v: gvec4u) = v.xzy;
fn rba(v: gvec4u) = v.xzw;
fn rag(v: gvec4u) = v.xwy;
fn rab(v: gvec4u) = v.xwz;
fn grb(v: gvec4u) = v.yxz;
fn gra(v: gvec4u) = v.yxw;
fn gbr(v: gvec4u) = v.yzx;
fn gba(v: gvec4u) = v.yzw;
fn gar(v: gvec4u) = v.ywx;
fn gab(v: gvec4u) = v.ywz;
fn brg(v: gvec4u) = v.zxy;
fn bra(v: gvec4u) = v.zxw;
fn bgr(v: gvec4u) = v.zyx;
fn bga(v: gvec4u) = v.zyw;
fn bar(v: gvec4u) = v.zwx;
fn bag(v: gvec4u) = v.zwy;
fn arb(v: gvec4u) = v.wxy;
fn arg(v: gvec4u) = v.wxz;
fn abr(v: gvec4u) = v.wyx;
fn abg(v: gvec4u) = v.wyz;
fn agr(v: gvec4u) = v.wzx;
fn agb(v: gvec4u) = v.wzy;

fn xyzw(v: gvec4u) = gProp('xyzw', v); // 1234
fn xywz(v: gvec4u) = gProp('xywz', v); // 1243
fn xzyw(v: gvec4u) = gProp('xzyw', v); // 1324
fn xzwy(v: gvec4u) = gProp('xzwy', v); // 1342
fn xwyz(v: gvec4u) = gProp('xwyz', v); // 1423
fn xwzy(v: gvec4u) = gProp('xwzy', v); // 1432
fn yxzw(v: gvec4u) = gProp('yxzw', v); // 2134
fn yxwz(v: gvec4u) = gProp('yxwz', v); // 2143
fn yzxw(v: gvec4u) = gProp('yzxw', v); // 2314
fn yzwx(v: gvec4u) = gProp('yzwx', v); // 2341
fn ywxz(v: gvec4u) = gProp('ywxz', v); // 2413
fn ywzx(v: gvec4u) = gProp('ywzx', v); // 2431
fn zxyw(v: gvec4u) = gProp('zxyw', v); // 3124
fn zxwy(v: gvec4u) = gProp('zxwy', v); // 3142
fn zyxw(v: gvec4u) = gProp('zyxw', v); // 3214
fn zywx(v: gvec4u) = gProp('zywx', v); // 3241
fn zwxy(v: gvec4u) = gProp('zwxy', v); // 3412
fn zwyx(v: gvec4u) = gProp('zwyx', v); // 3421
fn wxyz(v: gvec4u) = gProp('wxyz', v); // 4123
fn wxzy(v: gvec4u) = gProp('wxzy', v); // 4132
fn wyxz(v: gvec4u) = gProp('wyxz', v); // 4213
fn wyzx(v: gvec4u) = gProp('wyzx', v); // 4231
fn wzxy(v: gvec4u) = gProp('wzxy', v); // 4312
fn wzyx(v: gvec4u) = gProp('wzyx', v); // 4321
fn ijkl(v: gvec4u) = v.xyzw;
fn ijlk(v: gvec4u) = v.xywz;
fn ikjl(v: gvec4u) = v.xzyw;
fn iklj(v: gvec4u) = v.xzwy;
fn iljk(v: gvec4u) = v.xwyz;
fn ilkj(v: gvec4u) = v.xwzy;
fn jikl(v: gvec4u) = v.yxzw;
fn jilk(v: gvec4u) = v.yxwz;
fn jkil(v: gvec4u) = v.yzxw;
fn jkli(v: gvec4u) = v.yzwx;
fn jlik(v: gvec4u) = v.ywxz;
fn jlki(v: gvec4u) = v.ywzx;
fn kijl(v: gvec4u) = v.zxyw;
fn kilj(v: gvec4u) = v.zxwy;
fn kjil(v: gvec4u) = v.zyxw;
fn kjli(v: gvec4u) = v.zywx;
fn klij(v: gvec4u) = v.zwxy;
fn klji(v: gvec4u) = v.zwyx;
fn lijk(v: gvec4u) = v.wxyz;
fn likj(v: gvec4u) = v.wxzy;
fn ljik(v: gvec4u) = v.wyxz;
fn ljki(v: gvec4u) = v.wyzx;
fn lkij(v: gvec4u) = v.wzxy;
fn lkji(v: gvec4u) = v.wzyx;
fn rgba(v: gvec4u) = v.xyzw;
fn rgab(v: gvec4u) = v.xywz;
fn rbga(v: gvec4u) = v.xzyw;
fn rbag(v: gvec4u) = v.xzwy;
fn ragb(v: gvec4u) = v.xwyz;
fn rabg(v: gvec4u) = v.xwzy;
fn grba(v: gvec4u) = v.yxzw;
fn grab(v: gvec4u) = v.yxwz;
fn gbra(v: gvec4u) = v.yzxw;
fn gbar(v: gvec4u) = v.yzwx;
fn garb(v: gvec4u) = v.ywxz;
fn gabr(v: gvec4u) = v.ywzx;
fn argb(v: gvec4u) = v.wxyz;
fn arbg(v: gvec4u) = v.wxzy;
fn agrb(v: gvec4u) = v.wyxz;
fn agbr(v: gvec4u) = v.wyzx;
fn abrg(v: gvec4u) = v.wzxy;
fn abgr(v: gvec4u) = v.wzyx;

fn x(v: gvec4i) = gProp{gvec4i, gi32}('x', v);
fn y(v: gvec4i) = gProp{gvec4i, gi32}('y', v);
fn z(v: gvec4i) = gProp{gvec4i, gi32}('z', v);
fn w(v: gvec4i) = gProp{gvec4i, gi32}('w', v);
fn i(v: gvec4i) = v.x;
fn j(v: gvec4i) = v.y;
fn k(v: gvec4i) = v.z;
fn l(v: gvec4i) = v.w;
fn r(v: gvec4i) = v.x;
fn g(v: gvec4i) = v.y;
fn b(v: gvec4i) = v.z;
fn a(v: gvec4i) = v.w;

fn xy(v: gvec4i) = gProp{gvec4i, gvec2i}('xy', v);
fn yx(v: gvec4i) = gProp{gvec4i, gvec2i}('yx', v);
fn xz(v: gvec4i) = gProp{gvec4i, gvec2i}('xz', v);
fn zx(v: gvec4i) = gProp{gvec4i, gvec2i}('zx', v);
fn xw(v: gvec4i) = gProp{gvec4i, gvec2i}('xw', v);
fn wx(v: gvec4i) = gProp{gvec4i, gvec2i}('wx', v);
fn yz(v: gvec4i) = gProp{gvec4i, gvec2i}('yz', v);
fn zy(v: gvec4i) = gProp{gvec4i, gvec2i}('zy', v);
fn yw(v: gvec4i) = gProp{gvec4i, gvec2i}('yw', v);
fn wy(v: gvec4i) = gProp{gvec4i, gvec2i}('wy', v);
fn zw(v: gvec4i) = gProp{gvec4i, gvec2i}('zw', v);
fn wz(v: gvec4i) = gProp{gvec4i, gvec2i}('wz', v);
fn ij(v: gvec4i) = v.xy;
fn ji(v: gvec4i) = v.yx;
fn ik(v: gvec4i) = v.xz;
fn ki(v: gvec4i) = v.zx;
fn il(v: gvec4i) = v.xw;
fn li(v: gvec4i) = v.wx;
fn jk(v: gvec4i) = v.yz;
fn kj(v: gvec4i) = v.zy;
fn jl(v: gvec4i) = v.yw;
fn lj(v: gvec4i) = v.wy;
fn kl(v: gvec4i) = v.zw;
fn lk(v: gvec4i) = v.wz;
fn rg(v: gvec4i) = v.xy;
fn gr(v: gvec4i) = v.yx;
fn rb(v: gvec4i) = v.xz;
fn br(v: gvec4i) = v.zx;
fn ra(v: gvec4i) = v.xw;
fn ar(v: gvec4i) = v.wx;
fn gb(v: gvec4i) = v.yz;
fn bg(v: gvec4i) = v.zy;
fn ga(v: gvec4i) = v.yw;
fn ag(v: gvec4i) = v.wy;
fn ba(v: gvec4i) = v.zw;
fn ab(v: gvec4i) = v.wz;

fn xyz(v: gvec4i) = gProp{gvec4i, gvec3i}('xyz', v); // 123
fn xyw(v: gvec4i) = gProp{gvec4i, gvec3i}('xyw', v); // 124
fn xzy(v: gvec4i) = gProp{gvec4i, gvec3i}('xzy', v); // 132
fn xzw(v: gvec4i) = gProp{gvec4i, gvec3i}('xzw', v); // 134
fn xwy(v: gvec4i) = gProp{gvec4i, gvec3i}('xwy', v); // 142
fn xwz(v: gvec4i) = gProp{gvec4i, gvec3i}('xwz', v); // 143
fn yxz(v: gvec4i) = gProp{gvec4i, gvec3i}('yxz', v); // 213
fn yxw(v: gvec4i) = gProp{gvec4i, gvec3i}('yxw', v); // 214
fn yzx(v: gvec4i) = gProp{gvec4i, gvec3i}('yzx', v); // 231
fn yzw(v: gvec4i) = gProp{gvec4i, gvec3i}('yzw', v); // 234
fn ywx(v: gvec4i) = gProp{gvec4i, gvec3i}('ywx', v); // 241
fn ywz(v: gvec4i) = gProp{gvec4i, gvec3i}('ywz', v); // 243
fn zxy(v: gvec4i) = gProp{gvec4i, gvec3i}('zxy', v); // 312
fn zxw(v: gvec4i) = gProp{gvec4i, gvec3i}('zxw', v); // 314
fn zyx(v: gvec4i) = gProp{gvec4i, gvec3i}('zyx', v); // 321
fn zyw(v: gvec4i) = gProp{gvec4i, gvec3i}('zyw', v); // 324
fn zwx(v: gvec4i) = gProp{gvec4i, gvec3i}('zwx', v); // 341
fn zwy(v: gvec4i) = gProp{gvec4i, gvec3i}('zwy', v); // 342
fn wxy(v: gvec4i) = gProp{gvec4i, gvec3i}('wxy', v); // 412
fn wxz(v: gvec4i) = gProp{gvec4i, gvec3i}('wxz', v); // 413
fn wyx(v: gvec4i) = gProp{gvec4i, gvec3i}('wyx', v); // 421
fn wyz(v: gvec4i) = gProp{gvec4i, gvec3i}('wyz', v); // 423
fn wzx(v: gvec4i) = gProp{gvec4i, gvec3i}('wzx', v); // 431
fn wzy(v: gvec4i) = gProp{gvec4i, gvec3i}('wzy', v); // 432
fn ijk(v: gvec4i) = v.xyz;
fn ijl(v: gvec4i) = v.xyw;
fn ikj(v: gvec4i) = v.xzy;
fn ikl(v: gvec4i) = v.xzw;
fn ilj(v: gvec4i) = v.xwy;
fn ilk(v: gvec4i) = v.xwz;
fn jik(v: gvec4i) = v.yxz;
fn jil(v: gvec4i) = v.yxw;
fn jki(v: gvec4i) = v.yzx;
fn jkl(v: gvec4i) = v.yzw;
fn jli(v: gvec4i) = v.ywx;
fn jlk(v: gvec4i) = v.ywz;
fn kij(v: gvec4i) = v.zxy;
fn kil(v: gvec4i) = v.zxw;
fn kji(v: gvec4i) = v.zyx;
fn kjl(v: gvec4i) = v.zyw;
fn kli(v: gvec4i) = v.zwx;
fn klj(v: gvec4i) = v.zwy;
fn lij(v: gvec4i) = v.wxy;
fn lik(v: gvec4i) = v.wxz;
fn lji(v: gvec4i) = v.wyx;
fn ljk(v: gvec4i) = v.wyz;
fn lki(v: gvec4i) = v.wzx;
fn lkj(v: gvec4i) = v.wzy;
fn rgb(v: gvec4i) = v.xyz;
fn rga(v: gvec4i) = v.xyw;
fn rbg(v: gvec4i) = v.xzy;
fn rba(v: gvec4i) = v.xzw;
fn rag(v: gvec4i) = v.xwy;
fn rab(v: gvec4i) = v.xwz;
fn grb(v: gvec4i) = v.yxz;
fn gra(v: gvec4i) = v.yxw;
fn gbr(v: gvec4i) = v.yzx;
fn gba(v: gvec4i) = v.yzw;
fn gar(v: gvec4i) = v.ywx;
fn gab(v: gvec4i) = v.ywz;
fn brg(v: gvec4i) = v.zxy;
fn bra(v: gvec4i) = v.zxw;
fn bgr(v: gvec4i) = v.zyx;
fn bga(v: gvec4i) = v.zyw;
fn bar(v: gvec4i) = v.zwx;
fn bag(v: gvec4i) = v.zwy;
fn arb(v: gvec4i) = v.wxy;
fn arg(v: gvec4i) = v.wxz;
fn abr(v: gvec4i) = v.wyx;
fn abg(v: gvec4i) = v.wyz;
fn agr(v: gvec4i) = v.wzx;
fn agb(v: gvec4i) = v.wzy;

fn xyzw(v: gvec4i) = gProp('xyzw', v); // 1234
fn xywz(v: gvec4i) = gProp('xywz', v); // 1243
fn xzyw(v: gvec4i) = gProp('xzyw', v); // 1324
fn xzwy(v: gvec4i) = gProp('xzwy', v); // 1342
fn xwyz(v: gvec4i) = gProp('xwyz', v); // 1423
fn xwzy(v: gvec4i) = gProp('xwzy', v); // 1432
fn yxzw(v: gvec4i) = gProp('yxzw', v); // 2134
fn yxwz(v: gvec4i) = gProp('yxwz', v); // 2143
fn yzxw(v: gvec4i) = gProp('yzxw', v); // 2314
fn yzwx(v: gvec4i) = gProp('yzwx', v); // 2341
fn ywxz(v: gvec4i) = gProp('ywxz', v); // 2413
fn ywzx(v: gvec4i) = gProp('ywzx', v); // 2431
fn zxyw(v: gvec4i) = gProp('zxyw', v); // 3124
fn zxwy(v: gvec4i) = gProp('zxwy', v); // 3142
fn zyxw(v: gvec4i) = gProp('zyxw', v); // 3214
fn zywx(v: gvec4i) = gProp('zywx', v); // 3241
fn zwxy(v: gvec4i) = gProp('zwxy', v); // 3412
fn zwyx(v: gvec4i) = gProp('zwyx', v); // 3421
fn wxyz(v: gvec4i) = gProp('wxyz', v); // 4123
fn wxzy(v: gvec4i) = gProp('wxzy', v); // 4132
fn wyxz(v: gvec4i) = gProp('wyxz', v); // 4213
fn wyzx(v: gvec4i) = gProp('wyzx', v); // 4231
fn wzxy(v: gvec4i) = gProp('wzxy', v); // 4312
fn wzyx(v: gvec4i) = gProp('wzyx', v); // 4321
fn ijkl(v: gvec4i) = v.xyzw;
fn ijlk(v: gvec4i) = v.xywz;
fn ikjl(v: gvec4i) = v.xzyw;
fn iklj(v: gvec4i) = v.xzwy;
fn iljk(v: gvec4i) = v.xwyz;
fn ilkj(v: gvec4i) = v.xwzy;
fn jikl(v: gvec4i) = v.yxzw;
fn jilk(v: gvec4i) = v.yxwz;
fn jkil(v: gvec4i) = v.yzxw;
fn jkli(v: gvec4i) = v.yzwx;
fn jlik(v: gvec4i) = v.ywxz;
fn jlki(v: gvec4i) = v.ywzx;
fn kijl(v: gvec4i) = v.zxyw;
fn kilj(v: gvec4i) = v.zxwy;
fn kjil(v: gvec4i) = v.zyxw;
fn kjli(v: gvec4i) = v.zywx;
fn klij(v: gvec4i) = v.zwxy;
fn klji(v: gvec4i) = v.zwyx;
fn lijk(v: gvec4i) = v.wxyz;
fn likj(v: gvec4i) = v.wxzy;
fn ljik(v: gvec4i) = v.wyxz;
fn ljki(v: gvec4i) = v.wyzx;
fn lkij(v: gvec4i) = v.wzxy;
fn lkji(v: gvec4i) = v.wzyx;
fn rgba(v: gvec4i) = v.xyzw;
fn rgab(v: gvec4i) = v.xywz;
fn rbga(v: gvec4i) = v.xzyw;
fn rbag(v: gvec4i) = v.xzwy;
fn ragb(v: gvec4i) = v.xwyz;
fn rabg(v: gvec4i) = v.xwzy;
fn grba(v: gvec4i) = v.yxzw;
fn grab(v: gvec4i) = v.yxwz;
fn gbra(v: gvec4i) = v.yzxw;
fn gbar(v: gvec4i) = v.yzwx;
fn garb(v: gvec4i) = v.ywxz;
fn gabr(v: gvec4i) = v.ywzx;
fn argb(v: gvec4i) = v.wxyz;
fn arbg(v: gvec4i) = v.wxzy;
fn agrb(v: gvec4i) = v.wyxz;
fn agbr(v: gvec4i) = v.wyzx;
fn abrg(v: gvec4i) = v.wzxy;
fn abgr(v: gvec4i) = v.wzyx;

fn x(v: gvec4f) = gProp{gvec4f, gf32}('x', v);
fn y(v: gvec4f) = gProp{gvec4f, gf32}('y', v);
fn z(v: gvec4f) = gProp{gvec4f, gf32}('z', v);
fn w(v: gvec4f) = gProp{gvec4f, gf32}('w', v);
fn i(v: gvec4f) = v.x;
fn j(v: gvec4f) = v.y;
fn k(v: gvec4f) = v.z;
fn l(v: gvec4f) = v.w;
fn r(v: gvec4f) = v.x;
fn g(v: gvec4f) = v.y;
fn b(v: gvec4f) = v.z;
fn a(v: gvec4f) = v.w;

fn xy(v: gvec4f) = gProp{gvec4f, gvec2f}('xy', v);
fn yx(v: gvec4f) = gProp{gvec4f, gvec2f}('yx', v);
fn xz(v: gvec4f) = gProp{gvec4f, gvec2f}('xz', v);
fn zx(v: gvec4f) = gProp{gvec4f, gvec2f}('zx', v);
fn xw(v: gvec4f) = gProp{gvec4f, gvec2f}('xw', v);
fn wx(v: gvec4f) = gProp{gvec4f, gvec2f}('wx', v);
fn yz(v: gvec4f) = gProp{gvec4f, gvec2f}('yz', v);
fn zy(v: gvec4f) = gProp{gvec4f, gvec2f}('zy', v);
fn yw(v: gvec4f) = gProp{gvec4f, gvec2f}('yw', v);
fn wy(v: gvec4f) = gProp{gvec4f, gvec2f}('wy', v);
fn zw(v: gvec4f) = gProp{gvec4f, gvec2f}('zw', v);
fn wz(v: gvec4f) = gProp{gvec4f, gvec2f}('wz', v);
fn ij(v: gvec4f) = v.xy;
fn ji(v: gvec4f) = v.yx;
fn ik(v: gvec4f) = v.xz;
fn ki(v: gvec4f) = v.zx;
fn il(v: gvec4f) = v.xw;
fn li(v: gvec4f) = v.wx;
fn jk(v: gvec4f) = v.yz;
fn kj(v: gvec4f) = v.zy;
fn jl(v: gvec4f) = v.yw;
fn lj(v: gvec4f) = v.wy;
fn kl(v: gvec4f) = v.zw;
fn lk(v: gvec4f) = v.wz;
fn rg(v: gvec4f) = v.xy;
fn gr(v: gvec4f) = v.yx;
fn rb(v: gvec4f) = v.xz;
fn br(v: gvec4f) = v.zx;
fn ra(v: gvec4f) = v.xw;
fn ar(v: gvec4f) = v.wx;
fn gb(v: gvec4f) = v.yz;
fn bg(v: gvec4f) = v.zy;
fn ga(v: gvec4f) = v.yw;
fn ag(v: gvec4f) = v.wy;
fn ba(v: gvec4f) = v.zw;
fn ab(v: gvec4f) = v.wz;

fn xyz(v: gvec4f) = gProp{gvec4f, gvec3f}('xyz', v); // 123
fn xyw(v: gvec4f) = gProp{gvec4f, gvec3f}('xyw', v); // 124
fn xzy(v: gvec4f) = gProp{gvec4f, gvec3f}('xzy', v); // 132
fn xzw(v: gvec4f) = gProp{gvec4f, gvec3f}('xzw', v); // 134
fn xwy(v: gvec4f) = gProp{gvec4f, gvec3f}('xwy', v); // 142
fn xwz(v: gvec4f) = gProp{gvec4f, gvec3f}('xwz', v); // 143
fn yxz(v: gvec4f) = gProp{gvec4f, gvec3f}('yxz', v); // 213
fn yxw(v: gvec4f) = gProp{gvec4f, gvec3f}('yxw', v); // 214
fn yzx(v: gvec4f) = gProp{gvec4f, gvec3f}('yzx', v); // 231
fn yzw(v: gvec4f) = gProp{gvec4f, gvec3f}('yzw', v); // 234
fn ywx(v: gvec4f) = gProp{gvec4f, gvec3f}('ywx', v); // 241
fn ywz(v: gvec4f) = gProp{gvec4f, gvec3f}('ywz', v); // 243
fn zxy(v: gvec4f) = gProp{gvec4f, gvec3f}('zxy', v); // 312
fn zxw(v: gvec4f) = gProp{gvec4f, gvec3f}('zxw', v); // 314
fn zyx(v: gvec4f) = gProp{gvec4f, gvec3f}('zyx', v); // 321
fn zyw(v: gvec4f) = gProp{gvec4f, gvec3f}('zyw', v); // 324
fn zwx(v: gvec4f) = gProp{gvec4f, gvec3f}('zwx', v); // 341
fn zwy(v: gvec4f) = gProp{gvec4f, gvec3f}('zwy', v); // 342
fn wxy(v: gvec4f) = gProp{gvec4f, gvec3f}('wxy', v); // 412
fn wxz(v: gvec4f) = gProp{gvec4f, gvec3f}('wxz', v); // 413
fn wyx(v: gvec4f) = gProp{gvec4f, gvec3f}('wyx', v); // 421
fn wyz(v: gvec4f) = gProp{gvec4f, gvec3f}('wyz', v); // 423
fn wzx(v: gvec4f) = gProp{gvec4f, gvec3f}('wzx', v); // 431
fn wzy(v: gvec4f) = gProp{gvec4f, gvec3f}('wzy', v); // 432
fn ijk(v: gvec4f) = v.xyz;
fn ijl(v: gvec4f) = v.xyw;
fn ikj(v: gvec4f) = v.xzy;
fn ikl(v: gvec4f) = v.xzw;
fn ilj(v: gvec4f) = v.xwy;
fn ilk(v: gvec4f) = v.xwz;
fn jik(v: gvec4f) = v.yxz;
fn jil(v: gvec4f) = v.yxw;
fn jki(v: gvec4f) = v.yzx;
fn jkl(v: gvec4f) = v.yzw;
fn jli(v: gvec4f) = v.ywx;
fn jlk(v: gvec4f) = v.ywz;
fn kij(v: gvec4f) = v.zxy;
fn kil(v: gvec4f) = v.zxw;
fn kji(v: gvec4f) = v.zyx;
fn kjl(v: gvec4f) = v.zyw;
fn kli(v: gvec4f) = v.zwx;
fn klj(v: gvec4f) = v.zwy;
fn lij(v: gvec4f) = v.wxy;
fn lik(v: gvec4f) = v.wxz;
fn lji(v: gvec4f) = v.wyx;
fn ljk(v: gvec4f) = v.wyz;
fn lki(v: gvec4f) = v.wzx;
fn lkj(v: gvec4f) = v.wzy;
fn rgb(v: gvec4f) = v.xyz;
fn rga(v: gvec4f) = v.xyw;
fn rbg(v: gvec4f) = v.xzy;
fn rba(v: gvec4f) = v.xzw;
fn rag(v: gvec4f) = v.xwy;
fn rab(v: gvec4f) = v.xwz;
fn grb(v: gvec4f) = v.yxz;
fn gra(v: gvec4f) = v.yxw;
fn gbr(v: gvec4f) = v.yzx;
fn gba(v: gvec4f) = v.yzw;
fn gar(v: gvec4f) = v.ywx;
fn gab(v: gvec4f) = v.ywz;
fn brg(v: gvec4f) = v.zxy;
fn bra(v: gvec4f) = v.zxw;
fn bgr(v: gvec4f) = v.zyx;
fn bga(v: gvec4f) = v.zyw;
fn bar(v: gvec4f) = v.zwx;
fn bag(v: gvec4f) = v.zwy;
fn arb(v: gvec4f) = v.wxy;
fn arg(v: gvec4f) = v.wxz;
fn abr(v: gvec4f) = v.wyx;
fn abg(v: gvec4f) = v.wyz;
fn agr(v: gvec4f) = v.wzx;
fn agb(v: gvec4f) = v.wzy;

fn xyzw(v: gvec4f) = gProp('xyzw', v); // 1234
fn xywz(v: gvec4f) = gProp('xywz', v); // 1243
fn xzyw(v: gvec4f) = gProp('xzyw', v); // 1324
fn xzwy(v: gvec4f) = gProp('xzwy', v); // 1342
fn xwyz(v: gvec4f) = gProp('xwyz', v); // 1423
fn xwzy(v: gvec4f) = gProp('xwzy', v); // 1432
fn yxzw(v: gvec4f) = gProp('yxzw', v); // 2134
fn yxwz(v: gvec4f) = gProp('yxwz', v); // 2143
fn yzxw(v: gvec4f) = gProp('yzxw', v); // 2314
fn yzwx(v: gvec4f) = gProp('yzwx', v); // 2341
fn ywxz(v: gvec4f) = gProp('ywxz', v); // 2413
fn ywzx(v: gvec4f) = gProp('ywzx', v); // 2431
fn zxyw(v: gvec4f) = gProp('zxyw', v); // 3124
fn zxwy(v: gvec4f) = gProp('zxwy', v); // 3142
fn zyxw(v: gvec4f) = gProp('zyxw', v); // 3214
fn zywx(v: gvec4f) = gProp('zywx', v); // 3241
fn zwxy(v: gvec4f) = gProp('zwxy', v); // 3412
fn zwyx(v: gvec4f) = gProp('zwyx', v); // 3421
fn wxyz(v: gvec4f) = gProp('wxyz', v); // 4123
fn wxzy(v: gvec4f) = gProp('wxzy', v); // 4132
fn wyxz(v: gvec4f) = gProp('wyxz', v); // 4213
fn wyzx(v: gvec4f) = gProp('wyzx', v); // 4231
fn wzxy(v: gvec4f) = gProp('wzxy', v); // 4312
fn wzyx(v: gvec4f) = gProp('wzyx', v); // 4321
fn ijkl(v: gvec4f) = v.xyzw;
fn ijlk(v: gvec4f) = v.xywz;
fn ikjl(v: gvec4f) = v.xzyw;
fn iklj(v: gvec4f) = v.xzwy;
fn iljk(v: gvec4f) = v.xwyz;
fn ilkj(v: gvec4f) = v.xwzy;
fn jikl(v: gvec4f) = v.yxzw;
fn jilk(v: gvec4f) = v.yxwz;
fn jkil(v: gvec4f) = v.yzxw;
fn jkli(v: gvec4f) = v.yzwx;
fn jlik(v: gvec4f) = v.ywxz;
fn jlki(v: gvec4f) = v.ywzx;
fn kijl(v: gvec4f) = v.zxyw;
fn kilj(v: gvec4f) = v.zxwy;
fn kjil(v: gvec4f) = v.zyxw;
fn kjli(v: gvec4f) = v.zywx;
fn klij(v: gvec4f) = v.zwxy;
fn klji(v: gvec4f) = v.zwyx;
fn lijk(v: gvec4f) = v.wxyz;
fn likj(v: gvec4f) = v.wxzy;
fn ljik(v: gvec4f) = v.wyxz;
fn ljki(v: gvec4f) = v.wyzx;
fn lkij(v: gvec4f) = v.wzxy;
fn lkji(v: gvec4f) = v.wzyx;
fn rgba(v: gvec4f) = v.xyzw;
fn rgab(v: gvec4f) = v.xywz;
fn rbga(v: gvec4f) = v.xzyw;
fn rbag(v: gvec4f) = v.xzwy;
fn ragb(v: gvec4f) = v.xwyz;
fn rabg(v: gvec4f) = v.xwzy;
fn grba(v: gvec4f) = v.yxzw;
fn grab(v: gvec4f) = v.yxwz;
fn gbra(v: gvec4f) = v.yzxw;
fn gbar(v: gvec4f) = v.yzwx;
fn garb(v: gvec4f) = v.ywxz;
fn gabr(v: gvec4f) = v.ywzx;
fn argb(v: gvec4f) = v.wxyz;
fn arbg(v: gvec4f) = v.wxzy;
fn agrb(v: gvec4f) = v.wyxz;
fn agbr(v: gvec4f) = v.wyzx;
fn abrg(v: gvec4f) = v.wzxy;
fn abgr(v: gvec4f) = v.wzyx;

fn x(v: gvec4b) = gProp{gvec4b, gbool}('x', v);
fn y(v: gvec4b) = gProp{gvec4b, gbool}('y', v);
fn z(v: gvec4b) = gProp{gvec4b, gbool}('z', v);
fn w(v: gvec4b) = gProp{gvec4b, gbool}('w', v);
fn i(v: gvec4b) = v.x;
fn j(v: gvec4b) = v.y;
fn k(v: gvec4b) = v.z;
fn l(v: gvec4b) = v.w;
fn r(v: gvec4b) = v.x;
fn g(v: gvec4b) = v.y;
fn b(v: gvec4b) = v.z;
fn a(v: gvec4b) = v.w;

fn xy(v: gvec4b) = gProp{gvec4b, gvec2b}('xy', v);
fn yx(v: gvec4b) = gProp{gvec4b, gvec2b}('yx', v);
fn xz(v: gvec4b) = gProp{gvec4b, gvec2b}('xz', v);
fn zx(v: gvec4b) = gProp{gvec4b, gvec2b}('zx', v);
fn xw(v: gvec4b) = gProp{gvec4b, gvec2b}('xw', v);
fn wx(v: gvec4b) = gProp{gvec4b, gvec2b}('wx', v);
fn yz(v: gvec4b) = gProp{gvec4b, gvec2b}('yz', v);
fn zy(v: gvec4b) = gProp{gvec4b, gvec2b}('zy', v);
fn yw(v: gvec4b) = gProp{gvec4b, gvec2b}('yw', v);
fn wy(v: gvec4b) = gProp{gvec4b, gvec2b}('wy', v);
fn zw(v: gvec4b) = gProp{gvec4b, gvec2b}('zw', v);
fn wz(v: gvec4b) = gProp{gvec4b, gvec2b}('wz', v);
fn ij(v: gvec4b) = v.xy;
fn ji(v: gvec4b) = v.yx;
fn ik(v: gvec4b) = v.xz;
fn ki(v: gvec4b) = v.zx;
fn il(v: gvec4b) = v.xw;
fn li(v: gvec4b) = v.wx;
fn jk(v: gvec4b) = v.yz;
fn kj(v: gvec4b) = v.zy;
fn jl(v: gvec4b) = v.yw;
fn lj(v: gvec4b) = v.wy;
fn kl(v: gvec4b) = v.zw;
fn lk(v: gvec4b) = v.wz;
fn rg(v: gvec4b) = v.xy;
fn gr(v: gvec4b) = v.yx;
fn rb(v: gvec4b) = v.xz;
fn br(v: gvec4b) = v.zx;
fn ra(v: gvec4b) = v.xw;
fn ar(v: gvec4b) = v.wx;
fn gb(v: gvec4b) = v.yz;
fn bg(v: gvec4b) = v.zy;
fn ga(v: gvec4b) = v.yw;
fn ag(v: gvec4b) = v.wy;
fn ba(v: gvec4b) = v.zw;
fn ab(v: gvec4b) = v.wz;

fn xyz(v: gvec4b) = gProp{gvec4b, gvec3b}('xyz', v); // 123
fn xyw(v: gvec4b) = gProp{gvec4b, gvec3b}('xyw', v); // 124
fn xzy(v: gvec4b) = gProp{gvec4b, gvec3b}('xzy', v); // 132
fn xzw(v: gvec4b) = gProp{gvec4b, gvec3b}('xzw', v); // 134
fn xwy(v: gvec4b) = gProp{gvec4b, gvec3b}('xwy', v); // 142
fn xwz(v: gvec4b) = gProp{gvec4b, gvec3b}('xwz', v); // 143
fn yxz(v: gvec4b) = gProp{gvec4b, gvec3b}('yxz', v); // 213
fn yxw(v: gvec4b) = gProp{gvec4b, gvec3b}('yxw', v); // 214
fn yzx(v: gvec4b) = gProp{gvec4b, gvec3b}('yzx', v); // 231
fn yzw(v: gvec4b) = gProp{gvec4b, gvec3b}('yzw', v); // 234
fn ywx(v: gvec4b) = gProp{gvec4b, gvec3b}('ywx', v); // 241
fn ywz(v: gvec4b) = gProp{gvec4b, gvec3b}('ywz', v); // 243
fn zxy(v: gvec4b) = gProp{gvec4b, gvec3b}('zxy', v); // 312
fn zxw(v: gvec4b) = gProp{gvec4b, gvec3b}('zxw', v); // 314
fn zyx(v: gvec4b) = gProp{gvec4b, gvec3b}('zyx', v); // 321
fn zyw(v: gvec4b) = gProp{gvec4b, gvec3b}('zyw', v); // 324
fn zwx(v: gvec4b) = gProp{gvec4b, gvec3b}('zwx', v); // 341
fn zwy(v: gvec4b) = gProp{gvec4b, gvec3b}('zwy', v); // 342
fn wxy(v: gvec4b) = gProp{gvec4b, gvec3b}('wxy', v); // 412
fn wxz(v: gvec4b) = gProp{gvec4b, gvec3b}('wxz', v); // 413
fn wyx(v: gvec4b) = gProp{gvec4b, gvec3b}('wyx', v); // 421
fn wyz(v: gvec4b) = gProp{gvec4b, gvec3b}('wyz', v); // 423
fn wzx(v: gvec4b) = gProp{gvec4b, gvec3b}('wzx', v); // 431
fn wzy(v: gvec4b) = gProp{gvec4b, gvec3b}('wzy', v); // 432
fn ijk(v: gvec4b) = v.xyz;
fn ijl(v: gvec4b) = v.xyw;
fn ikj(v: gvec4b) = v.xzy;
fn ikl(v: gvec4b) = v.xzw;
fn ilj(v: gvec4b) = v.xwy;
fn ilk(v: gvec4b) = v.xwz;
fn jik(v: gvec4b) = v.yxz;
fn jil(v: gvec4b) = v.yxw;
fn jki(v: gvec4b) = v.yzx;
fn jkl(v: gvec4b) = v.yzw;
fn jli(v: gvec4b) = v.ywx;
fn jlk(v: gvec4b) = v.ywz;
fn kij(v: gvec4b) = v.zxy;
fn kil(v: gvec4b) = v.zxw;
fn kji(v: gvec4b) = v.zyx;
fn kjl(v: gvec4b) = v.zyw;
fn kli(v: gvec4b) = v.zwx;
fn klj(v: gvec4b) = v.zwy;
fn lij(v: gvec4b) = v.wxy;
fn lik(v: gvec4b) = v.wxz;
fn lji(v: gvec4b) = v.wyx;
fn ljk(v: gvec4b) = v.wyz;
fn lki(v: gvec4b) = v.wzx;
fn lkj(v: gvec4b) = v.wzy;
fn rgb(v: gvec4b) = v.xyz;
fn rga(v: gvec4b) = v.xyw;
fn rbg(v: gvec4b) = v.xzy;
fn rba(v: gvec4b) = v.xzw;
fn rag(v: gvec4b) = v.xwy;
fn rab(v: gvec4b) = v.xwz;
fn grb(v: gvec4b) = v.yxz;
fn gra(v: gvec4b) = v.yxw;
fn gbr(v: gvec4b) = v.yzx;
fn gba(v: gvec4b) = v.yzw;
fn gar(v: gvec4b) = v.ywx;
fn gab(v: gvec4b) = v.ywz;
fn brg(v: gvec4b) = v.zxy;
fn bra(v: gvec4b) = v.zxw;
fn bgr(v: gvec4b) = v.zyx;
fn bga(v: gvec4b) = v.zyw;
fn bar(v: gvec4b) = v.zwx;
fn bag(v: gvec4b) = v.zwy;
fn arb(v: gvec4b) = v.wxy;
fn arg(v: gvec4b) = v.wxz;
fn abr(v: gvec4b) = v.wyx;
fn abg(v: gvec4b) = v.wyz;
fn agr(v: gvec4b) = v.wzx;
fn agb(v: gvec4b) = v.wzy;

fn xyzw(v: gvec4b) = gProp('xyzw', v); // 1234
fn xywz(v: gvec4b) = gProp('xywz', v); // 1243
fn xzyw(v: gvec4b) = gProp('xzyw', v); // 1324
fn xzwy(v: gvec4b) = gProp('xzwy', v); // 1342
fn xwyz(v: gvec4b) = gProp('xwyz', v); // 1423
fn xwzy(v: gvec4b) = gProp('xwzy', v); // 1432
fn yxzw(v: gvec4b) = gProp('yxzw', v); // 2134
fn yxwz(v: gvec4b) = gProp('yxwz', v); // 2143
fn yzxw(v: gvec4b) = gProp('yzxw', v); // 2314
fn yzwx(v: gvec4b) = gProp('yzwx', v); // 2341
fn ywxz(v: gvec4b) = gProp('ywxz', v); // 2413
fn ywzx(v: gvec4b) = gProp('ywzx', v); // 2431
fn zxyw(v: gvec4b) = gProp('zxyw', v); // 3124
fn zxwy(v: gvec4b) = gProp('zxwy', v); // 3142
fn zyxw(v: gvec4b) = gProp('zyxw', v); // 3214
fn zywx(v: gvec4b) = gProp('zywx', v); // 3241
fn zwxy(v: gvec4b) = gProp('zwxy', v); // 3412
fn zwyx(v: gvec4b) = gProp('zwyx', v); // 3421
fn wxyz(v: gvec4b) = gProp('wxyz', v); // 4123
fn wxzy(v: gvec4b) = gProp('wxzy', v); // 4132
fn wyxz(v: gvec4b) = gProp('wyxz', v); // 4213
fn wyzx(v: gvec4b) = gProp('wyzx', v); // 4231
fn wzxy(v: gvec4b) = gProp('wzxy', v); // 4312
fn wzyx(v: gvec4b) = gProp('wzyx', v); // 4321
fn ijkl(v: gvec4b) = v.xyzw;
fn ijlk(v: gvec4b) = v.xywz;
fn ikjl(v: gvec4b) = v.xzyw;
fn iklj(v: gvec4b) = v.xzwy;
fn iljk(v: gvec4b) = v.xwyz;
fn ilkj(v: gvec4b) = v.xwzy;
fn jikl(v: gvec4b) = v.yxzw;
fn jilk(v: gvec4b) = v.yxwz;
fn jkil(v: gvec4b) = v.yzxw;
fn jkli(v: gvec4b) = v.yzwx;
fn jlik(v: gvec4b) = v.ywxz;
fn jlki(v: gvec4b) = v.ywzx;
fn kijl(v: gvec4b) = v.zxyw;
fn kilj(v: gvec4b) = v.zxwy;
fn kjil(v: gvec4b) = v.zyxw;
fn kjli(v: gvec4b) = v.zywx;
fn klij(v: gvec4b) = v.zwxy;
fn klji(v: gvec4b) = v.zwyx;
fn lijk(v: gvec4b) = v.wxyz;
fn likj(v: gvec4b) = v.wxzy;
fn ljik(v: gvec4b) = v.wyxz;
fn ljki(v: gvec4b) = v.wyzx;
fn lkij(v: gvec4b) = v.wzxy;
fn lkji(v: gvec4b) = v.wzyx;
fn rgba(v: gvec4b) = v.xyzw;
fn rgab(v: gvec4b) = v.xywz;
fn rbga(v: gvec4b) = v.xzyw;
fn rbag(v: gvec4b) = v.xzwy;
fn ragb(v: gvec4b) = v.xwyz;
fn rabg(v: gvec4b) = v.xwzy;
fn grba(v: gvec4b) = v.yxzw;
fn grab(v: gvec4b) = v.yxwz;
fn gbra(v: gvec4b) = v.yzxw;
fn gbar(v: gvec4b) = v.yzwx;
fn garb(v: gvec4b) = v.ywxz;
fn gabr(v: gvec4b) = v.ywzx;
fn brga(v: gvec4b) = v.zxyw;
fn brag(v: gvec4b) = v.zxwy;
fn bgra(v: gvec4b) = v.zyxw;
fn bgar(v: gvec4b) = v.zywx;
fn barg(v: gvec4b) = v.zwxy;
fn bagr(v: gvec4b) = v.zwyx;
fn argb(v: gvec4b) = v.wxyz;
fn arbg(v: gvec4b) = v.wxzy;
fn agrb(v: gvec4b) = v.wyxz;
fn agbr(v: gvec4b) = v.wyzx;
fn abrg(v: gvec4b) = v.wzxy;
fn abgr(v: gvec4b) = v.wzyx;

fn get{T}(gb: GBuffer{T}, i: gu32) {
  let varName = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(GBufferTagged(gb)));
  return {Prop{WgpuTypeMap, String{T}}}(varName, i.statements, buffers);
}
fn get{T}(gb: GBuffer{T}, i: gi32) {
  let varName = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(GBufferTagged(gb)));
  return {Prop{WgpuTypeMap, String{T}}}(varName, i.statements, buffers);
}
fn get{T}(gb: GBuffer{T}, i: i64) {
  let varName = gb.id.concat('[').concat(i.string).concat(']');
  let statements = Dict{string, string}();
  let buffers = Set(GBufferTagged(gb));
  return {Prop{WgpuTypeMap, String{T}}}(varName, statements, buffers);
}

fn store{N}(a: WgpuType{N}, b: WgpuType{N}) {
  let statement = a.varName.concat(" = ").concat(b.varName);
  let statements = a.statements.concat(b.statements).concat(Dict(statement, statement));
  let buffers = a.buffers.union(b.buffers);
  return WgpuType{N}(statement, statements, buffers);
}

/// GPGPU Math functions

fn neg(v: gi32) = gPrefix("-", "neg", v);
fn neg(v: gf32) = gPrefix("-", "neg", v);
fn neg(v: gvec2i) = gPrefix("-", "neg", v);
fn neg(v: gvec2f) = gPrefix("-", "neg", v);
fn neg(v: gvec3i) = gPrefix("-", "neg", v);
fn neg(v: gvec3f) = gPrefix("-", "neg", v);
fn neg(v: gvec4i) = gPrefix("-", "neg", v);
fn neg(v: gvec4f) = gPrefix("-", "neg", v);

fn abs(v: gi32) = gFn1("abs", v);
fn abs(v: gf32) = gFn1("abs", v);
fn abs(v: gvec2i) = gFn1("abs", v);
fn abs(v: gvec2f) = gFn1("abs", v);
fn abs(v: gvec3i) = gFn1("abs", v);
fn abs(v: gvec3f) = gFn1("abs", v);
fn abs(v: gvec4i) = gFn1("abs", v);
fn abs(v: gvec4f) = gFn1("abs", v);

fn clz(v: gi32) = gFn1("countLeadingZeros", v);
fn clz(v: gu32) = gFn1("countLeadingZeros", v);
fn clz(v: gvec2i) = gFn1("countLeadingZeros", v);
fn clz(v: gvec2u) = gFn1("countLeadingZeros", v);
fn clz(v: gvec3i) = gFn1("countLeadingZeros", v);
fn clz(v: gvec3u) = gFn1("countLeadingZeros", v);
fn clz(v: gvec4i) = gFn1("countLeadingZeros", v);
fn clz(v: gvec4u) = gFn1("countLeadingZeros", v);

fn ones(v: gi32) = gFn1("countOneBits", v);
fn ones(v: gu32) = gFn1("countOneBits", v);
fn ones(v: gvec2i) = gFn1("countOneBits", v);
fn ones(v: gvec2u) = gFn1("countOneBits", v);
fn ones(v: gvec3i) = gFn1("countOneBits", v);
fn ones(v: gvec3u) = gFn1("countOneBits", v);
fn ones(v: gvec4i) = gFn1("countOneBits", v);
fn ones(v: gvec4u) = gFn1("countOneBits", v);

fn ctz(v: gi32) = gFn1("countTrailingZeros", v);
fn ctz(v: gu32) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec2i) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec2u) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec3i) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec3u) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec4i) = gFn1("countTrailingZeros", v);
fn ctz(v: gvec4u) = gFn1("countTrailingZeros", v);

fn reverseBits(v: gi32) = gFn1("reverseBits", v);
fn reverseBits(v: gu32) = gFn1("reverseBits", v);
fn reverseBits(v: gvec2i) = gFn1("reverseBits", v);
fn reverseBits(v: gvec2u) = gFn1("reverseBits", v);
fn reverseBits(v: gvec3i) = gFn1("reverseBits", v);
fn reverseBits(v: gvec3u) = gFn1("reverseBits", v);
fn reverseBits(v: gvec4i) = gFn1("reverseBits", v);
fn reverseBits(v: gvec4u) = gFn1("reverseBits", v);

fn extractBits{A, B}(v: gu32, offset: A, count: B) =
  gFn3{gu32, gu32}("extractBits", v, offset.gu32, count.gu32);
fn extractBits{A, B}(v: gvec2u, offset: A, count: B) =
  gFn3{gvec2u, gu32, gu32, gvec2u}("extractBits", v, offset.gu32, count.gu32);
fn extractBits{A, B}(v: gvec3u, offset: A, count: B) =
  gFn3{gvec3u, gu32, gu32, gvec3u}("extractBits", v, offset.gu32, count.gu32);
fn extractBits{A, B}(v: gvec4u, offset: A, count: B) =
  gFn3{gvec4u, gu32, gu32, gvec4u}("extractBits", v, offset.gu32, count.gu32);

fn insertBits{A, B, C}(v: gu32, newbits: A, offset: B, count: C) =
  gFn4{gu32, gu32}("insertBits", v, newbits.gu32, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gi32, newbits: A, offset: B, count: C) =
  gFn4{gi32, gi32, gu32, gu32, gi32}("insertBits", v, newbits.gi32, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec2u, newbits: A, offset: B, count: C) =
  gFn4{gvec2u, gvec2u, gu32, gu32, gvec2u}("insertBits", v, newbits.gvec2u, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec2i, newbits: A, offset: B, count: C) =
  gFn4{gvec2i, gvec2i, gu32, gu32, gvec2i}("insertBits", v, newbits.gvec2i, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec3u, newbits: A, offset: B, count: C) =
  gFn4{gvec3u, gvec3u, gu32, gu32, gvec3u}("insertBits", v, newbits.gvec3u, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec3i, newbits: A, offset: B, count: C) =
  gFn4{gvec3i, gvec3i, gu32, gu32, gvec3i}("insertBits", v, newbits.gvec3i, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec4u, newbits: A, offset: B, count: C) =
  gFn4{gvec4u, gvec4u, gu32, gu32, gvec4u}("insertBits", v, newbits.gvec4u, offset.gu32, count.gu32);
fn insertBits{A, B, C}(v: gvec4i, newbits: A, offset: B, count: C) =
  gFn4{gvec4i, gvec4i, gu32, gu32, gvec4i}("insertBits", v, newbits.gvec4i, offset.gu32, count.gu32);

fn cross(a: gvec3f, b: gvec3f) = gFn2("cross", a, b);

fn transpose(m: gmat2x2f) = gFn1{gmat2x2f, gmat2x2f}("transpose", m);
fn transpose(m: gmat2x3f) = gFn1{gmat2x3f, gmat3x2f}("transpose", m);
fn transpose(m: gmat2x4f) = gFn1{gmat2x4f, gmat4x2f}("transpose", m);
fn transpose(m: gmat3x2f) = gFn1{gmat3x2f, gmat2x3f}("transpose", m);
fn transpose(m: gmat3x3f) = gFn1{gmat3x3f, gmat3x3f}("transpose", m);
fn transpose(m: gmat3x4f) = gFn1{gmat3x4f, gmat4x3f}("transpose", m);
fn transpose(m: gmat4x2f) = gFn1{gmat4x2f, gmat2x4f}("transpose", m);
fn transpose(m: gmat4x3f) = gFn1{gmat4x3f, gmat3x4f}("transpose", m);
fn transpose(m: gmat4x4f) = gFn1{gmat4x4f, gmat4x4f}("transpose", m);

fn dot(a: gvec2f, b: gvec2f) = gFn2{gvec2f, gf32}("dot", a, b);
fn dot(a: gvec3f, b: gvec3f) = gFn2{gvec3f, gf32}("dot", a, b);
fn dot(a: gvec4f, b: gvec4f) = gFn2{gvec4f, gf32}("dot", a, b);
fn dot(a: gvec2u, b: gvec2u) = gFn2{gvec2u, gu32}("dot", a, b);
fn dot(a: gvec3u, b: gvec3u) = gFn2{gvec3u, gu32}("dot", a, b);
fn dot(a: gvec4u, b: gvec4u) = gFn2{gvec4u, gu32}("dot", a, b);
fn dot(a: gvec2i, b: gvec2i) = gFn2{gvec2i, gi32}("dot", a, b);
fn dot(a: gvec3i, b: gvec3i) = gFn2{gvec3i, gi32}("dot", a, b);
fn dot(a: gvec4i, b: gvec4i) = gFn2{gvec4i, gi32}("dot", a, b);

fn magnitude(v: gf32) = gFn1("length", v);
fn magnitude(v: gvec2f) = gFn1{gvec2f, gf32}("length", v);
fn magnitude(v: gvec3f) = gFn1{gvec3f, gf32}("length", v);
fn magnitude(v: gvec4f) = gFn1{gvec4f, gf32}("length", v);

fn inverseSqrt(v: gf32) = gFn1("inverseSqrt", v);
fn inverseSqrt(v: gvec2f) = gFn1("inverseSqrt", v);
fn inverseSqrt(v: gvec3f) = gFn1("inverseSqrt", v);
fn inverseSqrt(v: gvec4f) = gFn1("inverseSqrt", v);

fn normalize(v: gvec2f) = gFn1("normalize", v);
fn normalize(v: gvec3f) = gFn1("normalize", v);
fn normalize(v: gvec4f) = gFn1("normalize", v);

fn round(v: gf32) = gFn1("round", v);
fn round(v: gvec2f) = gFn1("round", v);
fn round(v: gvec3f) = gFn1("round", v);
fn round(v: gvec4f) = gFn1("round", v);

fn fma(a: gf32, b: gf32, c: gf32) = gFn3("fma", a, b, c);
fn fma(a: gvec2f, b: gvec2f, c: gvec2f) = gFn3("fma", a, b, c);
fn fma(a: gvec3f, b: gvec3f, c: gvec3f) = gFn3("fma", a, b, c);
fn fma(a: gvec4f, b: gvec4f, c: gvec4f) = gFn3("fma", a, b, c);

fn fract(a: gf32) = gFn1("fract", a);
fn fract(a: gvec2f) = gFn1("fract", a);
fn fract(a: gvec3f) = gFn1("fract", a);
fn fract(a: gvec4f) = gFn1("fract", a);

fn determinant(m: gmat2x2f) = gFn1{gmat2x2f, gf32}("determinant", m);
fn determinant(m: gmat3x3f) = gFn1{gmat3x3f, gf32}("determinant", m);
fn determinant(m: gmat4x4f) = gFn1{gmat4x4f, gf32}("determinant", m);

fn add(a: gu32, b: gu32) = gInfix("+", "add", a, b);
fn add{T}(a: gu32, b: T) = add(a, b.gu32);
fn add{T}(a: T, b: gu32) = add(a.gu32, b);

fn add(a: gi32, b: gi32) = gInfix("+", "add", a, b);
fn add{T}(a: gi32, b: T) = add(a, b.gi32);
fn add{T}(a: T, b: gi32) = add(a.gi32, b);

fn add(a: gf32, b: gf32) = gInfix("+", "add", a, b);
fn add{T}(a: gf32, b: T) = add(a, b.gf32);
fn add{T}(a: T, b: gf32) = add(a.gf32, b);

fn add(a: gvec2u, b: gvec2u) = gInfix("+", "add", a, b);
fn add(a: gvec2u, b: gu32) = gInfix("+", "add", a, b);
// Because addition is commutative, I can do this
fn add(a: gu32, b: gvec2u) = gInfix("+", "add", b, a);

fn add(a: gvec2i, b: gvec2i) = gInfix("+", "add", a, b);
fn add(a: gvec2i, b: gi32) = gInfix("+", "add", a, b);
fn add(a: gi32, b: gvec2i) = gInfix("+", "add", b, a);

fn add(a: gvec2f, b: gvec2f) = gInfix("+", "add", a, b);
fn add(a: gvec2f, b: gf32) = gInfix("+", "add", a, b);
fn add(a: gf32, b: gvec2f) = gInfix("+", "add", b, a);

fn add(a: gvec3u, b: gvec3u) = gInfix("+", "add", a, b);
fn add(a: gvec3u, b: gu32) = gInfix("+", "add", a, b);
fn add(a: gu32, b: gvec3u) = gInfix("+", "add", b, a);

fn add(a: gvec3i, b: gvec3i) = gInfix("+", "add", a, b);
fn add(a: gvec3i, b: gi32) = gInfix("+", "add", a, b);
fn add(a: gi32, b: gvec3i) = gInfix("+", "add", b, a);

fn add(a: gvec3f, b: gvec3f) = gInfix("+", "add", a, b);
fn add(a: gvec3f, b: gf32) = gInfix("+", "add", a, b);
fn add(a: gf32, b: gvec3f) = gInfix("+", "add", b, a);

fn add(a: gvec4u, b: gvec4u) = gInfix("+", "add", a, b);
fn add(a: gvec4u, b: gu32) = gInfix("+", "add", a, b);
fn add(a: gu32, b: gvec4u) = gInfix("+", "add", b, a);

fn add(a: gvec4i, b: gvec4i) = gInfix("+", "add", a, b);
fn add(a: gvec4i, b: gi32) = gInfix("+", "add", a, b);
fn add(a: gi32, b: gvec4i) = gInfix("+", "add", b, a);

fn add(a: gvec4f, b: gvec4f) = gInfix("+", "add", a, b);
fn add(a: gvec4f, b: gf32) = gInfix("+", "add", a, b);
fn add(a: gf32, b: gvec4f) = gInfix("+", "add", b, a);

fn add(a: gmat2x2f, b: gmat2x2f) = gInfix("+", "add", a, b);
fn add(a: gmat2x3f, b: gmat2x3f) = gInfix("+", "add", a, b);
fn add(a: gmat2x4f, b: gmat2x4f) = gInfix("+", "add", a, b);
fn add(a: gmat3x2f, b: gmat3x2f) = gInfix("+", "add", a, b);
fn add(a: gmat3x3f, b: gmat3x3f) = gInfix("+", "add", a, b);
fn add(a: gmat3x4f, b: gmat3x4f) = gInfix("+", "add", a, b);
fn add(a: gmat4x2f, b: gmat4x2f) = gInfix("+", "add", a, b);
fn add(a: gmat4x3f, b: gmat4x3f) = gInfix("+", "add", a, b);
fn add(a: gmat4x4f, b: gmat4x4f) = gInfix("+", "add", a, b);

fn sub(a: gu32, b: gu32) = gInfix('-', 'sub', a, b);
fn sub{T}(a: gu32, b: T) = sub(a, b.gu32);
fn sub{T}(a: T, b: gu32) = sub(a.gu32, b);

fn sub(a: gi32, b: gi32) = gInfix('-', 'sub', a, b);
fn sub{T}(a: gi32, b: T) = sub(a, b.gi32);
fn sub{T}(a: T, b: gi32) = sub(a.gi32, b);

fn sub(a: gf32, b: gf32) = gInfix('-', 'sub', a, b);
fn sub{T}(a: gf32, b: T) = sub(a, b.gf32);
fn sub{T}(a: T, b: gf32) = sub(a.gf32, b);

fn sub(a: gvec2u, b: gvec2u) = gInfix('-', 'sub', a, b);
fn sub(a: gvec2u, b: gu32) = gInfix('-', 'sub', a, b);
fn sub(a: gu32, b: gvec2u) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec2i, b: gvec2i) = gInfix('-', 'sub', a, b);
fn sub(a: gvec2i, b: gi32) = gInfix('-', 'sub', a, b);
fn sub(a: gi32, b: gvec2i) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec2f, b: gvec2f) = gInfix('-', 'sub', a, b);
fn sub(a: gvec2f, b: gf32) = gInfix('-', 'sub', a, b);
fn sub(a: gf32, b: gvec2f) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec3u, b: gvec3u) = gInfix('-', 'sub', a, b);
fn sub(a: gvec3u, b: gu32) = gInfix('-', 'sub', a, b);
fn sub(a: gu32, b: gvec3u) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec3i, b: gvec3i) = gInfix('-', 'sub', a, b);
fn sub(a: gvec3i, b: gi32) = gInfix('-', 'sub', a, b);
fn sub(a: gi32, b: gvec3i) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec3f, b: gvec3f) = gInfix('-', 'sub', a, b);
fn sub(a: gvec3f, b: gf32) = gInfix('-', 'sub', a, b);
fn sub(a: gf32, b: gvec3f) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec4u, b: gvec4u) = gInfix('-', 'sub', a, b);
fn sub(a: gvec4u, b: gu32) = gInfix('-', 'sub', a, b);
fn sub(a: gu32, b: gvec4u) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec4i, b: gvec4i) = gInfix('-', 'sub', a, b);
fn sub(a: gvec4i, b: gi32) = gInfix('-', 'sub', a, b);
fn sub(a: gi32, b: gvec4i) = gInfixRev('-', 'sub', a, b);

fn sub(a: gvec4f, b: gvec4f) = gInfix('-', 'sub', a, b);
fn sub(a: gvec4f, b: gf32) = gInfix('-', 'sub', a, b);
fn sub(a: gf32, b: gvec4f) = gInfixRev('-', 'sub', a, b);

fn sub(a: gmat2x2f, b: gmat2x2f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat2x3f, b: gmat2x3f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat2x4f, b: gmat2x4f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat3x2f, b: gmat3x2f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat3x3f, b: gmat3x3f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat3x4f, b: gmat3x4f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat4x2f, b: gmat4x2f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat4x3f, b: gmat4x3f) = gInfix('-', 'sub', a, b);
fn sub(a: gmat4x4f, b: gmat4x4f) = gInfix('-', 'sub', a, b);

fn mul(a: gu32, b: gu32) = gInfix('*', 'mul', a, b);
fn mul{T}(a: gu32, b: T) = mul(a, b.gu32);
fn mul{T}(a: T, b: gu32) = mul(a.gu32, b);

fn mul(a: gi32, b: gi32) = gInfix('*', 'mul', a, b);
fn mul{T}(a: gi32, b: T) = mul(a, b.gi32);
fn mul{T}(a: T, b: gi32) = mul(a.gi32, b);

fn mul(a: gf32, b: gf32) = gInfix('*', 'mul', a, b);
fn mul{T}(a: gf32, b: T) = mul(a, b.gf32);
fn mul{T}(a: T, b: gf32) = mul(a.gf32, b);

fn mul(a: gvec2u, b: gvec2u) = gInfix('*', 'mul', a, b);
fn mul(a: gvec2u, b: gu32) = gInfix('*', 'mul', a, b);
// Same thing here, using the commutative property
fn mul(a: gu32, b: gvec2u) = gInfix('*', 'mul', b, a);

fn mul(a: gvec2i, b: gvec2i) = gInfix('*', 'mul', a, b);
fn mul(a: gvec2i, b: gi32) = gInfix('*', 'mul', a, b);
fn mul(a: gi32, b: gvec2i) = gInfix('*', 'mul', b, a);

fn mul(a: gvec2f, b: gvec2f) = gInfix('*', 'mul', a, b);
fn mul(a: gvec2f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gvec2f) = gInfix('*', 'mul', b, a);

fn mul(a: gvec3u, b: gvec3u) = gInfix('*', 'mul', a, b);
fn mul(a: gvec3u, b: gu32) = gInfix('*', 'mul', a, b);
fn mul(a: gu32, b: gvec3u) = gInfix('*', 'mul', b, a);

fn mul(a: gvec3i, b: gvec3i) = gInfix('*', 'mul', a, b);
fn mul(a: gvec3i, b: gi32) = gInfix('*', 'mul', a, b);
fn mul(a: gi32, b: gvec3i) = gInfix('*', 'mul', b, a);

fn mul(a: gvec3f, b: gvec3f) = gInfix('*', 'mul', a, b);
fn mul(a: gvec3f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gvec3f) = gInfix('*', 'mul', b, a);

fn mul(a: gvec4u, b: gvec4u) = gInfix('*', 'mul', a, b);
fn mul(a: gvec4u, b: gu32) = gInfix('*', 'mul', a, b);
fn mul(a: gu32, b: gvec4u) = gInfix('*', 'mul', b, a);

fn mul(a: gvec4i, b: gvec4i) = gInfix('*', 'mul', a, b);
fn mul(a: gvec4i, b: gi32) = gInfix('*', 'mul', a, b);
fn mul(a: gi32, b: gvec4i) = gInfix('*', 'mul', b, a);

fn mul(a: gvec4f, b: gvec4f) = gInfix('*', 'mul', a, b);
fn mul(a: gvec4f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gvec4f) = gInfix('*', 'mul', b, a);

// Matrix multiplication, though, needs some special consideration, most of the time
fn mul(a: gmat2x2f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat2x2f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat2x2f, b: gvec2f) = gInfix{gmat2x2f, gvec2f, gvec2f}('*', 'mul', a, b);
fn mul(a: gvec2f, b: gmat2x2f) = gInfix{gvec2f, gmat2x2f, gvec2f}('*', 'mul', a, b);
fn mul(a: gmat2x2f, b: gmat2x2f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat2x2f, b: gmat3x2f) = gInfix{gmat2x2f, gmat3x2f, gmat3x2f}('*', 'mul', a, b);
fn mul(a: gmat2x2f, b: gmat4x2f) = gInfix{gmat2x2f, gmat4x2f, gmat4x2f}('*', 'mul', a, b);

fn mul(a: gmat2x3f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat2x3f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat2x3f, b: gvec2f) = gInfix{gmat2x3f, gvec2f, gvec3f}('*', 'mul', a, b);
fn mul(a: gvec3f, b: gmat2x3f) = gInfix{gvec3f, gmat2x3f, gvec2f}('*', 'mul', a, b);
fn mul(a: gmat2x3f, b: gmat2x2f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat2x3f, b: gmat3x2f) = gInfix{gmat2x3f, gmat3x2f, gmat3x3f}('*', 'mul', a, b);
fn mul(a: gmat2x3f, b: gmat4x2f) = gInfix{gmat2x3f, gmat4x2f, gmat4x3f}('*', 'mul', a, b);

fn mul(a: gmat2x4f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat2x4f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat2x4f, b: gvec2f) = gInfix{gmat2x4f, gvec2f, gvec4f}('*', 'mul', a, b);
fn mul(a: gvec4f, b: gmat2x4f) = gInfix{gvec4f, gmat2x4f, gvec2f}('*', 'mul', a, b);
fn mul(a: gmat2x4f, b: gmat2x2f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat2x4f, b: gmat3x2f) = gInfix{gmat2x4f, gmat3x2f, gmat3x4f}('*', 'mul', a, b);
fn mul(a: gmat2x4f, b: gmat4x2f) = gInfix{gmat2x4f, gmat4x2f, gmat4x4f}('*', 'mul', a, b);

fn mul(a: gmat3x2f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat3x2f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat3x2f, b: gvec3f) = gInfix{gmat3x2f, gvec3f, gvec2f}('*', 'mul', a, b);
fn mul(a: gvec2f, b: gmat3x2f) = gInfix{gvec2f, gmat3x2f, gvec3f}('*', 'mul', a, b);
fn mul(a: gmat3x2f, b: gmat2x3f) = gInfix{gmat3x2f, gmat2x3f, gmat2x2f}('*', 'mul', a, b);
fn mul(a: gmat3x2f, b: gmat3x3f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat3x2f, b: gmat4x3f) = gInfix{gmat3x2f, gmat4x3f, gmat4x2f}('*', 'mul', a, b);

fn mul(a: gmat3x3f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat3x3f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat3x3f, b: gvec3f) = gInfix{gmat3x3f, gvec3f, gvec3f}('*', 'mul', a, b);
fn mul(a: gvec3f, b: gmat3x3f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat3x3f, b: gmat2x3f) = gInfix{gmat3x3f, gmat2x3f, gmat2x3f}('*', 'mul', a, b);
fn mul(a: gmat3x3f, b: gmat3x3f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat3x3f, b: gmat4x3f) = gInfix{gmat3x3f, gmat4x3f, gmat4x3f}('*', 'mul', a, b);

fn mul(a: gmat3x4f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat3x4f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat3x4f, b: gvec3f) = gInfix{gmat3x4f, gvec3f, gvec4f}('*', 'mul', a, b);
fn mul(a: gvec4f, b: gmat3x4f) = gInfix{gvec4f, gmat3x4f, gvec3f}('*', 'mul', a, b);
fn mul(a: gmat3x4f, b: gmat2x3f) = gInfix{gmat3x4f, gmat2x3f, gmat2x4f}('*', 'mul', a, b);
fn mul(a: gmat3x4f, b: gmat3x3f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat3x4f, b: gmat4x3f) = gInfix{gmat3x4f, gmat4x3f, gmat4x4f}('*', 'mul', a, b);

fn mul(a: gmat4x2f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat4x2f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat4x2f, b: gvec4f) = gInfix{gmat4x2f, gvec4f, gvec2f}('*', 'mul', a, b);
fn mul(a: gvec2f, b: gmat4x2f) = gInfix{gvec2f, gmat4x2f, gvec4f}('*', 'mul', a, b);
fn mul(a: gmat4x2f, b: gmat2x4f) = gInfix{gmat4x2f, gmat2x4f, gmat2x2f}('*', 'mul', a, b);
fn mul(a: gmat4x2f, b: gmat3x4f) = gInfix{gmat4x2f, gmat3x4f, gmat3x2f}('*', 'mul', a, b);
fn mul(a: gmat4x2f, b: gmat4x4f) = gInfix('*', 'mul', a, b);

fn mul(a: gmat4x3f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat4x3f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat4x3f, b: gvec4f) = gInfix{gmat4x3f, gvec4f, gvec3f}('*', 'mul', a, b);
fn mul(a: gvec3f, b: gmat4x3f) = gInfix{gvec3f, gmat4x3f, gvec4f}('*', 'mul', a, b);
fn mul(a: gmat4x3f, b: gmat2x4f) = gInfix{gmat4x3f, gmat2x4f, gmat2x3f}('*', 'mul', a, b);
fn mul(a: gmat4x3f, b: gmat3x4f) = gInfix{gmat4x3f, gmat3x4f, gmat3x3f}('*', 'mul', a, b);
fn mul(a: gmat4x3f, b: gmat4x4f) = gInfix('*', 'mul', a, b);

fn mul(a: gmat4x4f, b: gf32) = gInfix('*', 'mul', a, b);
fn mul(a: gf32, b: gmat4x4f) = gInfix('*', 'mul', b, a);
fn mul(a: gmat4x4f, b: gvec4f) = gInfix{gmat4x4f, gvec4f, gvec4f}('*', 'mul', a, b);
fn mul(a: gvec4f, b: gmat4x4f) = gInfix('*', 'mul', a, b);
fn mul(a: gmat4x4f, b: gmat2x4f) = gInfix{gmat4x4f, gmat2x4f, gmat2x4f}('*', 'mul', a, b);
fn mul(a: gmat4x4f, b: gmat3x4f) = gInfix{gmat4x4f, gmat3x4f, gmat3x4f}('*', 'mul', a, b);
fn mul(a: gmat4x4f, b: gmat4x4f) = gInfix('*', 'mul', a, b);

fn div(a: gu32, b: gu32) = gInfix('/', 'div', a, b);
fn div{T}(a: gu32, b: T) = div(a, b.gu32);
fn div{T}(a: T, b: gu32) = div(a.gu32, b);

fn div(a: gi32, b: gi32) = gInfix('/', 'div', a, b);
fn div{T}(a: gi32, b: T) = div(a, b.gi32);
fn div{T}(a: T, b: gi32) = div(a.gi32, b);

fn div(a: gf32, b: gf32) = gInfix('/', 'div', a, b);
fn div{T}(a: gf32, b: T) = div(a, b.gf32);
fn div{T}(a: T, b: gf32) = div(a.gf32, b);

fn div(a: gvec2u, b: gvec2u) = gInfix('/', 'div', a, b);
fn div(a: gvec2u, b: gu32) = gInfix('/', 'div', a, b);
fn div(a: gu32, b: gvec2u) = gInfixRev('/', 'div', a, b);

fn div(a: gvec2i, b: gvec2i) = gInfix('/', 'div', a, b);
fn div(a: gvec2i, b: gi32) = gInfix('/', 'div', a, b);
fn div(a: gi32, b: gvec2i) = gInfixRev('/', 'div', a, b);

fn div(a: gvec2f, b: gvec2f) = gInfix('/', 'div', a, b);
fn div(a: gvec2f, b: gf32) = gInfix('/', 'div', a, b);
fn div(a: gf32, b: gvec2f) = gInfixRev('/', 'div', a, b);

fn div(a: gvec3u, b: gvec3u) = gInfix('/', 'div', a, b);
fn div(a: gvec3u, b: gu32) = gInfix('/', 'div', a, b);
fn div(a: gu32, b: gvec3u) = gInfixRev('/', 'div', a, b);

fn div(a: gvec3i, b: gvec3i) = gInfix('/', 'div', a, b);
fn div(a: gvec3i, b: gi32) = gInfix('/', 'div', a, b);
fn div(a: gi32, b: gvec3i) = gInfixRev('/', 'div', a, b);

fn div(a: gvec3f, b: gvec3f) = gInfix('/', 'div', a, b);
fn div(a: gvec3f, b: gf32) = gInfix('/', 'div', a, b);
fn div(a: gf32, b: gvec3f) = gInfixRev('/', 'div', a, b);

fn div(a: gvec4u, b: gvec4u) = gInfix('/', 'div', a, b);
fn div(a: gvec4u, b: gu32) = gInfix('/', 'div', a, b);
fn div(a: gu32, b: gvec4u) = gInfixRev('/', 'div', a, b);

fn div(a: gvec4i, b: gvec4i) = gInfix('/', 'div', a, b);
fn div(a: gvec4i, b: gi32) = gInfix('/', 'div', a, b);
fn div(a: gi32, b: gvec4i) = gInfixRev('/', 'div', a, b);

fn div(a: gvec4f, b: gvec4f) = gInfix('/', 'div', a, b);
fn div(a: gvec4f, b: gf32) = gInfix('/', 'div', a, b);
fn div(a: gf32, b: gvec4f) = gInfixRev('/', 'div', a, b);

fn mod(a: gu32, b: gu32) = gInfix('%', 'mod', a, b);
fn mod{T}(a: gu32, b: T) = mod(a, b.gu32);
fn mod{T}(a: T, b: gu32) = mod(a.gu32, b);

fn mod(a: gi32, b: gi32) = gInfix('%', 'mod', a, b);
fn mod{T}(a: gi32, b: T) = mod(a, b.gi32);
fn mod{T}(a: T, b: gi32) = mod(a.gi32, b);

fn mod(a: gf32, b: gf32) = gInfix('%', 'mod', a, b);
fn mod{T}(a: gf32, b: T) = mod(a, b.gf32);
fn mod{T}(a: T, b: gf32) = mod(a.gf32, b);

fn mod(a: gvec2u, b: gvec2u) = gInfix('%', 'mod', a, b);
fn mod(a: gvec2u, b: gu32) = gInfix('%', 'mod', a, b);
fn mod(a: gu32, b: gvec2u) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec2i, b: gvec2i) = gInfix('%', 'mod', a, b);
fn mod(a: gvec2i, b: gi32) = gInfix('%', 'mod', a, b);
fn mod(a: gi32, b: gvec2i) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec2f, b: gvec2f) = gInfix('%', 'mod', a, b);
fn mod(a: gvec2f, b: gf32) = gInfix('%', 'mod', a, b);
fn mod(a: gf32, b: gvec2f) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec3u, b: gvec3u) = gInfix('%', 'mod', a, b);
fn mod(a: gvec3u, b: gu32) = gInfix('%', 'mod', a, b);
fn mod(a: gu32, b: gvec3u) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec3i, b: gvec3i) = gInfix('%', 'mod', a, b);
fn mod(a: gvec3i, b: gi32) = gInfix('%', 'mod', a, b);
fn mod(a: gi32, b: gvec3i) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec3f, b: gvec3f) = gInfix('%', 'mod', a, b);
fn mod(a: gvec3f, b: gf32) = gInfix('%', 'mod', a, b);
fn mod(a: gf32, b: gvec3f) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec4u, b: gvec4u) = gInfix('%', 'mod', a, b);
fn mod(a: gvec4u, b: gu32) = gInfix('%', 'mod', a, b);
fn mod(a: gu32, b: gvec4u) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec4i, b: gvec4i) = gInfix('%', 'mod', a, b);
fn mod(a: gvec4i, b: gi32) = gInfix('%', 'mod', a, b);
fn mod(a: gi32, b: gvec4i) = gInfixRev('%', 'mod', a, b);

fn mod(a: gvec4f, b: gvec4f) = gInfix('%', 'mod', a, b);
fn mod(a: gvec4f, b: gf32) = gInfix('%', 'mod', a, b);
fn mod(a: gf32, b: gvec4f) = gInfixRev('%', 'mod', a, b);

fn pow(a: gf32, b: gf32) = gFn2('pow', a, b);
fn pow{T}(a: gf32, b: T) = pow(a, b.gf32);
fn pow{T}(a: T, b: gf32) = pow(a.gf32, b);
fn pow(a: gvec2f, b: gvec2f) = gFn2('pow', a, b);
fn pow{T}(a: gvec2f, b: T) = pow(a, b.gvec2f);
fn pow{T}(a: T, b: gvec2f) = pow(a.gvec2f, b);
fn pow(a: gvec3f, b: gvec3f) = gFn2('pow', a, b);
fn pow{T}(a: gvec3f, b: T) = pow(a, b.gvec3f);
fn pow{T}(a: T, b: gvec3f) = pow(a.gvec3f, b);
fn pow(a: gvec4f, b: gvec4f) = gFn2('pow', a, b);
fn pow{T}(a: gvec4f, b: T) = pow(a, b.gvec4f);
fn pow{T}(a: T, b: gvec4f) = pow(a.gvec4f, b);

fn min(a: gf32, b: gf32) = gFn2("min", a, b);
fn min{A}(a: A, b: gf32) = gFn2("min", a.gf32, b);
fn min{B}(a: gf32, b: B) = gFn2("min", a, b.gf32);
fn min(a: gu32, b: gu32) = gFn2("min", a, b);
fn min{A}(a: A, b: gu32) = gFn2("min", a.gu32, b);
fn min{B}(a: gu32, b: B) = gFn2("min", a, b.gu32);
fn min(a: gi32, b: gi32) = gFn2("min", a, b);
fn min{A}(a: A, b: gi32) = gFn2("min", a.gi32, b);
fn min{B}(a: gi32, b: B) = gFn2("min", a, b.gi32);

fn max(a: gf32, b: gf32) = gFn2('max', a, b);
fn max{A}(a: A, b: gf32) = gFn2('max', a.gf32, b);
fn max{B}(a: gf32, b: B) = gFn2('max', a, b.gf32);
fn max(a: gu32, b: gu32) = gFn2('max', a, b);
fn max{A}(a: A, b: gu32) = gFn2('max', a.gu32, b);
fn max{B}(a: gu32, b: B) = gFn2('max', a, b.gu32);
fn max(a: gi32, b: gi32) = gFn2('max', a, b);
fn max{A}(a: A, b: gi32) = gFn2('max', a.gi32, b);
fn max{B}(a: gi32, b: B) = gFn2('max', a, b.gi32);

fn sqrt(v: gf32) = gFn1('sqrt', v);
fn sqrt(v: gvec2f) = gFn1('sqrt', v);
fn sqrt(v: gvec3f) = gFn1('sqrt', v);
fn sqrt(v: gvec4f) = gFn1('sqrt', v);

fn acos(v: gf32) = gFn1('acos', v);
fn acos(v: gvec2f) = gFn1('acos', v);
fn acos(v: gvec3f) = gFn1('acos', v);
fn acos(v: gvec4f) = gFn1('acos', v);

fn acosh(v: gf32) = gFn1('acosh', v);
fn acosh(v: gvec2f) = gFn1('acosh', v);
fn acosh(v: gvec3f) = gFn1('acosh', v);
fn acosh(v: gvec4f) = gFn1('acosh', v);

fn asin(v: gf32) = gFn1('asin', v);
fn asin(v: gvec2f) = gFn1('asin', v);
fn asin(v: gvec3f) = gFn1('asin', v);
fn asin(v: gvec4f) = gFn1('asin', v);

fn asinh(v: gf32) = gFn1('asinh', v);
fn asinh(v: gvec2f) = gFn1('asinh', v);
fn asinh(v: gvec3f) = gFn1('asinh', v);
fn asinh(v: gvec4f) = gFn1('asinh', v);

fn atan(v: gf32) = gFn1('atan', v);
fn atan(v: gvec2f) = gFn1('atan', v);
fn atan(v: gvec3f) = gFn1('atan', v);
fn atan(v: gvec4f) = gFn1('atan', v);

fn atanh(v: gf32) = gFn1('atanh', v);
fn atanh(v: gvec2f) = gFn1('atanh', v);
fn atanh(v: gvec3f) = gFn1('atanh', v);
fn atanh(v: gvec4f) = gFn1('atanh', v);

fn atan2(a: gf32, b: gf32) = gFn2('atan2', a, b);
fn atan2{T}(a: gf32, b: T) = gFn2('atan2', a, b.gf32);
fn atan2{T}(a: T, b: gf32) = gFn2('atan2', a.gf32, b);
fn atan2(a: gvec2f, b: gvec2f) = gFn2('atan2', a, b);
fn atan2{T}(a: gvec2f, b: T) = gFn2('atan2', a, b.gvec2f);
fn atan2{T}(a: T, b: gvec2f) = gFn2('atan2', a.gvec2f, b);
fn atan2(a: gvec3f, b: gvec3f) = gFn2('atan2', a, b);
fn atan2{T}(a: gvec3f, b: T) = gFn2('atan2', a, b.gvec3f);
fn atan2{T}(a: T, b: gvec3f) = gFn2('atan2', a.gvec3f, b);
fn atan2(a: gvec4f, b: gvec4f) = gFn2('atan2', a, b);
fn atan2{T}(a: gvec4f, b: T) = gFn2('atan2', a, b.gvec4f);
fn atan2{T}(a: T, b: gvec4f) = gFn2('atan2', a.gvec4f, b);

fn floor(v: gf32) = gFn1('floor', v);
fn floor(v: gvec2f) = gFn1('floor', v);
fn floor(v: gvec3f) = gFn1('floor', v);
fn floor(v: gvec4f) = gFn1('floor', v);

fn ceil(v: gf32) = gFn1('ceil', v);
fn ceil(v: gvec2f) = gFn1('ceil', v);
fn ceil(v: gvec3f) = gFn1('ceil', v);
fn ceil(v: gvec4f) = gFn1('ceil', v);

fn clamp(v: gf32, l: gf32, h: gf32) = gFn3('clamp', v, l, h);
fn clamp{T}(v: gf32, l: T, h: T) = gFn3('clamp', v, l.gf32, h.gf32);
fn clamp{T}(v: gf32, l: gf32, h: T) = gFn3('clamp', v, l, h.gf32);
fn clamp{T}(v: gf32, l: T, h: gf32) = gFn3('clamp', v, l.gf32, h);
fn clamp(v: gvec2f, l: gvec2f, h: gvec2f) = gFn3('clamp', v, l, h);
fn clamp{T}(v: gvec2f, l: T, h: T) = gFn3('clamp', v, l.gvec2f, h.gvec2f);
fn clamp{T}(v: gvec2f, l: gvec2f, h: T) = gFn3('clamp', v, l, h.gvec2f);
fn clamp{T}(v: gvec2f, l: T, h: gvec2f) = gFn3('clamp', v, l.gvec2f, h);
fn clamp(v: gvec3f, l: gvec3f, h: gvec3f) = gFn3('clamp', v, l, h);
fn clamp{T}(v: gvec3f, l: T, h: T) = gFn3('clamp', v, l.gvec3f, h.gvec3f);
fn clamp{T}(v: gvec3f, l: gvec3f, h: T) = gFn3('clamp', v, l, h.gvec3f);
fn clamp{T}(v: gvec3f, l: T, h: gvec3f) = gFn3('clamp', v, l.gvec3f, h);
fn clamp(v: gvec4f, l: gvec4f, h: gvec4f) = gFn3('clamp', v, l, h);
fn clamp{T}(v: gvec4f, l: T, h: T) = gFn3('clamp', v, l.gvec4f, h.gvec4f);
fn clamp{T}(v: gvec4f, l: gvec4f, h: T) = gFn3('clamp', v, l, h.gvec4f);
fn clamp{T}(v: gvec4f, l: T, h: gvec4f) = gFn3('clamp', v, l.gvec4f, h);

fn saturate(v: gf32) = gFn1('saturate', v);
fn saturate(v: gvec2f) = gFn1('saturate', v);
fn saturate(v: gvec3f) = gFn1('saturate', v);
fn saturate(v: gvec4f) = gFn1('saturate', v);

fn exp(v: gf32) = gFn1('exp', v);
fn exp(v: gvec2f) = gFn1('exp', v);
fn exp(v: gvec3f) = gFn1('exp', v);
fn exp(v: gvec4f) = gFn1('exp', v);

fn ln(v: gf32) = gFn1('log', v);
fn ln(v: gvec2f) = gFn1('log', v);
fn ln(v: gvec3f) = gFn1('log', v);
fn ln(v: gvec4f) = gFn1('log', v);

fn log2(v: gf32) = gFn1('log2', v);
fn log2(v: gvec2f) = gFn1('log2', v);
fn log2(v: gvec3f) = gFn1('log2', v);
fn log2(v: gvec4f) = gFn1('log2', v);

fn glog10{I}(v: I) {
  let typename = {I.typeName}();
  let varName = 'log10_'.concat(typename).concat('_').concat(uuid().string.replace('-', '_'));
  let statement = 'var '
    .concat(varName)
    .concat(' = log(')
    .concat(v.varName)
    .concat(') / log(10.0)');
  let statements = v.statements.concat(Dict(varName, statement));
  return {I}(varName, statements, v.buffers);
}
fn log10(v: gf32) = glog10(v);
fn log10(v: gvec2f) = glog10(v);
fn log10(v: gvec3f) = glog10(v);
fn log10(v: gvec4f) = glog10(v);

fn cos(v: gf32) = gFn1('cos', v);
fn cos(v: gvec2f) = gFn1('cos', v);
fn cos(v: gvec3f) = gFn1('cos', v);
fn cos(v: gvec4f) = gFn1('cos', v);

fn cosh(v: gf32) = gFn1('cosh', v);
fn cosh(v: gvec2f) = gFn1('cosh', v);
fn cosh(v: gvec3f) = gFn1('cosh', v);
fn cosh(v: gvec4f) = gFn1('cosh', v);

fn sin(v: gf32) = gFn1('sin', v);
fn sin(v: gvec2f) = gFn1('sin', v);
fn sin(v: gvec3f) = gFn1('sin', v);
fn sin(v: gvec4f) = gFn1('sin', v);

fn sinh(v: gf32) = gFn1('sinh', v);
fn sinh(v: gvec2f) = gFn1('sinh', v);
fn sinh(v: gvec3f) = gFn1('sinh', v);
fn sinh(v: gvec4f) = gFn1('sinh', v);

fn tan(v: gf32) = gFn1('tan', v);
fn tan(v: gvec2f) = gFn1('tan', v);
fn tan(v: gvec3f) = gFn1('tan', v);
fn tan(v: gvec4f) = gFn1('tan', v);

fn tanh(v: gf32) = gFn1('tanh', v);
fn tanh(v: gvec2f) = gFn1('tanh', v);
fn tanh(v: gvec3f) = gFn1('tanh', v);
fn tanh(v: gvec4f) = gFn1('tanh', v);

fn sec(v: gf32) = 1.0.div(cos(v));
fn sec(v: gvec2f) = gvec2f(1.0).div(cos(v));
fn sec(v: gvec3f) = gvec3f(1.0).div(cos(v));
fn sec(v: gvec4f) = gvec4f(1.0).div(cos(v));

fn csc(v: gf32) = 1.0.div(sin(v));
fn csc(v: gvec2f) = gvec2f(1.0).div(sin(v));
fn csc(v: gvec3f) = gvec3f(1.0).div(sin(v));
fn csc(v: gvec4f) = gvec4f(1.0).div(sin(v));

fn cot(v: gf32) = 1.0.div(tan(v));
fn cot(v: gvec2f) = gvec2f(1.0).div(tan(v));
fn cot(v: gvec3f) = gvec3f(1.0).div(tan(v));
fn cot(v: gvec4f) = gvec4f(1.0).div(tan(v));

fn asec(v: gf32) = acos(1.0.div(v));
fn asec(v: gvec2f) = acos(gvec2f(1.0).div(v));
fn asec(v: gvec3f) = acos(gvec3f(1.0).div(v));
fn asec(v: gvec4f) = acos(gvec4f(1.0).div(v));

fn acsc(v: gf32) = asin(1.0.div(v));
fn acsc(v: gvec2f) = asin(gvec2f(1.0).div(v));
fn acsc(v: gvec3f) = asin(gvec3f(1.0).div(v));
fn acsc(v: gvec4f) = asin(gvec4f(1.0).div(v));

fn acot(v: gf32) = pi.div(2.0).sub(atan(v));
fn acot(v: gvec2f) = gvec2f(pi.div(2.0), pi.div(2.0)).sub(atan(v));
fn acot(v: gvec3f) = gvec3f(pi.div(2.0), pi.div(2.0), pi.div(2.0)).sub(atan(v));
fn acot(v: gvec4f) = gvec4f(pi.div(2.0), pi.div(2.0), pi.div(2.0), pi.div(2.0)).sub(atan(v));

fn sech(v: gf32) = 1.0.div(cosh(v));
fn sech(v: gvec2f) = gvec2f(1.0).div(cosh(v));
fn sech(v: gvec3f) = gvec3f(1.0).div(cosh(v));
fn sech(v: gvec4f) = gvec4f(1.0).div(cosh(v));

fn csch(v: gf32) = 1.0.div(sinh(v));
fn csch(v: gvec2f) = gvec2f(1.0).div(sinh(v));
fn csch(v: gvec3f) = gvec3f(1.0).div(sinh(v));
fn csch(v: gvec4f) = gvec4f(1.0).div(sinh(v));

fn coth(v: gf32) = 1.0.div(tanh(v));
fn coth(v: gvec2f) = gvec2f(1.0).div(tanh(v));
fn coth(v: gvec3f) = gvec3f(1.0).div(tanh(v));
fn coth(v: gvec4f) = gvec4f(1.0).div(tanh(v));

fn asech(v: gf32) = ln(1.0.add(sqrt(1.0.sub(v.pow(2.0)))).div(v));
fn asech(v: gvec2f) = ln(gvec2f(1.0).add(sqrt(gvec2f(1.0).sub(v.pow(gvec2f(2.0))))).div(v));
fn asech(v: gvec3f) = ln(gvec3f(1.0).add(sqrt(gvec3f(1.0).sub(v.pow(gvec3f(2.0))))).div(v));
fn asech(v: gvec4f) = ln(gvec4f(1.0).add(sqrt(gvec4f(1.0).sub(v.pow(gvec4f(2.0))))).div(v));

fn acsch(x: gf32) = ln(1.0.div(x).add(sqrt(1.0.div(x.pow(2.0)).add(1.0))));
fn acsch(x: gvec2f) = ln(gvec2f(1.0).div(x).add(sqrt(gvec2f(1.0).div(x.pow(gvec2f(2.0))).add(gvec2f(1.0)))));
fn acsch(x: gvec3f) = ln(gvec3f(1.0).div(x).add(sqrt(gvec3f(1.0).div(x.pow(gvec3f(2.0))).add(gvec3f(1.0)))));
fn acsch(x: gvec4f) = ln(gvec4f(1.0).div(x).add(sqrt(gvec4f(1.0).div(x.pow(gvec4f(2.0))).add(gvec4f(1.0)))));

fn acoth(x: gf32) = ln(x.add(1.0).div(x.sub(1.0))).div(2.0);
fn acoth(x: gvec2f) = ln(x.add(gvec2f(1.0)).div(x.sub(gvec2f(1.0)))).div(gvec2f(2.0));
fn acoth(x: gvec3f) = ln(x.add(gvec3f(1.0)).div(x.sub(gvec3f(1.0)))).div(gvec3f(2.0));
fn acoth(x: gvec4f) = ln(x.add(gvec4f(1.0)).div(x.sub(gvec4f(1.0)))).div(gvec4f(2.0));

/// GPGPU Comparison functions

fn eq(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('==', 'eq', a, b);
fn eq{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('==', 'eq', a, b.gu32);
fn eq{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('==', 'eq', a.gu32, b);
fn eq(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('==', 'eq', a, b);
fn eq{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('==', 'eq', a, b.gi32);
fn eq{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('==', 'eq', a.gi32, b);
fn eq(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('==', 'eq', a, b);
fn eq{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('==', 'eq', a, b.gf32);
fn eq{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('==', 'eq', a.gf32, b);
fn eq(a: gbool, b: gbool) = gInfix{gbool, gbool, gbool}('==', 'eq', a, b);
fn eq{T}(a: gbool, b: T) = gInfix{gbool, gbool, gbool}('==', 'eq', a, b.gbool);
fn eq{T}(a: T, b: gbool) = gInfix{gbool, gbool, gbool}('==', 'eq', a.gbool, b);
fn eq(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('==', 'eq', a, b);
fn eq(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('==', 'eq', a, b);
fn eq(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('==', 'eq', a, b);
fn eq(a: gvec2b, b: gvec2b) = gInfix{gvec2b, gvec2b, gvec2b}('==', 'eq', a, b);
fn eq(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('==', 'eq', a, b);
fn eq(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('==', 'eq', a, b);
fn eq(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('==', 'eq', a, b);
fn eq(a: gvec3b, b: gvec3b) = gInfix{gvec3b, gvec3b, gvec3b}('==', 'eq', a, b);
fn eq(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('==', 'eq', a, b);
fn eq(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('==', 'eq', a, b);
fn eq(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('==', 'eq', a, b);
fn eq(a: gvec4b, b: gvec4b) = gInfix{gvec4b, gvec4b, gvec4b}('==', 'eq', a, b);

fn neq(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('!=', 'neq', a, b);
fn neq{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('!=', 'neq', a, b.gu32);
fn neq{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('!=', 'neq', a.gu32, b);
fn neq(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('!=', 'neq', a, b);
fn neq{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('!=', 'neq', a, b.gi32);
fn neq{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('!=', 'neq', a.gi32, b);
fn neq(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('!=', 'neq', a, b);
fn neq{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('!=', 'neq', a, b.gf32);
fn neq{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('!=', 'neq', a.gf32, b);
fn neq(a: gbool, b: gbool) = gInfix{gbool, gbool, gbool}('!=', 'neq', a, b);
fn neq{T}(a: gbool, b: T) = gInfix{gbool, gbool, gbool}('!=', 'neq', a, b.gbool);
fn neq{T}(a: T, b: gbool) = gInfix{gbool, gbool, gbool}('!=', 'neq', a.gbool, b);
fn neq(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('!=', 'neq', a, b);
fn neq(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('!=', 'neq', a, b);
fn neq(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('!=', 'neq', a, b);
fn neq(a: gvec2b, b: gvec2b) = gInfix{gvec2b, gvec2b, gvec2b}('!=', 'neq', a, b);
fn neq(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('!=', 'neq', a, b);
fn neq(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('!=', 'neq', a, b);
fn neq(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('!=', 'neq', a, b);
fn neq(a: gvec3b, b: gvec3b) = gInfix{gvec3b, gvec3b, gvec3b}('!=', 'neq', a, b);
fn neq(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('!=', 'neq', a, b);
fn neq(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('!=', 'neq', a, b);
fn neq(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('!=', 'neq', a, b);
fn neq(a: gvec4b, b: gvec4b) = gInfix{gvec4b, gvec4b, gvec4b}('!=', 'neq', a, b);

fn lt(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('<', 'lt', a, b);
fn lt{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('<', 'lt', a, b.gu32);
fn lt{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('<', 'lt', a.gu32, b);
fn lt(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('<', 'lt', a, b);
fn lt{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('<', 'lt', a, b.gi32);
fn lt{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('<', 'lt', a.gi32, b);
fn lt(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('<', 'lt', a, b);
fn lt{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('<', 'lt', a, b.gf32);
fn lt{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('<', 'lt', a.gf32, b);
fn lt(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('<', 'lt', a, b);
fn lt(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('<', 'lt', a, b);
fn lt(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('<', 'lt', a, b);
fn lt(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('<', 'lt', a, b);
fn lt(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('<', 'lt', a, b);
fn lt(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('<', 'lt', a, b);
fn lt(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('<', 'lt', a, b);
fn lt(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('<', 'lt', a, b);
fn lt(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('<', 'lt', a, b);

fn lte(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('<=', 'lte', a, b);
fn lte{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('<=', 'lte', a, b.gu32);
fn lte{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('<=', 'lte', a.gu32, b);
fn lte(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('<=', 'lte', a, b);
fn lte{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('<=', 'lte', a, b.gi32);
fn lte{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('<=', 'lte', a.gi32, b);
fn lte(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('<=', 'lte', a, b);
fn lte{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('<=', 'lte', a, b.gf32);
fn lte{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('<=', 'lte', a.gf32, b);
fn lte(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('<=', 'lte', a, b);
fn lte(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('<=', 'lte', a, b);
fn lte(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('<=', 'lte', a, b);
fn lte(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('<=', 'lte', a, b);
fn lte(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('<=', 'lte', a, b);
fn lte(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('<=', 'lte', a, b);
fn lte(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('<=', 'lte', a, b);
fn lte(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('<=', 'lte', a, b);
fn lte(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('<=', 'lte', a, b);

fn gt(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('>', 'gt', a, b);
fn gt{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('>', 'gt', a, b.gu32);
fn gt{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('>', 'gt', a.gu32, b);
fn gt(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('>', 'gt', a, b);
fn gt{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('>', 'gt', a, b.gi32);
fn gt{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('>', 'gt', a.gi32, b);
fn gt(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('>', 'gt', a, b);
fn gt{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('>', 'gt', a, b.gf32);
fn gt{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('>', 'gt', a.gf32, b);
fn gt(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('>', 'gt', a, b);
fn gt(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('>', 'gt', a, b);
fn gt(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('>', 'gt', a, b);
fn gt(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('>', 'gt', a, b);
fn gt(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('>', 'gt', a, b);
fn gt(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('>', 'gt', a, b);
fn gt(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('>', 'gt', a, b);
fn gt(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('>', 'gt', a, b);
fn gt(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('>', 'gt', a, b);

fn gte(a: gu32, b: gu32) = gInfix{gu32, gu32, gbool}('>=', 'gte', a, b);
fn gte{T}(a: gu32, b: T) = gInfix{gu32, gu32, gbool}('>=', 'gte', a, b.gu32);
fn gte{T}(a: T, b: gu32) = gInfix{gu32, gu32, gbool}('>=', 'gte', a.gu32, b);
fn gte(a: gi32, b: gi32) = gInfix{gi32, gi32, gbool}('>=', 'gte', a, b);
fn gte{T}(a: gi32, b: T) = gInfix{gi32, gi32, gbool}('>=', 'gte', a, b.gi32);
fn gte{T}(a: T, b: gi32) = gInfix{gi32, gi32, gbool}('>=', 'gte', a.gi32, b);
fn gte(a: gf32, b: gf32) = gInfix{gf32, gf32, gbool}('>=', 'gte', a, b);
fn gte{T}(a: gf32, b: T) = gInfix{gf32, gf32, gbool}('>=', 'gte', a, b.gf32);
fn gte{T}(a: T, b: gf32) = gInfix{gf32, gf32, gbool}('>=', 'gte', a.gf32, b);
fn gte(a: gvec2u, b: gvec2u) = gInfix{gvec2u, gvec2u, gvec2b}('>=', 'gte', a, b);
fn gte(a: gvec2i, b: gvec2i) = gInfix{gvec2i, gvec2i, gvec2b}('>=', 'gte', a, b);
fn gte(a: gvec2f, b: gvec2f) = gInfix{gvec2f, gvec2f, gvec2b}('>=', 'gte', a, b);
fn gte(a: gvec3u, b: gvec3u) = gInfix{gvec3u, gvec3u, gvec3b}('>=', 'gte', a, b);
fn gte(a: gvec3i, b: gvec3i) = gInfix{gvec3i, gvec3i, gvec3b}('>=', 'gte', a, b);
fn gte(a: gvec3f, b: gvec3f) = gInfix{gvec3f, gvec3f, gvec3b}('>=', 'gte', a, b);
fn gte(a: gvec4u, b: gvec4u) = gInfix{gvec4u, gvec4u, gvec4b}('>=', 'gte', a, b);
fn gte(a: gvec4i, b: gvec4i) = gInfix{gvec4i, gvec4i, gvec4b}('>=', 'gte', a, b);
fn gte(a: gvec4f, b: gvec4f) = gInfix{gvec4f, gvec4f, gvec4b}('>=', 'gte', a, b);

/// GPGPU Conditional functions

fn if{T}(c: gbool, t: () -> T, f: () -> T) = if(c, t(), f());
fn if{T}(c: gbool, t: T, f: T) {
  let varName = "select("
    .concat(f.varName)
    .concat(', ')
    .concat(t.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = f.statements.concat(t.statements).concat(c.statements);
  let buffers = f.buffers.union(t.buffers).union(c.buffers);
  return {T}(varName, statements, buffers);
}

/// GPU Boolean and Bitwise methods

fn not(a: gu32) = gPrefix('!', 'not', a);
fn not(a: gi32) = gPrefix('!', 'not', a);
fn not(a: gbool) = gPrefix('!', 'not', a);
fn not(a: gvec2u) = gPrefix('!', 'not', a);
fn not(a: gvec2i) = gPrefix('!', 'not', a);
fn not(a: gvec2b) = gPrefix('!', 'not', a);
fn not(a: gvec3u) = gPrefix('!', 'not', a);
fn not(a: gvec3i) = gPrefix('!', 'not', a);
fn not(a: gvec3b) = gPrefix('!', 'not', a);
fn not(a: gvec4u) = gPrefix('!', 'not', a);
fn not(a: gvec4i) = gPrefix('!', 'not', a);
fn not(a: gvec4b) = gPrefix('!', 'not', a);

fn or(a: gu32, b: gu32) = gInfix('|', 'or', a, b);
fn or{T}(a: gu32, b: T) = gInfix('|', 'or', a, b.gu32);
fn or{T}(a: T, b: gu32) = gInfix('|', 'or', a.gu32, b);
fn or(a: gi32, b: gi32) = gInfix('|', 'or', a, b);
fn or{T}(a: gi32, b: T) = gInfix('|', 'or', a, b.gi32);
fn or{T}(a: T, b: gi32) = gInfix('|', 'or', a.gi32, b);
fn or(a: gbool, b: gbool) = gInfix('|', 'or', a, b);
fn or{T}(a: gbool, b: T) = gInfix('|', 'or', a, b.gbool);
fn or{T}(a: T, b: gbool) = gInfix('|', 'or', a.gbool, b);
fn or(a: gvec2u, b: gvec2u) = gInfix('|', 'or', a, b);
fn or(a: gvec2i, b: gvec2i) = gInfix('|', 'or', a, b);
fn or(a: gvec2b, b: gvec2b) = gInfix('|', 'or', a, b);
fn or(a: gvec3u, b: gvec3u) = gInfix('|', 'or', a, b);
fn or(a: gvec3i, b: gvec3i) = gInfix('|', 'or', a, b);
fn or(a: gvec3b, b: gvec3b) = gInfix('|', 'or', a, b);
fn or(a: gvec4u, b: gvec4u) = gInfix('|', 'or', a, b);
fn or(a: gvec4i, b: gvec4i) = gInfix('|', 'or', a, b);
fn or(a: gvec4b, b: gvec4b) = gInfix('|', 'or', a, b);

fn and(a: gu32, b: gu32) = gInfix('&', 'and', a, b);
fn and{T}(a: gu32, b: T) = gInfix('&', 'and', a, b.gu32);
fn and{T}(a: T, b: gu32) = gInfix('&', 'and', a.gu32, b);
fn and(a: gi32, b: gi32) = gInfix('&', 'and', a, b);
fn and{T}(a: gi32, b: T) = gInfix('&', 'and', a, b.gi32);
fn and{T}(a: T, b: gi32) = gInfix('&', 'and', a.gi32, b);
fn and(a: gbool, b: gbool) = gInfix('&&', 'and', a, b);
fn and{T}(a: gbool, b: T) = gInfix('&&', 'and', a, b.gbool);
fn and{T}(a: T, b: gbool) = gInfix('&&', 'and', a.gbool, b);
fn and(a: gvec2u, b: gvec2u) = gInfix('&', 'and', a, b);
fn and(a: gvec2i, b: gvec2i) = gInfix('&', 'and', a, b);
fn and(a: gvec2b, b: gvec2b) = gInfix('&&', 'and', a, b);
fn and(a: gvec3u, b: gvec3u) = gInfix('&', 'and', a, b);
fn and(a: gvec3i, b: gvec3i) = gInfix('&', 'and', a, b);
fn and(a: gvec3b, b: gvec3b) = gInfix('&&', 'and', a, b);
fn and(a: gvec4u, b: gvec4u) = gInfix('&', 'and', a, b);
fn and(a: gvec4i, b: gvec4i) = gInfix('&', 'and', a, b);
fn and(a: gvec4b, b: gvec4b) = gInfix('&&', 'and', a, b);

fn xor(a: gu32, b: gu32) = gInfix('^', 'xor', a, b);
fn xor{T}(a: gu32, b: T) = gInfix('^', 'xor', a, b.gu32);
fn xor{T}(a: T, b: gu32) = gInfix('^', 'xor', a.gu32, b);
fn xor(a: gi32, b: gi32) = gInfix('^', 'xor', a, b);
fn xor{T}(a: gi32, b: T) = gInfix('^', 'xor', a, b.gi32);
fn xor{T}(a: T, b: gi32) = gInfix('^', 'xor', a.gi32, b);
fn xor(a: gbool, b: gbool) = gInfix('!=', 'xor', a, b);
fn xor{T}(a: gbool, b: T) = gInfix('!=', 'xor', a, b.gbool);
fn xor{T}(a: T, b: gbool) = gInfix('!=', 'xor', a.gbool, b);
fn xor(a: gvec2u, b: gvec2u) = gInfix('^', 'xor', a, b);
fn xor(a: gvec2i, b: gvec2i) = gInfix('^', 'xor', a, b);
fn xor(a: gvec2b, b: gvec2b) = gInfix('!=', 'xor', a, b);
fn xor(a: gvec3u, b: gvec3u) = gInfix('^', 'xor', a, b);
fn xor(a: gvec3i, b: gvec3i) = gInfix('^', 'xor', a, b);
fn xor(a: gvec3b, b: gvec3b) = gInfix('!=', 'xor', a, b);
fn xor(a: gvec4u, b: gvec4u) = gInfix('^', 'xor', a, b);
fn xor(a: gvec4i, b: gvec4i) = gInfix('^', 'xor', a, b);
fn xor(a: gvec4b, b: gvec4b) = gInfix('!=', 'xor', a, b);

fn shl(a: gu32, b: gu32) = gInfix('<<', 'shl', a, b);
fn shl{T}(a: gu32, b: T) = gInfix('<<', 'shl', a, b.gu32);
fn shl{T}(a: T, b: gu32) = gInfix('<<', 'shl', a.gu32, b);
fn shl(a: gi32, b: gi32) = gInfix('<<', 'shl', a, b);
fn shl{T}(a: gi32, b: T) = gInfix('<<', 'shl', a, b.gi32);
fn shl{T}(a: T, b: gi32) = gInfix('<<', 'shl', a.gi32, b);
fn shl(a: gvec2u, b: gvec2u) = gInfix('<<', 'shl', a, b);
fn shl(a: gvec2i, b: gvec2i) = gInfix('<<', 'shl', a, b);
fn shl(a: gvec3u, b: gvec3u) = gInfix('<<', 'shl', a, b);
fn shl(a: gvec3i, b: gvec3i) = gInfix('<<', 'shl', a, b);
fn shl(a: gvec4u, b: gvec4u) = gInfix('<<', 'shl', a, b);
fn shl(a: gvec4i, b: gvec4i) = gInfix('<<', 'shl', a, b);

fn shr(a: gu32, b: gu32) = gInfix('>>', 'shr', a, b);
fn shr{T}(a: gu32, b: T) = gInfix('>>', 'shr', a, b.gu32);
fn shr{T}(a: T, b: gu32) = gInfix('>>', 'shr', a.gu32, b);
fn shr(a: gi32, b: gi32) = gInfix('>>', 'shr', a, b);
fn shr{T}(a: gi32, b: T) = gInfix('>>', 'shr', a, b.gi32);
fn shr{T}(a: T, b: gi32) = gInfix('>>', 'shr', a.gi32, b);
fn shr(a: gvec2u, b: gvec2u) = gInfix('>>', 'shr', a, b);
fn shr(a: gvec2i, b: gvec2i) = gInfix('>>', 'shr', a, b);
fn shr(a: gvec3u, b: gvec3u) = gInfix('>>', 'shr', a, b);
fn shr(a: gvec3i, b: gvec3i) = gInfix('>>', 'shr', a, b);
fn shr(a: gvec4u, b: gvec4u) = gInfix('>>', 'shr', a, b);
fn shr(a: gvec4i, b: gvec4i) = gInfix('>>', 'shr', a, b);

/// GPGPU Bitcasting functions

fn gbitcast{I, O}(v: I) {
  let typename = {O.typeName}();
  let varName = 'bitcast_'.concat(typename).concat('_').concat(uuid().string.replace('-', '_'));
  let statement = 'var '
    .concat(varName)
    .concat(' = ')
    .concat('bitcast<')
    .concat(typename)
    .concat('>(')
    .concat(v.varName)
    .concat(')');
  let statements = v.statements.concat(Dict(varName, statement));
  let buffers = v.buffers.clone;
  return {O}(varName, statements, buffers);
}
fn asU32(v: gu32) = v;
fn asU32(v: gi32) = gbitcast{gi32, gu32}(v);
fn asU32(v: gf32) = gbitcast{gf32, gu32}(v);
fn asI32(v: gu32) = gbitcast{gu32, gi32}(v);
fn asI32(v: gi32) = v;
fn asI32(v: gf32) = gbitcast{gf32, gi32}(v);
fn asF32(v: gu32) = gbitcast{gu32, gf32}(v);
fn asF32(v: gi32) = gbitcast{gi32, gf32}(v);
fn asF32(v: gf32) = v;
fn asVec2u(v: gvec2u) = v;
fn asVec2u(v: gvec2i) = gbitcast{gvec2i, gvec2u}(v);
fn asVec2u(v: gvec2f) = gbitcast{gvec2f, gvec2u}(v);
fn asVec2i(v: gvec2u) = gbitcast{gvec2u, gvec2i}(v);
fn asVec2i(v: gvec2i) = v;
fn asVec2i(v: gvec2f) = gbitcast{gvec2f, gvec2i}(v);
fn asVec2f(v: gvec2u) = gbitcast{gvec2u, gvec2f}(v);
fn asVec2f(v: gvec2i) = gbitcast{gvec2i, gvec2f}(v);
fn asVec2f(v: gvec2f) = v;
fn asVec3u(v: gvec3u) = v;
fn asVec3u(v: gvec3i) = gbitcast{gvec3i, gvec3u}(v);
fn asVec3u(v: gvec3f) = gbitcast{gvec3f, gvec3u}(v);
fn asVec3i(v: gvec3u) = gbitcast{gvec3u, gvec3i}(v);
fn asVec3i(v: gvec3i) = v;
fn asVec3i(v: gvec3f) = gbitcast{gvec3f, gvec3i}(v);
fn asVec3f(v: gvec3u) = gbitcast{gvec3u, gvec3f}(v);
fn asVec3f(v: gvec3i) = gbitcast{gvec3i, gvec3f}(v);
fn asVec3f(v: gvec3f) = v;
fn asVec4u(v: gvec4u) = v;
fn asVec4u(v: gvec4i) = gbitcast{gvec4i, gvec4u}(v);
fn asVec4u(v: gvec4f) = gbitcast{gvec4f, gvec4u}(v);
fn asVec4i(v: gvec4u) = gbitcast{gvec4u, gvec4i}(v);
fn asVec4i(v: gvec4i) = v;
fn asVec4i(v: gvec4f) = gbitcast{gvec4f, gvec4i}(v);
fn asVec4f(v: gvec4u) = gbitcast{gvec4u, gvec4f}(v);
fn asVec4f(v: gvec4i) = gbitcast{gvec4i, gvec4f}(v);
fn asVec4f(v: gvec4f) = v;

/// CPU and GPGPU miscellaneous Vector functions

fn every(v: gvec2b) = gFn1('all', v);
fn every(v: gvec3b) = gFn1('all', v);
fn every(v: gvec4b) = gFn1('all', v);

fn some(v: gvec2b) = gFn1('any', v);
fn some(v: gvec3b) = gFn1('any', v);
fn some(v: gvec4b) = gFn1('any', v);

fn if(c: gvec2b, t: gvec2u, f: gvec2u) = gFn3{gvec2b, gvec2u, gvec2u, gvec2u}('select', c, t, f);
fn if(c: gvec2b, t: gvec2i, f: gvec2i) = gFn3{gvec2b, gvec2i, gvec2i, gvec2i}('select', c, t, f);
fn if(c: gvec2b, t: gvec2f, f: gvec2f) = gFn3{gvec2b, gvec2f, gvec2f, gvec2f}('select', c, t, f);
fn if(c: gvec2b, t: gvec2b, f: gvec2b) = gFn3{gvec2b, gvec2b, gvec2b, gvec2b}('select', c, t, f);
fn if(c: gvec3b, t: gvec3u, f: gvec3u) = gFn3{gvec3b, gvec3u, gvec3u, gvec3u}('select', c, t, f);
fn if(c: gvec3b, t: gvec3i, f: gvec3i) = gFn3{gvec3b, gvec3i, gvec3i, gvec3i}('select', c, t, f);
fn if(c: gvec3b, t: gvec3f, f: gvec3f) = gFn3{gvec3b, gvec3f, gvec3f, gvec3f}('select', c, t, f);
fn if(c: gvec3b, t: gvec3b, f: gvec3b) = gFn3{gvec3b, gvec3b, gvec3b, gvec3b}('select', c, t, f);
fn if(c: gvec4b, t: gvec4u, f: gvec4u) = gFn3{gvec4b, gvec4u, gvec4u, gvec4u}('select', c, t, f);
fn if(c: gvec4b, t: gvec4i, f: gvec4i) = gFn3{gvec4b, gvec4i, gvec4i, gvec4i}('select', c, t, f);
fn if(c: gvec4b, t: gvec4f, f: gvec4f) = gFn3{gvec4b, gvec4f, gvec4f, gvec4f}('select', c, t, f);
fn if(c: gvec4b, t: gvec4b, f: gvec4b) = gFn3{gvec4b, gvec4b, gvec4b, gvec4b}('select', c, t, f);

fn pack4x8snorm(v: gvec4f) = gFn1{gvec4f, gu32}('pack4x8snorm', v);
fn pack4x8snorm(v: f32[4]) {
  let a = floor(127.f32 * v.0.min(1.f32).max(-1.f32)).i8.asU8.u32 << 24.u32;
  let b = floor(127.f32 * v.1.min(1.f32).max(-1.f32)).i8.asU8.u32 << 16.u32;
  let c = floor(127.f32 * v.2.min(1.f32).max(-1.f32)).i8.asU8.u32 << 8.u32;
  let d = floor(127.f32 * v.3.min(1.f32).max(-1.f32)).i8.asU8.u32;
  return a + b + c + d;
}

fn pack4x8unorm(v: gvec4f) = gFn1{gvec4f, gu32}('pack4x8unorm', v);
fn pack4x8unorm(v: f32[4]) {
  let a = floor(0.5.f32 + 255.f32 * v.0.min(1.f32).max(0.f32)).u32 << 24.u32;
  let b = floor(0.5.f32 + 255.f32 * v.1.min(1.f32).max(0.f32)).u32 << 16.u32;
  let c = floor(0.5.f32 + 255.f32 * v.2.min(1.f32).max(0.f32)).u32 << 8.u32;
  let d = floor(0.5.f32 + 255.f32 * v.3.min(1.f32).max(0.f32)).u32;
  return a + b + c + d;
}

fn pack2x16snorm(v: gvec2f) = gFn1{gvec2f, gu32}('pack2x16snorm', v);
fn pack2x16snorm(v: f32[2]) {
  let a = floor(32767.f32 * v.0.min(1.f32).max(-1.f32)).i16.asU16.u32 << 16.u32;
  let b = floor(32767.f32 * v.1.min(1.f32).max(-1.f32)).i16.asU16.u32;
  return a + b;
}

fn pack2x16unorm(v: gvec2f) = gFn1{gvec2f, gu32}('pack2x16unorm', v);
fn pack2x16unorm(v: f32[2]) {
  let a = floor(0.5.f32 + 65535.f32 * v.0.min(1.f32).max(0.f32)).u32 << 16.u32;
  let b = floor(0.5.f32 + 65535.f32 * v.1.min(1.f32).max(0.f32)).u32;
  return a + b;
}

fn pack2x16float(v: gvec2f) = gFn1{gvec2f, gu32}('pack2x16float', v);
// No CPU-side equivalent as `f16` is only available in Rust nightly and not at all in JS-land.

fn unpack4x8snorm(v: gu32) = gFn1{gu32, gvec4f}('unpack4x8snorm', v);
fn unpack4x8snorm(v: u32) {
  let d = max(-1.f32, (v & 255.u32).f32 / 127.f32);
  let v2 = v.clone >> 8.u32;
  let c = max(-1.f32, (v2 & 255.u32).f32 / 127.f32);
  let v3 = v2.clone >> 8.u32;
  let b = max(-1.f32, (v3 & 255.u32).f32 / 127.f32);
  let v4 = v3.clone >> 8.u32;
  let a = max(-1.f32, (v4 & 255.u32).f32 / 127.f32);
  return {f32[4]}(a, b, c, d);
}

fn unpack4x8unorm(v: gu32) = gFn1{gu32, gvec4f}('unpack4x8unorm', v);
fn unpack4x8unorm(v: u32) {
  let d = (v & 255.u32).f32 / 255.f32;
  let v2 = v.clone >> 8.u32;
  let c = (v2 & 255.u32).f32 / 255.f32;
  let v3 = v2.clone >> 8.u32;
  let b = (v3 & 255.u32).f32 / 255.f32;
  let v4 = v3.clone >> 8.u32;
  let a = (v4 & 255.u32).f32 / 255.f32;
  return {f32[4]}(a, b, c, d);
}


fn unpack2x16snorm(v: gu32) = gFn1{gu32, gvec2f}('unpack2x16snorm', v);
fn unpack2x16snorm(v: u32) {
  let b = max(-1.f32, (v & 65535.u32).f32 / 32767.f32);
  let v2 = v.clone >> 16.u32;
  let a = max(-1.f32, (v2 & 65535.u32).f32 / 32767.f32);
  return {f32[2]}(a, b);
}

fn unpack2x16unorm(v: gu32) = gFn1{gu32, gvec2f}('unpack2x16unorm', v);
fn unpack2x16unorm(v: u32) {
  let b = (v & 65535.u32).f32 / 65535.f32;
  let v2 = v.clone >> 16.u32;
  let a = (v2 & 65535.u32).f32 / 65535.f32;
  return {f32[2]}(a, b);
}

fn unpack2x16float(v: gu32) = gFn1{gu32, gvec2f}('unpack2x16float', v);
// Also not doing this on the CPU side

// storageBarrier is a synchronization mechanism on writes to storage buffers up to that point, to
// make sure further reads/writes can expect all prior logical reads/writes to have completed. This
// can be useful for operations where you need multiple prior outputs as the new input, like doing
// a gaussian blur on an image, the current pixel is dependent on a set of pixels surrounding it, so
// rather than having two different shaders, one to first create the image buffer and the second to
// blur it, you can combine them and insert the storage barrier between the steps to avoid the extra
// machinery of another shader compilation and work scheduling, or you could do it in a loop which
// would be infeasible otherwise. It's a pure side-effect function, though, so using it "properly"
// in the GPGPU binding in Alan is trickier. (Really only possible with the array-based `run`.
fn storageBarrier() = WgpuType{"storageBarrier"}(
  "storageBarrier()", Dict("storageBarrier()", "storageBarrier()"), Set{GBufferTagged}()
);

/// GBuffer-specific functions

fn map{G, G2}(gb: GBuffer{G}, f: Prop{WgpuTypeMap, String{G}} -> Prop{WgpuTypeMap, String{G2}}) {
  let idx = gFor(gb.cpulen);
  let val = gb[idx];
  let out = GBuffer{G2}(gb.cpulen)!!;
  let compute = out[idx].store(f(val));
  compute.build.run;
  return out;
}
fn map{G, G2}(gb: GBuffer{G}, f: (Prop{WgpuTypeMap, String{G}}, gu32) -> Prop{WgpuTypeMap, String{G2}}) {
  let idx = gFor(gb.cpulen);
  let val = gb[idx];
  let out = GBuffer{G2}(gb.cpulen)!!;
  let compute = out[idx].store(f(val, idx));
  compute.build.run;
  return out;
}

/// GPU Rendering-related functions
type{Rs} Window = Binds{"alan_std::AlanWindowContext" <- RootBacking};
type{Js} Window = Binds{"AlanWindowContext"};
type{Rs} Frame = Binds{"alan_std::AlanWindowFrame" <- RootBacking};
type{Js} Frame = Binds{"AlanWindowFrame"};

fn{Rs} window "alan_std::run_window" <- RootBacking :: (Mut{(Mut{Window}) -> ()}, Mut{(Mut{Window}) -> u32[]}, (Frame) -> GPGPU[]) -> ()!;
fn{Js} window "alan_std.runWindow" <- RootBacking :: (Window -> (), Window -> u32[], Frame -> GPGPU[]) -> ()!;
fn{Rs} width Method{"width"} :: Window -> u32;
fn{Js} width "alan_std.contextWidth" <- RootBacking :: Window -> u32;
fn{Rs} height Method{"height"} :: Window -> u32;
fn{Js} height "alan_std.contextHeight" <- RootBacking :: Window -> u32;
fn{Rs} bufferWidth Method{"buffer_width"} :: Window -> u32;
fn{Js} bufferWidth "alan_std.contextBufferWidth" <- RootBacking :: Window -> u32;
fn{Rs} mouseX Method{"mouse_x"} :: Mut{Window} -> u32;
fn{Js} mouseX "alan_std.contextMouseX" <- RootBacking :: Window -> u32;
fn{Rs} mouseY Method{"mouse_y"} :: Mut{Window} -> u32;
fn{Js} mouseY "alan_std.contextMouseY" <- RootBacking :: Window -> u32;
fn{Rs} cursorVisible Method{"cursor_visible"} :: Mut{Window} -> ();
fn{Js} cursorVisible "alan_std.contextCursorVisible" <- RootBacking :: Window -> ();
fn{Rs} cursorInvisible Method{"cursor_invisible"} :: Mut{Window} -> ();
fn{Js} cursorInvisible "alan_std.contextCursorInvisible" <- RootBacking :: Window -> ();
fn{Rs} transparent Method{"transparent"} :: Mut{Window} -> ();
fn{Js} transparent "alan_std.contextTransparent" <- RootBacking :: Window -> ();
fn{Rs} opaque Method{"opaque"} :: Mut{Window} -> ();
fn{Js} opaque "alan_std.contextOpaque" <- RootBacking :: Window -> ();
fn{Rs} runtime Method{"runtime"} :: Window -> u32;
fn{Js} runtime "alan_std.contextRuntime" <- RootBacking :: Window -> u32;
fn{Js} canvas "alan_std.contextCanvas" <- RootBacking :: (Window, string) -> ();
// TODO: Be less opinionated on the context and framebuffer types, maybe?
fn{Rs} context(f: Frame) = GBuffer{u32}({Property{"context.clone()"} :: Frame -> GBufferRaw}(f));
fn{Js} context(f: Frame) = GBuffer{u32}({"alan_std.frameContext" <- RootBacking :: Frame -> GBufferRaw}(f));
fn{Rs} framebuffer(f: Frame) = GBuffer{u32}({Property{"framebuffer.clone()"} :: Frame -> GBufferRaw}(f));
fn{Js} framebuffer(f: Frame) = GBuffer{u32}({"alan_std.frameFramebuffer" <- RootBacking :: Frame -> GBufferRaw}(f));
fn pixel Frame = gFor(-1, -2); // Magic numbers for the binding

/// Process exit-related functions
fn{Rs} ExitCode "std::process::ExitCode::from" :: Own{u8} -> ExitCode;
fn{Js} ExitCode "Number" :: u8 -> ExitCode;
fn ExitCode(e: u16) = ExitCode(e.u8);
fn ExitCode(e: u32) = ExitCode(e.u8);
fn ExitCode(e: u64) = ExitCode(e.u8);
fn ExitCode(e: i8) = ExitCode(e.u8);
fn ExitCode(e: i16) = ExitCode(e.u8);
fn ExitCode(e: i32) = ExitCode(e.u8);
fn ExitCode(e: i64) = ExitCode(e.u8);

/// Stdout/stderr-related functions
// TODO: Rework this to just print anything that can be converted to `string` via interfaces
fn{Rs} print{T}(v: T) = {"println!" :: ("{}", string)}(v.string);
fn{Js} print{T}(v: T) = {"console.log" :: T}(v);
fn{Js} print{T}(v: T[]) = {"((vs) => console.log(vs.map((v) => v.valueOf())))" :: T[]}(v);
fn{Js} print "((s) => console.log(s.val))" :: string;
fn{Js} print (b: bool) = b.string.print;
fn{Js} print (i: i8) = i.string.print;
fn{Js} print (u: u8) = u.string.print;
fn{Js} print (i: i16) = i.string.print;
fn{Js} print (u: u16) = u.string.print;
fn{Js} print (i: i32) = i.string.print;
fn{Js} print (u: u32) = u.string.print;
fn{Js} print (i: i64) = i.string.print;
fn{Js} print (u: u64) = u.string.print;
fn{Js} print (f: f32) = f.string.print;
fn{Js} print (f: f64) = f.string.print;
fn{Js} print (i: i64[]) = "[".concat(i.map(string).join(", ")).concat("]").print;
fn{Js} print (u: u64[]) = "[".concat(u.map(string).join(", ")).concat("]").print;
fn{Js} print{S} (i: Buffer{i64, S}) = "[".concat(i.map(string).join(", ")).concat("]").print;
fn{Js} print{S} (u: Buffer{u64, S}) = "[".concat(u.map(string).join(", ")).concat("]").print;
fn{Js} print (e: Error) = "Error: ".concat(e.string).print;
fn{Rs} print (d: Duration) = {"println!" :: ("{}.{:0>9}", u64, u32)}(
  {Method{"as_secs"} :: Duration -> u64}(d),
  {Method{"subsec_nanos"} :: Duration -> u32}(d));
fn{Rs} print(v: void) = {"println!" :: "void"}();
fn{Js} print(v: void) = {"console.log" :: "void"}();
fn{Rs} print(s: string) = {"println!" :: ("{}", string)}(s);
fn{Rs} print{T, N}(a: T[N]) = "[".concat(a.map(fn (v: T) = string(v)).join(", ")).concat("]").print;
fn{Rs} print{T}(a: T[]) = "[".concat(a.map(fn (v: T) = string(v)).join(", ")).concat("]").print;
fn print{T}(v: T?) = if(v.exists,
  fn = print(v!!),
  fn = print("void"));
fn print{T}(v: T!) = if({T}(v).exists,
  fn = print(v!!),
  fn = print(v.Error!!));
fn{Js} print{T}(v: void!) = if({T}(v).exists,
  fn = "void".print,
  fn = print(v.Error!!));
fn{Rs} eprint{T}(v: T) = {"eprintln!" :: ("{}", string)}(v.string);
fn{Js} eprint{T}(v: T) = {"console.error" :: string}(v.string);
fn{Rs} eprint(v: void) = {"eprintln!" :: "void"}();
fn{Js} eprint(v: void) = {"console.error" :: "void"}();
fn{Rs} eprint(s: string) = {"eprintln!" :: ("{}", string)}(s);
fn{Js} eprint "((s) => console.error(s.val))" :: string;
fn{Js} eprint (b: bool) = b.string.print;
fn{Js} eprint (i: i8) = i.string.print;
fn{Js} eprint (u: u8) = u.string.print;
fn{Js} eprint (i: i16) = i.string.print;
fn{Js} eprint (u: u16) = u.string.print;
fn{Js} eprint (i: i32) = i.string.print;
fn{Js} eprint (u: u32) = u.string.print;
fn{Js} eprint (i: i64) = i.string.print;
fn{Js} eprint (u: u64) = u.string.print;
fn{Js} eprint (f: f32) = f.string.print;
fn{Js} eprint (f: f64) = f.string.print;
fn{Js} eprint (i: i64[]) = "[".concat(i.map(string).join(", ")).concat("]").print;
fn{Js} eprint (u: u64[]) = "[".concat(u.map(string).join(", ")).concat("]").print;
fn{Rs} eprint{T}(a: T[]) = "[".concat(a.map(string).join(", ")).concat("]").eprint;
fn{Rs} eprint{T}(v: T?) = if(v.exists,
  fn = eprint(v!!),
  fn = eprint("void"));
fn{Rs} eprint{T}(v: T!) = if({T}(v).exists,
  fn = eprint(v!!),
  fn = eprint(v.Error!!));

fn{Rs} stdout (s: string) {
  {"print!" :: ("{}", string)}(s);
  {"std::io::stdout().flush" :: () -> ()}();
}
fn{Js} stdout "((s) => process.stdout.write(s.val))" :: string;
fn{Rs} stderr (s: string) {
  {"eprint!" :: ("{}", string)}(s);
  {"std::io::stderr().flush" :: () -> ()}();
}
fn{Js} stderr "((s) => process.stderr.write(s.val))" :: string;

/// Testing types and functions
/*
 * This is what I *want*, but the Rust codegen is trying to clone the array of closure functions,
 * which is *not* cloneable, and I don't want to have to gate testing on a complete rewrite of the
 * last stage of the compiler, so I'm going to go with a simpler implementation for now and leave
 * this partial implementation in the root scope as a comment to hopefully revive. I am pretty sure
 * that the only thing I'll be missing out on is the ability to make a progress bar because the
 * simpler implementation won't know how many tests are left to run.

type{Test} AssertOutput = actual: string, expected: string, success: bool;
type{Test} Assert = () -> AssertOutput;
type{Test} It = testname: string, assertions: Array{Assert};
type{Test} Describe = groupname: string, tests: Array{It};
type{Test} Testing = Array{Describe};

fn{Test} describe(groupname: string) = Testing(Describe(groupname, Array{It}()));
fn{Test} describe(testing: Mut{Testing}, groupname: string) {
  testing.push(Describe(groupname, Array{It}()));
  return testing;
}
fn{Test} describe(groupname: string, callback: Mut{Testing} -> ()) {
  let testing = Testing(Describe(groupname, Array{It}()));
  callback(testing);
  return testing;
}
fn{Test} describe(testing: Mut{Testing}, groupname: string, callback: Mut{Testing} -> ()) {
  testing.push(Describe(groupname, Array{It}()));
  callback(testing);
  return testing;
}
fn{Test} describe(groupname: string, callback: Mut{Testing} -> Testing) {
  let testing = Testing(Describe(groupname, Array{It}()));
  callback(testing);
  return testing;
}
fn{Test} describe(testing: Mut{Testing}, groupname: string, callback: Mut{Testing} -> Testing) {
  testing.push(Describe(groupname, Array{It}()));
  callback(testing);
  return testing;
}

fn{Test} it(testing: Mut{Testing}, testname: string) {
  testing.last.getOrExit.tests.push(It(testname, Array{Assert}()));
  return testing;
}
fn{Test} it(testing: Mut{Testing}, testname: string, callback: Mut{Testing} -> ()) {
  testing.last.getOrExit.tests.push(It(testname, Array{Assert}()));
  callback(testing);
  return testing;
}
fn{Test} it(testing: Mut{Testing}, testname: string, callback: Mut{Testing} -> Testing) {
  testing.last.getOrExit.tests.push(It(testname, Array{Assert}()));
  callback(testing);
  return testing;
}

fn{Test} assert{T}(testing: Mut{Testing}, comparator: (T, T) -> bool, actual: T, expected: T) {
  testing.last.getOrExit.tests.last.getOrExit.assertions.push(fn = AssertOutput(actual.string, expected.string, comparator(actual, expected)));
  return testing;
}

fn{Test} report(testing: Testing) {
  let numTests = testing.reduce(0, fn (cum: i64, d: Describe) = cum.add(d.tests.len));
  "Test count: ".concat(numTests.string).print;
}

 */

type{Test} Testing = Array{string}; // To prevent porting issues when the desired test runner works
fn{Test} Testing = Testing("Start");

fn{Test} describe(groupname: string) = [groupname];
fn{Test} describe(groupname: string, callback: string[] -> ()) {
  callback([groupname]);
  return [groupname];
}
fn{Test} describe(groupname: string, callback: string[] -> string[]) {
  callback([groupname]);
  return [groupname];
}
fn{Test} describe(prevgroupname: string[], groupname: string) = [groupname];
fn{Test} describe(prevgroupname: string[], groupname: string, callback: string[] -> ()) {
  callback([groupname]);
  return [groupname];
}
fn{Test} describe(prevgroupname: string[], groupname: string, callback: string[] -> string[]) {
  callback([groupname]);
  return [groupname];
}

fn{Test} it(groupname: string[], testname: string) {
  if(groupname.len > 1, fn = groupname.pop, fn = Maybe{string}(""));
  groupname.push(testname);
  return groupname;
}
fn{Test} it(groupname: string[], testname: string, callback: string[] -> ()) {
  if(groupname.len > 1, fn = groupname.pop, fn = Maybe{string}(""));
  groupname.push(testname);
  callback(groupname);
  return groupname;
}
fn{Test} it(groupname: string[], testname: string, callback: string[] -> string[]) {
  if(groupname.len > 1, fn = groupname.pop, fn = Maybe{string}(""));
  groupname.push(testname);
  callback(groupname);
  return groupname;
}

fn{Test} assert{T}(groupname: string[], comparator: (T, T) -> bool, actual: T, expected: T) {
  let line = groupname.join(' ');
  "\u{1b}[33;1m ".stdout;
  line.stdout;
  "\u{1b}[0m".stdout;
  let res = comparator(actual, expected);
  if(res,
    fn { "\u{0d}\u{1b}[32;1m".stdout; },
    fn { "\u{0d}\u{1b}[31;1m".stdout; });
  line.stdout;
  "\u{1b}[0m".print;
  if(!res, fn {
    "\u{1b}[31;1mTest Failure\u{1b}[0m".eprint;
    Maybe{i64}()!!;
  }, fn {
    "".stdout;
  }); // TODO: Better way to force an exit */
  return groupname;
}

fn{Test} report(groupname: string[]) {
  "\u{1b}[32;1mSuccess!\u{1b}[0m".print;
}
