
from @std/app import start, print, exit

on start {
  const test = [ 1, 1, 2, 3, 5, 8 ];
  const test2 = [ 4, 5, 6 ];
  print('reduce test');
  test.reduce(fn (a: int, b: int): int = a + b || 0).print();
  test.reduce(min).print();
  test.reduce(max).print();

  print('filter test');
  test.filter(fn (val: int64): bool {
    return val % 2 == 1;
  }).map(fn (val: int64): string {
    return toString(val);
  }).join(', ').print();

  print('concat test');
  test.concat(test2).map(fn (val: int64): string {
    return toString(val);
  }).join(', ').print();
  (test + test2).map(fn (val: int64): string {
    return toString(val);
  }).join(', ').print();

  print('reduce as filter and concat test');
  // TODO: Lots of improvements needed for closures passed directly to opcodes. This one-liner is ridiculous
  test.reduce(fn (acc: string, i: int): string = ((acc == '') && (i % 2 == 1)) ? i.toString() : (i % 2 == 1 ? (acc + ', ' + i.toString()) : acc), '').print();
  // TODO: Even more ridiculous when you want to allow parallelism
  test.reducePar(fn (acc: string, i: int): string = ((acc == '') && (i % 2 == 1)) ? i.toString() : (i % 2 == 1 ? (acc + ', ' + i.toString()) : acc), fn (acc: string, cur: string): string = ((acc != '') && (cur != '')) ? (acc + ', ' + cur) : (acc != '' ? acc : cur), '').print();

  emit exit 0;
}

