/**
 * The Alan root scope. The functions and types it binds from Rust are either part of the standard
 * library, or are defined in the sibling root.rs file
 **/

/// Type system setup

// Declaration of the types the compiler-time type system is built on
export ctype Type; // Any kind of concrete type
export ctype Generic; // Any type that is a generic type (not yet realized into a concrete type)
export ctype Binds{T}; // A direct reference into the platform language's type system
export ctype Int; // An integer used *to define a type*, like the length of a fixed array
export ctype Float; // A float used to define a type. I have no idea why you'd want this, yet
export ctype Bool; // A bool used to define a type. Heavily used for conditional compilation
export ctype String; // A string used to define a type. Useful for conditional inclusion of files/code
export ctype Group{G}; // A grouping of type statements `()`. Useful to allow for tuples of tuples
export ctype Function{I, O}; // A function type, indicating the input and output of the function
export ctype Call{N, F}; // A reference to a function call (or method, etc) in the platform language
export ctype Infix{O}; // A reference to a native infix operation in the platform language
export ctype Prefix{O}; // A reference to a native prefix operation in the platform language
export ctype Method{F}; // A reference to a native method in the platform language
export ctype Property{P}; // A reference to a native property in the platform language
export ctype Cast{T}; // A reference to a native type in the platform language to cast to
export ctype Own{T}; // Specifying that the native code needs an owned version of the type
export ctype Deref{T}; // Specifying that the native code needs an owned version of the type and it is safe to dereference the reference
export ctype Mut{T}; // Specifying that the function (native or otherwise) needs a mutable reference of the type
export ctype Dependency{N, V}; // The representation of a dependency (of some form or another). Does nothing on its own
export ctype Rust{D}; // Specifying that the provided dependency is a Rust dependency.
export ctype Node{D}; // Specifying that the provided dependency is a Node.js dependency.
export ctype From{D}; // Pulls the desired value from the dependency. Magically figures out which is needed through compiler trickery.
export ctype Import{N, D}; // Imports the named value from the dependency.
export ctype Tuple{A, B}; // A tuple of two (or more) types in a single compound type
export ctype Field{L, V}; // Labeling a type with a property name. Useful to turn tuples into structs
export ctype Either{A, B}; // An either type, allowing the value to be from *one* of the specified types, kinda like Rust enums
export ctype Prop{T, P}; // Extracts the inner type from the outer type by the property name or number
export ctype AnyOf{A, B}; // The AnyOf type is kinda like a Tuple, in that all sub-types are present, but it only *resolves* into one of these types above it. Useful for choosing the "best" integer, or a particular function by name.
export ctype Buffer{T, S}; // A buffer type, a pre-allocated, fixed-length array of the specified type the specified amount
export ctype Array{T}; // An array type, a variable-length array of the specified type the specified amount. This would usually be an stdlib type built in the language itself, but we're just going to re-use the one in the platform language

// The following `ctype`s don't represent data but instead represent transforms that convert into one of the many ctypes above. (I did not expect to need so many of them.)
export ctype Fail{M}; // A special type that if ever encountered at compile time causes the compilation to fail with the specified error message. Useful with conditional types
export ctype Add{A, B}; // Combines the Int or Float types together at compile time into a new Int or Float. Fails if an Int and Float are mixed.
export ctype Sub{A, B}; // Same, but subtracts them
export ctype Mul{A, B}; // Multiplication
export ctype Div{A, B}; // Division
export ctype Mod{A, B}; // Modulus (remainder)
export ctype Pow{A, B}; // Exponentiation/Power
export ctype Min{A, B}; // Minimum value of the two
export ctype Max{A, B}; // Maximum value of the two
export ctype Neg{A}; // Negate the value
export ctype Len{A}; // Returns the length of the input type in terms of the number of elements it contains, which is most useful for Buffers, Tuples, and Either, causes a compiler failure for Arrays, and returns 1 for everything else
export ctype Size{T}; // Returns the size in bytes of the type in question, if possible, causing a compiler failure otherwise.
export ctype FileStr{F}; // Read a file and return a string constant, useful for including large strings from a separate, nearby file, or fails if it doesn't exist
export ctype Env{K}; // Read an environment variable at compile time and return a string of the value. Returns an empty string if the key doesn't exist. Intended to be used with...
export ctype EnvExists{K}; // Returns a boolean if the environment variable key exists at compile time, and...
export ctype If{C, A, B}; // A conditional type, if C is true, resolves to A, otherwise to B. There's also a simpler version...
export ctype If{C, T}; // That expects a two-type tuple and extracts the first tuple type for true and the second for false, which can be bound to symbolic syntax
export ctype Env{K, D}; // Finally, since the majority of the time this is what you'd want, this variant of `Env` takes a default value to use when the key does not exist, making this another conditional type
export ctype And{A, B}; // Performs a boolean or bitwise AND on the inputs, depending on type
export ctype Or{A, B}; // Performs a boolean or bitwise OR on the inputs
export ctype Xor{A, B}; // Performs a boolean or bitwise XOR on the inputs
export ctype Not{B}; // Inverts the boolean provided
export ctype Nand{A, B}; // Performs a boolean or bitwise NAND on the inputs
export ctype Nor{A, B}; // Performs a boolean or bitwise NOR on the inputs
export ctype Xnor{A, B}; // Performs a boolean or bitwise XNOR on the inputs (same as EQ for booleans)
export ctype Eq{A, B}; // Returns true if the two types are the same (or are the same int, float, bool, or string), false otherwise
export ctype Neq{A, B}; // Returns true if the two types are difference
export ctype Lt{A, B}; // Returns true if A is less than B (and are an int or float)
export ctype Lte{A, B}; // Returns true if A is less than or equal to B
export ctype Gt{A, B}; // Returns true if A is greater than B
export ctype Gte{A, B}; // Returns true if A is greater than or equal to B

// Environment variable-derived boolean constants to be used by the root scope (or your own code)
export type Test = Eq{Env{"ALAN_TARGET"}, "test"};
export type Release = Eq{Env{"ALAN_TARGET"}, "release"};
export type Debug = Eq{Env{"ALAN_TARGET"}, "debug"};
export type Rs = Eq{Env{"ALAN_OUTPUT_LANG"}, "rs"};
export type Js = Eq{Env{"ALAN_OUTPUT_LANG"}, "js"};

// Importing the Root Scope backing implementation and supporting 3rd party libraries
export type{Rs} RootBacking = Rust{Dependency{"alan_std", "https://github.com/alantech/alan.git"}};
export type{Js} RootBacking = Node{Dependency{"alan_std", "https://github.com/alantech/alan.git"}};

// Defining derived types
export type void = ();
export type Self{T} = T;
export type{Rs} Error = Binds{Import{"alan_std::AlanError", RootBacking}};
export type{Js} Error = Binds{Import{"alan_std.AlanError", RootBacking}};
export type Fallible{T} = Either{T, Error};
export type Maybe{T} = Either{T, ()};

// Defining the operators in the type system
export type infix Function as -> precedence 4; // I -> O, where I is the input and O is the output. With Tuples and Fields you can reconstruct arguments for functions.
export type infix Call as :: precedence 0; // N :: F, where N is the native function (or method) and F is the function type
export type infix Dependency as @ precedence 1; // N @ V, where N is the name of the dependency and V is the version
export type infix Import as <- precedence 0; // N <- D, where N is the name of the value to be imported and D is the dependency to pull it from
export type prefix From as <= precedence 0; // <- D, where D is the dependency to pull a value or values from, TODO: Switch to <- once disambiguation is fixed
export type infix Tuple as , precedence 0; // A, B, C, ... The tuple type combines with other tuple types to become a larger tuple type. To have a tuple of tuples, you need to `Group` the inner tuple, eg `(a, b), c`
export type infix Field as : precedence 1; // Foo: Bar, let's you specify a property access label for the type, useful for syntactic sugar on a tuple type and the Either type (eventually).
export type infix Either as | precedence 0; // A | B, the type has a singular value from only one of the types at once.
export type infix Prop as . precedence 6; // A.B, returns the sub-type within A referenced by property B. Allows an inverse of a Tuple or Either type, accessed by either the Field name or an integer index
export type infix AnyOf as & precedence 0; // A & B, which can be passed to a function that takes A or B as necessary.
export type infix Buffer as [ precedence 2; // Technically allows `Foo[3` by itself to be valid syntax, but...
export type postfix Self as ] precedence 11; // This one goes to eleven. Technically not necessary, but allows for `Foo[3]` to do the "right thing" and become a buffer of size 3
export type postfix Array as [] precedence 5; // Allows `Foo[]` to do the right thing
export type postfix Maybe as ? precedence 5; // Allows `Foo?` for nullable types. Should this have a precedence of 5?
export type postfix Fallible as ! precedence 5; // Allows `Foo!` for fallible types. Same question on the precedence.
export type infix Add as + precedence 3;
export type infix Sub as - precedence 3;
export type infix Mul as * precedence 4;
export type infix Div as / precedence 4;
export type infix Mod as % precedence 4;
export type infix Pow as ** precedence 5;
export type infix If as ?? precedence 1; // C puts this kind of thing as a very high precedence. I'm not sure if I want to follow it. I feel like that would force grouping parens everywhere.
export type infix And as && precedence 4;
export type infix Or as || precedence 3;
export type infix Xor as ^ precedence 3;
export type prefix Not as ~ precedence 5; // TODO: Temporarily change this from ! to ~ until the operator prefix/postfix tiebreaker is updated to accept whichever *works* rather than prefer prefix
export type infix Nand as !& precedence 4;
export type infix Nor as !| precedence 3;
export type infix Xnor as !^ precedence 3;
export type infix Eq as == precedence 1;
export type infix Neq as != precedence 1;
export type infix Lt as < precedence 1;
export type infix Lte as <= precedence 1;
export type infix Gt as > precedence 1;
export type infix Gte as >= precedence 1;

// Binding the integer types
export type{Rs} i8 = Binds{"i8"};
export type{Js} i8 = Binds{"alan_std.I8" <- RootBacking};
export type{Rs} i16 = Binds{"i16"};
export type{Js} i16 = Binds{"alan_std.I16" <- RootBacking};
export type{Rs} i32 = Binds{"i32"};
export type{Js} i32 = Binds{"alan_std.I32" <- RootBacking};
export type{Rs} i64 = Binds{"i64"};
export type{Js} i64 = Binds{"alan_std.I64" <- RootBacking};
export type{Rs} u8 = Binds{"u8"};
export type{Js} u8 = Binds{"alan_std.U8" <- RootBacking};
export type{Rs} u16 = Binds{"u16"};
export type{Js} u16 = Binds{"alan_std.U16" <- RootBacking};
export type{Rs} u32 = Binds{"u32"};
export type{Js} u32 = Binds{"alan_std.U32" <- RootBacking};
export type{Rs} u64 = Binds{"u64"};
export type{Js} u64 = Binds{"alan_std.U64" <- RootBacking};

// Binding the float types
export type{Rs} f32 = Binds{"f32"};
export type{Js} f32 = Binds{"alan_std.F32" <- RootBacking};
export type{Rs} f64 = Binds{"f64"};
export type{Js} f64 = Binds{"alan_std.F64" <- RootBacking};

// Binding the string types
export type{Rs} string = Binds{"String"};
export type{Js} string = Binds{"alan_std.Str" <- RootBacking};

// Binding the boolean types
export type{Rs} bool = Binds{"bool"};
export type{Js} bool = Binds{"alan_std.Bool" <- RootBacking};

// Binding the exit code type
export type{Rs} ExitCode = Binds{"std::process::ExitCode"};
export type{Js} ExitCode = Binds{"Number"};

// Binding the time types
export type{Rs} Instant = Binds{"std::time::Instant"};
export type{Rs} Duration = Binds{"std::time::Duration"};
export type{Js} Performance = Binds{"Performance"}

// Binding the uuid type
export type{Rs} uuid = Binds{"alan_std::Uuid" <- RootBacking};
// TODO: JS variant

// Binding the Dict and Set types
export type{Rs} Dict{K, V} = Binds{"alan_std::OrderedHashMap" <- RootBacking, K, V};
export type{Js} Dict{K, V} = Binds{"Map", K, V};
export type{Rs} Set{V} = Binds{"std::collections::HashSet", V};
export type{Js} Set{V} = Binds{"Set", V};

/// Functions for (potentially) every type
export fn{Rs} clone{T} (v: T) -> T = {Method{"clone"} :: T -> T}(v);
// TODO: This needs to be turned into a JS function that's bound
export fn{Js} clone{T} (v: T) -> T = {"(function clone(t) { if (t instanceof Array) { return t.map(clone); } else if (t.build instanceof Function) { return t.build(t.val); } else { return structuredClone(t) } })" :: T -> T}(v);
// TODO: The "proper" way to hash this consistently for all types is to decompose the input type
// into the various primitive types of Alan and then have hashing rules for each of them, which
// may themselves decompose, etc. This might be doable in Alan code on top of specialized hashing
// functions in Rust (as partially implemented here) or it might be better done as a special `hash`
// function created by the compiler for the specific type *if* ever actually used, walking the
// CType tree to determine the correct code to run. In either case, this is "good enough" for now.
export fn{Rs} hash{T} "alan_std::hash" <- RootBacking :: T -> i64;
export fn{Rs} hash{T} "alan_std::hasharray" <- RootBacking :: T[] -> i64;
export fn{Rs} hash "alan_std::hashstring" <- RootBacking :: string -> i64;
// TODO: JS variant for `hash`
export fn void{T}(v: T) -> void {}
export fn void() -> void {}
export fn{Rs} store{T} (a: Mut{T}, b: T) -> T = {"std::mem::replace" :: (Mut{T}, Own{T}) -> T}(a, b);
export fn{Js} store{T} (a: Mut{T}, b: T) -> T = {"((a, b) => Object.keys(b).forEach((k) => a[k] = b[k]))" :: (Mut{T}, T) -> T}(a, b);

/// Fallible, Maybe, and Either functions
export fn{Rs} Maybe{T}(v: T!) = {Method{"ok"} :: T! -> T?}(v);
export fn{Rs} Fallible{T}(v: T?, e: Error) = {Method{"ok_or"} :: (T?, Error) -> T!}(v, e);
export fn getOr{T, U}(v: U, d: T) = {T}(v).getOr(d);
export fn{Rs} getOr{T} (v: T?, d: T) = {Method{"unwrap_or"} :: (Own{T?}, Own{T}) -> T}(v, d);
export fn{Js} getOr{T} (v: T?, d: T) = {"((v, d) => v ?? d)" :: (T?, T) -> T}(v, d);
export fn{Rs} getOr{T} (v: T!, d: T) = {Method{"unwrap_or"} :: (Own{T!}, Own{T}) -> T}(v, d);
export fn{Js} getOr{T} (v: T!, d: T) = {"((v, d) => v instanceof alan_std.AlanError ? d : v)" :: (T!, T) -> T}(v, d);
export fn{Rs} getOrExit{T} (v: T!) = {Method{"unwrap"} :: Own{T!} -> T}(v);
export fn{Js} getOrExit{T} (v: T!) = {"((a) => { if (!(a instanceof alan_std.AlanError)) { return a; } else { process.exit(101); } })" :: T! -> T}(v);
export fn{Rs} getOrExit{T} (v: T?) = {Method{"unwrap"} :: Own{T?} -> T}(v);
export fn{Js} getOrExit{T} (v: T?) = {"((a) => a)" :: T? -> T}(v);
export fn{Js} getOrExit{T} (v: T?) = {"((a) => { if (a !== null && a !== undefined) { return a; } else { process.exit(101); } })" :: T? -> T}(v);
export fn{Rs} Error{T} (e: string) = {"Err" :: Own{Error} -> T!}(
  {Method{"into"} :: Own{string} -> Error}(e));
export fn{Rs} Error (e: string) = {Method{"into"} :: Own{string} -> Error}(e);
export fn{Js} Error{T} "new alan_std.AlanError" <- RootBacking :: string -> T!;
export fn{Js} Error "new alan_std.AlanError" <- RootBacking :: string -> Error;
export fn{Rs} exists{T} (m: T?) = {Method{"is_some"} :: T? -> bool}(m);
export fn{Js} exists{T} (m: T?) = {"((a) => new alan_std.Bool(a !== null))" <- RootBacking :: T? -> bool}(m);
export fn{Rs} string(e: Error) = {"format!" :: ("{}", Error) -> string}(e);
export fn{Js} string Property{"message"} :: Error -> string;

/// Primitive type casting functions
export fn i8(i: i8) = i;
export fn{Rs} i8 Cast{"i8"} :: Deref{i16} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: i16 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{i32} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: i32 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{i64} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: i64 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{u8} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: u8 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{u16} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: u16 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{u32} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: u32 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{u64} -> i8;
export fn{Js} i8 "new alan_std.I8" <- RootBacking :: u64 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{f32} -> i8;
export fn{Js} i8 "((f) => new alan_std.I8(Math.floor(f.val)))" <- RootBacking :: f32 -> i8;
export fn{Rs} i8 Cast{"i8"} :: Deref{f64} -> i8;
export fn{Js} i8 "((f) => new alan_std.I8(Math.floor(f.val)))" <- RootBacking :: f64 -> i8;
// TODO: LOL, what a hack
export fn{Rs} i8 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i8!;
export fn{Js} i8 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I8(v); } })" <- RootBacking :: string -> i8!;

export fn{Rs} i16 Cast{"i16"} :: Deref{i8} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: i8 -> i16;
export fn i16(i: i16) = i;
export fn{Rs} i16 Cast{"i16"} :: Deref{i32} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: i32 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{i64} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: i64 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{u8} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: u8 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{u16} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: u16 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{u32} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: u32 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{u64} -> i16;
export fn{Js} i16 "new alan_std.I16" <- RootBacking :: u64 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{f32} -> i16;
export fn{Js} i16 "((f) => new alan_std.I16(Math.floor(f.val)))" <- RootBacking :: f32 -> i16;
export fn{Rs} i16 Cast{"i16"} :: Deref{f64} -> i16;
export fn{Js} i16 "((f) => new alan_std.I16(Math.floor(f.val)))" <- RootBacking :: f64 -> i16;
export fn{Rs} i16 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i16!;
export fn{Js} i16 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I16(v); } })" <- RootBacking :: string -> i16!;

export fn{Rs} i32 Cast{"i32"} :: Deref{i8} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: i8 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{i16} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: i16 -> i32;
export fn i32(i: i32) = i;
export fn{Rs} i32 Cast{"i32"} :: Deref{i64} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: i64 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{u8} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: u8 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{u16} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: u16 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{u32} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: u32 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{u64} -> i32;
export fn{Js} i32 "new alan_std.I32" <- RootBacking :: u64 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{f32} -> i32;
export fn{Js} i32 "((f) => new alan_std.I32(Math.floor(f.val)))" <- RootBacking :: f32 -> i32;
export fn{Rs} i32 Cast{"i32"} :: Deref{f64} -> i32;
export fn{Js} i32 "((f) => new alan_std.I32(Math.floor(f.val)))" <- RootBacking :: f64 -> i32;
export fn{Js} i32 (f: f64) -> i32 = {"new alan_std.I32" <- RootBacking :: f64 -> i32}(
  {"Math.floor" :: f64 -> f64}(f));
export fn{Rs} i32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i32!;
export fn{Js} i32 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.I32(v); } })" <- RootBacking :: string -> i32!;

export fn{Rs} i64 Cast{"i64"} :: Deref{i8} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: i8 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{i16} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: i16 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{i32} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: i32 -> i64;
export fn i64(i: i64) = i;
export fn{Rs} i64 Cast{"i64"} :: Deref{u8} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: u8 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{u16} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: u16 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{u32} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: u32 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{u64} -> i64;
export fn{Js} i64 "new alan_std.I64" <- RootBacking :: u64 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{f32} -> i64;
export fn{Js} i64 "((f) => new alan_std.I64(Math.floor(f.val)))" <- RootBacking :: f32 -> i64;
export fn{Rs} i64 Cast{"i64"} :: Deref{f64} -> i64;
export fn{Js} i64 "((f) => new alan_std.I64(Math.floor(f.val)))" <- RootBacking :: f64 -> i64;
export fn{Rs} i64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> i64!;
export fn{Js} i64 "((s) => { try { return new alan_std.I64(BigInt(s.val)) } catch (e) { return new alan_std.AlanError(new alan_std.Str(e.message)); } })" <- RootBacking :: string -> i64!;

export fn{Rs} u8 Cast{"u8"} :: Deref{i8} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: i8 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{i16} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: i16 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{i32} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: i32 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{i64} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: i64 -> u8;
export fn u8(i: u8) = i;
export fn{Rs} u8 Cast{"u8"} :: Deref{u16} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: u16 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{u32} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: u32 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{u64} -> u8;
export fn{Js} u8 "new alan_std.U8" <- RootBacking :: u64 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{f32} -> u8;
export fn{Js} u8 "((f) => new alan_std.U8(Math.floor(f.val)))" <- RootBacking :: f32 -> u8;
export fn{Rs} u8 Cast{"u8"} :: Deref{f64} -> u8;
export fn{Js} u8 "((f) => new alan_std.U8(Math.floor(f.val)))" <- RootBacking :: f64 -> u8;
export fn{Rs} u8 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u8!;
export fn{Js} u8 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U8(v); } })" <- RootBacking :: string -> u8!;

export fn{Rs} u16 Cast{"u16"} :: Deref{i8} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: i8 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{i16} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: i16 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{i32} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: i32 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{i64} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: i64 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{u8} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: u8 -> u16;
export fn u16(i: u16) = i;
export fn{Rs} u16 Cast{"u16"} :: Deref{u32} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: u32 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{u64} -> u16;
export fn{Js} u16 "new alan_std.U16" <- RootBacking :: u64 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{f32} -> u16;
export fn{Js} u16 "((f) => new alan_std.U16(Math.floor(f.val)))" <- RootBacking :: f32 -> u16;
export fn{Rs} u16 Cast{"u16"} :: Deref{f64} -> u16;
export fn{Js} u16 "((f) => new alan_std.U16(Math.floor(f.val)))" <- RootBacking :: f64 -> u16;
export fn{Rs} u16 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u16!;
export fn{Js} u16 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U16(v); } })" <- RootBacking :: string -> u16!;

export fn{Rs} u32 Cast{"u32"} :: Deref{i8} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: i8 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{i16} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: i16 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{i32} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: i32 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{i64} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: i64 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{u8} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: u8 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{u16} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: u16 -> u32;
export fn u32(i: u32) = i;
export fn{Rs} u32 Cast{"u32"} :: Deref{u64} -> u32;
export fn{Js} u32 "new alan_std.U32" <- RootBacking :: u64 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{f32} -> u32;
export fn{Js} u32 "((f) => new alan_std.U32(Math.floor(f.val)))" <- RootBacking :: f32 -> u32;
export fn{Rs} u32 Cast{"u32"} :: Deref{f64} -> u32;
export fn{Js} u32 "((f) => new alan_std.U32(Math.floor(f.val)))" <- RootBacking :: f64 -> u32;
export fn{Rs} u32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u32!;
export fn{Js} u32 "((s) => { let v = parseInt(s.val); if (Number.isNaN(v)) { return new alan_std.AlanError(new alan_std.Str('Not a Number')); } else { return new alan_std.U32(v); } })" <- RootBacking :: string -> u32!;

export fn{Rs} u64 Cast{"u64"} :: Deref{i8} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: i8 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{i16} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: i16 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{i32} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: i32 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{i64} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: i64 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{u8} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: u8 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{u16} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: u16 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{u32} -> u64;
export fn{Js} u64 "new alan_std.U64" <- RootBacking :: u32 -> u64;
export fn u64(u: u64) = u;
export fn{Rs} u64 Cast{"u64"} :: Deref{f32} -> u64;
export fn{Js} u64 "((f) => new alan_std.U64(Math.floor(f.val)))" <- RootBacking :: f32 -> u64;
export fn{Rs} u64 Cast{"u64"} :: Deref{f64} -> u64;
export fn{Js} u64 "((f) => new alan_std.U64(Math.floor(f.val)))" <- RootBacking :: f64 -> u64;
export fn{Rs} u64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> u64!;
export fn{Js} u64 "((s) => { try { return new alan_std.U64(BigInt(s.val)) } catch (e) { return new alan_std.AlanError(new alan_std.Str(e.message)); } })" <- RootBacking :: string -> u64!;

export fn{Rs} f32 Cast{"f32"} :: Deref{i8} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: i8 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{i16} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: i16 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{i32} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: i32 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{i64} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: i64 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{u8} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: u8 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{u16} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: u16 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{u32} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: u32 -> f32;
export fn{Rs} f32 Cast{"f32"} :: Deref{u64} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: u64 -> f32;
export fn f32(f: f32) = f;
export fn{Rs} f32 Cast{"f32"} :: Deref{f64} -> f32;
export fn{Js} f32 "new alan_std.F32" <- RootBacking :: f64 -> f32;
export fn{Rs} f32 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> f32!;
export fn{Js} f32 "((s) => { let f = parseFloat(s.val); if (Number.isNaN(f)) { return alan_std.nanToError(f); } else { return new alan_std.F32(f); } })" :: string -> f32!;

export fn{Rs} f64 Cast{"f64"} :: Deref{i8} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: i8 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{i16} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: i16 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{i32} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: i32 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{i64} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: i64 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{u8} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: u8 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{u16} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: u16 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{u32} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: u32 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{u64} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: u64 -> f64;
export fn{Rs} f64 Cast{"f64"} :: Deref{f32} -> f64;
export fn{Js} f64 "new alan_std.F64" <- RootBacking :: f32 -> f64;
export fn f64(f: f64) = f;
export fn{Rs} f64 Method{"parse().map_err(|s| alan_std::AlanError { message: alan_std::stringify(s) }).into"} :: string -> f64!;
export fn{Js} f64 "((s) => { let f = parseFloat(s.val); if (Number.isNaN(f)) { return alan_std.nanToError(f); } else { return new alan_std.F32(f); } })" :: string -> f64!;

export fn{Rs} bool (i: i8) = {Infix{"!="} :: (Deref{i8}, Deref{i8}) -> bool}(i, 0.i8);
export fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i8 -> bool;
export fn{Rs} bool (i: i16) = {Infix{"!="} :: (Deref{i16}, Deref{i16}) -> bool}(i, 0.i16);
export fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i16 -> bool;
export fn{Rs} bool (i: i32) = {Infix{"!="} :: (Deref{i32}, Deref{i32}) -> bool}(i, 0.i32);
export fn{Js} bool "((i) => new alan_std.Bool(i.val != 0))" <- RootBacking :: i32 -> bool;
export fn{Rs} bool (i: i64) = {Infix{"!="} :: (Deref{i64}, Deref{i64}) -> bool}(i, 0);
export fn{Js} bool "((i) => new alan_std.Bool(i.val != 0n))" <- RootBacking :: i64 -> bool;
export fn{Rs} bool (u: u8) = {Infix{"!="} :: (Deref{u8}, Deref{u8}) -> bool}(u, 0.u8);
export fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u8 -> bool;
export fn{Rs} bool (u: u16) = {Infix{"!="} :: (Deref{u16}, Deref{u16}) -> bool}(u, 0.u16);
export fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u16 -> bool;
export fn{Rs} bool (u: u32) = {Infix{"!="} :: (Deref{u32}, Deref{u32}) -> bool}(u, 0.u32);
export fn{Js} bool "((u) => new alan_std.Bool(u.val != 0))" <- RootBacking :: u32 -> bool;
export fn{Rs} bool (u: u64) = {Infix{"!="} :: (Deref{u64}, Deref{u64}) -> bool}(u, 0.u64);
export fn{Js} bool "((u) => new alan_std.Bool(u.val != 0n))" <- RootBacking :: u64 -> bool;
export fn{Rs} bool (f: f32) = {Infix{"!="} :: (Deref{f32}, Deref{f32}) -> bool}(f, 0.f32);
export fn{Js} bool "((f) => new alan_std.Bool(f.val != 0.0))" <- RootBacking :: f32 -> bool;
export fn{Rs} bool (f: f64) = {Infix{"!="} :: (Deref{f64}, Deref{f64}) -> bool}(f, 0.f64);
export fn{Js} bool "((f) => new alan_std.Bool(f.val != 0.0))" <- RootBacking :: f64 -> bool;
export fn{Rs} bool(s: string) = {Infix{"=="} :: (string, string) -> bool}(s, "true");
export fn{Js} bool "((s) => new alan_std.Bool(s.val == 'true'))" <- RootBacking :: string -> bool;
export fn bool(b: bool) = b;

/// Boolean related bindings
export fn{Rs} and Infix{"&&"} :: (Deref{bool}, Deref{bool}) -> bool;
export fn{Js} and "((a, b) => new alan_std.Bool(a.val && b.val))" <- RootBacking :: (bool, bool) -> bool;
export fn{Rs} or Infix{"||"} :: (Deref{bool}, Deref{bool}) -> bool;
export fn{Js} or "((a, b) => new alan_std.Bool(a.val || b.val))" <- RootBacking :: (bool, bool) -> bool;
export fn{Rs} xor Infix{"^"} :: (Deref{bool}, Deref{bool}) -> bool;
export fn{Js} xor "((a, b) => new alan_std.Bool(!!(a.val ^ b.val)))" <- RootBacking :: (bool, bool) -> bool;
export fn{Rs} not Prefix{"!"} :: Deref{bool} -> bool;
export fn{Js} not "((a) => new alan_std.Bool(!a.val))" :: bool -> bool;
export fn nand (a: bool, b: bool) = a.and(b).not;
export fn nor (a: bool, b: bool) = a.or(b).not;
export fn{Rs} xnor Infix{"=="} :: (bool, bool) -> bool;
export fn{Js} xnor "((a, b) => new alan_std.Bool(a.val == b.val))" :: (bool, bool) -> bool;
export fn{Rs} eq Infix{"=="} :: (bool, bool) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" :: (bool, bool) -> bool;
export fn{Rs} neq Infix{"!="} :: (bool, bool) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" :: (bool, bool) -> bool;
export fn if{T}(c: bool, t: T) = if(c, fn () -> Maybe{T} = Maybe{T}(t), fn () -> Maybe{T} = Maybe{T}());
export fn if{T}(c: bool, t: T, f: T) = if(c, fn () -> T = t, fn () -> T = f);
export fn if{T}(c: bool, t: () -> T) = if(c, fn () -> Maybe{T} = Maybe{T}(t()), fn () -> Maybe{T} = Maybe{T}());
export fn{Rs} if{T} "alan_std::ifbool" <- RootBacking :: (bool, () -> T, () -> T) -> T;
export fn{Js} if{T} "alan_std.ifbool" <- RootBacking :: (bool, () -> T, () -> T) -> T;

/// Signed Integer-related functions and function bindings
export fn{Rs} add Method{"wrapping_add"} :: (i8, Deref{i8}) -> i8;
export fn{Js} add Method{"wrappingAdd"} :: (i8, i8) -> i8;
export fn{Rs} sub Method{"wrapping_sub"} :: (i8, Deref{i8}) -> i8;
export fn{Js} sub Method{"wrappingSub"} :: (i8, i8) -> i8;
export fn{Rs} mul Method{"wrapping_mul"} :: (i8, Deref{i8}) -> i8;
export fn{Js} mul Method{"wrappingMul"} :: (i8, i8) -> i8;
export fn{Rs} div Method{"wrapping_div"} :: (i8, Deref{i8}) -> i8;
export fn{Js} div Method{"wrappingDiv"} :: (i8, i8) -> i8;
export fn{Rs} mod Method{"wrapping_rem"} :: (i8, Deref{i8}) -> i8;
export fn{Js} mod Method{"wrappingMod"} :: (i8, i8) -> i8;
export fn{Rs} pow (a: i8, b: i8) = {Method{"wrapping_pow"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (i8, i8) -> i8;
export fn{Rs} neg Prefix{"-"} :: Deref{i8} -> i8;
export fn{Js} neg "((a) => new alan_std.I8(-a))" <- RootBacking :: i8 -> i8;
export fn{Rs} and Infix{"&"} :: (Deref{i8}, Deref{i8}) -> i8;
export fn{Js} and "((a, b) => new alan_std.I8(a & b))" <- RootBacking :: (i8, i8) -> i8;
export fn{Rs} or Infix{"|"} :: (Deref{i8}, Deref{i8}) -> i8;
export fn{Js} or "((a, b) => new alan_std.I8(a | b))" <- RootBacking :: (i8, i8) -> i8;
export fn{Rs} xor Infix{"^"} :: (Deref{i8}, Deref{i8}) -> i8;
export fn{Js} xor "((a, b) => new alan_std.I8(a ^ b))" <- RootBacking :: (i8, i8) -> i8;
export fn{Rs} not Prefix{"!"} :: Deref{i8} -> i8;
export fn{Js} not Method{"not"} :: i8 -> i8;
export fn nand (a: i8, b: i8) = a.and(b).not;
export fn nor (a: i8, b: i8) = a.or(b).not;
export fn xnor (a: i8, b: i8) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{i8}, Deref{i8}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i8, i8) -> bool;
export fn min (a: i8, b: i8) = if(a.lte(b), a, b);
export fn max (a: i8, b: i8) = if(a.gte(b), a, b);
export fn{Rs} shl (a: i8, b: i8) = {Method{"wrapping_shl"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (i8, i8) -> i8;
export fn{Rs} shr (a: i8, b: i8) = {Method{"wrapping_shr"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (i8, i8) -> i8;
export fn{Rs} wrl (a: i8, b: i8) = {Method{"rotate_left"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (i8, i8) -> i8;
export fn{Rs} wrr (a: i8, b: i8) = {Method{"rotate_right"} :: (i8, Deref{u32}) -> i8}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (i8, i8) -> i8;

export fn{Rs} add Method{"wrapping_add"} :: (i16, Deref{i16}) -> i16;
export fn{Js} add Method{"wrappingAdd"} :: (i16, i16) -> i16;
export fn{Rs} sub Method{"wrapping_sub"} :: (i16, Deref{i16}) -> i16;
export fn{Js} sub Method{"wrappingSub"} :: (i16, i16) -> i16;
export fn{Rs} mul Method{"wrapping_mul"} :: (i16, Deref{i16}) -> i16;
export fn{Js} mul Method{"wrappingMul"} :: (i16, i16) -> i16;
export fn{Rs} div Method{"wrapping_div"} :: (i16, Deref{i16}) -> i16;
export fn{Js} div Method{"wrappingDiv"} :: (i16, i16) -> i16;
export fn{Rs} mod Method{"wrapping_rem"} :: (i16, Deref{i16}) -> i16;
export fn{Js} mod Method{"wrappingMod"} :: (i16, i16) -> i16;
export fn{Rs} pow (a: i16, b: i16) = {Method{"wrapping_pow"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (i16, i16) -> i16;
export fn{Rs} neg Prefix{"-"} :: Deref{i16} -> i16;
export fn{Js} neg "((a) => new alan_std.I16(-a))" <- RootBacking :: i16 -> i16;
export fn{Rs} and Infix{"&"} :: (Deref{i16}, Deref{i16}) -> i16;
export fn{Js} and "((a, b) => new alan_std.I16(a & b))" <- RootBacking :: (i16, i16) -> i16;
export fn{Rs} or Infix{"|"} :: (Deref{i16}, Deref{i16}) -> i16;
export fn{Js} or "((a, b) => new alan_std.I16(a | b))" <- RootBacking :: (i16, i16) -> i16;
export fn{Rs} xor Infix{"^"} :: (Deref{i16}, Deref{i16}) -> i16;
export fn{Js} xor "((a, b) => new alan_std.I16(a ^ b))" <- RootBacking :: (i16, i16) -> i16;
export fn{Rs} not Prefix{"!"} :: Deref{i16} -> i16;
export fn{Js} not Method{"not"} :: i16 -> i16;
export fn nand (a: i16, b: i16) = a.and(b).not;
export fn nor (a: i16, b: i16) = a.or(b).not;
export fn xnor (a: i16, b: i16) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{i16}, Deref{i16}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i16, i16) -> bool;
export fn min (a: i16, b: i16) = if(a.lte(b), a, b);
export fn max (a: i16, b: i16) = if(a.gte(b), a, b);
export fn{Rs} shl (a: i16, b: i16) = {Method{"wrapping_shl"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (i16, i16) -> i16;
export fn{Rs} shr (a: i16, b: i16) = {Method{"wrapping_shr"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (i16, i16) -> i16;
export fn{Rs} wrl (a: i16, b: i16) = {Method{"rotate_left"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (i16, i16) -> i16;
export fn{Rs} wrr (a: i16, b: i16) = {Method{"rotate_right"} :: (i16, Deref{u32}) -> i16}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (i16, i16) -> i16;

export fn{Rs} add Method{"wrapping_add"} :: (i32, Deref{i32}) -> i32;
export fn{Js} add Method{"wrappingAdd"} :: (i32, i32) -> i32;
export fn{Rs} sub Method{"wrapping_sub"} :: (i32, Deref{i32}) -> i32;
export fn{Js} sub Method{"wrappingSub"} :: (i32, i32) -> i32;
export fn{Rs} mul Method{"wrapping_mul"} :: (i32, Deref{i32}) -> i32;
export fn{Js} mul Method{"wrappingMul"} :: (i32, i32) -> i32;
export fn{Rs} div Method{"wrapping_div"} :: (i32, Deref{i32}) -> i32;
export fn{Js} div Method{"wrappingDiv"} :: (i32, i32) -> i32;
export fn{Rs} mod Method{"wrapping_rem"} :: (i32, Deref{i32}) -> i32;
export fn{Js} mod Method{"wrappingMod"} :: (i32, i32) -> i32;
export fn{Rs} pow (a: i32, b: i32) = {Method{"wrapping_pow"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (i32, i32) -> i32;
export fn{Rs} neg Prefix{"-"} :: Deref{i32} -> i32;
export fn{Js} neg "((a) => new alan_std.I32(-a))" <- RootBacking :: i32 -> i32;
export fn{Rs} and Infix{"&"} :: (Deref{i32}, Deref{i32}) -> i32;
export fn{Js} and "((a, b) => new alan_std.I32(a & b))" <- RootBacking :: (i32, i32) -> i32;
export fn{Rs} or Infix{"|"} :: (Deref{i32}, Deref{i32}) -> i32;
export fn{Js} or "((a, b) => new alan_std.I32(a | b))" <- RootBacking :: (i32, i32) -> i32;
export fn{Rs} xor Infix{"^"} :: (Deref{i32}, Deref{i32}) -> i32;
export fn{Js} xor "((a, b) => new alan_std.I32(a ^ b))" <- RootBacking :: (i32, i32) -> i32;
export fn{Rs} not Prefix{"!"} :: Deref{i32} -> i32;
export fn{Js} not Method{"not"} :: i32 -> i32;
export fn nand (a: i32, b: i32) = a.and(b).not;
export fn nor (a: i32, b: i32) = a.or(b).not;
export fn xnor (a: i32, b: i32) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i32, i32) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i32, i32) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i32, i32) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i32, i32) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" :: (i32, i32) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{i32}, Deref{i32}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" :: (i32, i32) -> bool;
export fn min (a: i32, b: i32) = if(a.lte(b), a, b);
export fn max (a: i32, b: i32) = if(a.gte(b), a, b);
export fn{Rs} shl (a: i32, b: i32) = {Method{"wrapping_shl"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (i32, i32) -> i32;
export fn{Rs} shr (a: i32, b: i32) = {Method{"wrapping_shr"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (i32, i32) -> i32;
export fn{Rs} wrl (a: i32, b: i32) = {Method{"rotate_left"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (i32, i32) -> i32;
export fn{Rs} wrr (a: i32, b: i32) = {Method{"rotate_right"} :: (i32, Deref{u32}) -> i32}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (i32, i32) -> i32;

export fn{Rs} add Method{"wrapping_add"} :: (i64, Deref{i64}) -> i64;
export fn{Js} add Method{"wrappingAdd"} :: (i64, i64) -> i64;
export fn{Rs} sub Method{"wrapping_sub"} :: (i64, Deref{i64}) -> i64;
export fn{Js} sub Method{"wrappingSub"} :: (i64, i64) -> i64;
export fn{Rs} mul Method{"wrapping_mul"} :: (i64, Deref{i64}) -> i64;
export fn{Js} mul Method{"wrappingMul"} :: (i64, i64) -> i64;
export fn{Rs} div Method{"wrapping_div"} :: (i64, Deref{i64}) -> i64;
export fn{Js} div Method{"wrappingDiv"} :: (i64, i64) -> i64;
export fn{Rs} mod Method{"wrapping_rem"} :: (i64, Deref{i64}) -> i64;
export fn{Js} mod Method{"wrappingMod"} :: (i64, i64) -> i64;
export fn{Rs} pow (a: i64, b: i64) = {Method{"wrapping_pow"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (i64, i64) -> i64;
export fn{Rs} neg Prefix{"-"} :: Deref{i64} -> i64;
export fn{Js} neg "((a) => new alan_std.I64(-a))" <- RootBacking :: i64 -> i64;
export fn{Rs} and Infix{"&"} :: (Deref{i64}, Deref{i64}) -> i64;
export fn{Js} and "((a, b) => new alan_std.I64(a & b))" <- RootBacking :: (i64, i64) -> i64;
export fn{Rs} or Infix{"|"} :: (Deref{i64}, Deref{i64}) -> i64;
export fn{Js} or "((a, b) => new alan_std.I64(a | b))" <- RootBacking :: (i64, i64) -> i64;
export fn{Rs} xor Infix{"^"} :: (Deref{i64}, Deref{i64}) -> i64;
export fn{Js} xor "((a, b) => new alan_std.I64(a ^ b))" <- RootBacking :: (i64, i64) -> i64;
export fn{Rs} not Prefix{"!"} :: Deref{i64} -> i64;
export fn{Js} not Method{"not"} :: i64 -> i64;
export fn nand (a: i64, b: i64) = a.and(b).not;
export fn nor (a: i64, b: i64) = a.or(b).not;
export fn xnor (a: i64, b: i64) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{i64}, Deref{i64}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (i64, i64) -> bool;
export fn min (a: i64, b: i64) = if(a.lte(b), a, b);
export fn max (a: i64, b: i64) = if(a.gte(b), a, b);
export fn{Rs} shl (a: i64, b: i64) = {Method{"wrapping_shl"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (i64, i64) -> i64;
export fn{Rs} shr (a: i64, b: i64) = {Method{"wrapping_shr"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (i64, i64) -> i64;
export fn{Rs} wrl (a: i64, b: i64) = {Method{"rotate_left"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (i64, i64) -> i64;
export fn{Rs} wrr (a: i64, b: i64) = {Method{"rotate_right"} :: (i64, Deref{u32}) -> i64}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (i64, i64) -> i64;

/// Unsigned Integer-related functions and function bindings
export fn{Rs} add Method{"wrapping_add"} :: (u8, Deref{u8}) -> u8;
export fn{Js} add Method{"wrappingAdd"} :: (u8, u8) -> u8;
export fn{Rs} sub Method{"wrapping_sub"} :: (u8, Deref{u8}) -> u8;
export fn{Js} sub Method{"wrappingSub"} :: (u8, u8) -> u8;
export fn{Rs} mul Method{"wrapping_mul"} :: (u8, Deref{u8}) -> u8;
export fn{Js} mul Method{"wrappingMul"} :: (u8, u8) -> u8;
export fn{Rs} div Method{"wrapping_div"} :: (u8, Deref{u8}) -> u8;
export fn{Js} div Method{"wrappingDiv"} :: (u8, u8) -> u8;
export fn{Rs} mod Method{"wrapping_rem"} :: (u8, Deref{u8}) -> u8;
export fn{Js} mod Method{"wrappingMod"} :: (u8, u8) -> u8;
export fn{Rs} pow (a: u8, b: u8) = {Method{"wrapping_pow"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (u8, u8) -> u8;
export fn{Rs} and Infix{"&"} :: (Deref{u8}, Deref{u8}) -> u8;
export fn{Js} and "((a, b) => new alan_std.U8(a & b))" <- RootBacking :: (u8, u8) -> u8;
export fn{Rs} or Infix{"|"} :: (Deref{u8}, Deref{u8}) -> u8;
export fn{Js} or "((a, b) => new alan_std.U8(a | b))" <- RootBacking :: (u8, u8) -> u8;
export fn{Rs} xor Infix{"^"} :: (Deref{u8}, Deref{u8}) -> u8;
export fn{Js} xor "((a, b) => new alan_std.U8(a ^ b))" <- RootBacking :: (u8, u8) -> u8;
export fn{Rs} not Prefix{"!"} :: Deref{u8} -> u8;
export fn{Js} not Method{"not"} :: u8 -> u8;
export fn nand (a: u8, b: u8) = a.and(b).not;
export fn nor (a: u8, b: u8) = a.or(b).not;
export fn xnor (a: u8, b: u8) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{u8}, Deref{u8}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u8, u8) -> bool;
export fn min (a: u8, b: u8) = if(a.lte(b), a, b);
export fn max (a: u8, b: u8) = if(a.gte(b), a, b);
export fn{Rs} shl (a: u8, b: u8) = {Method{"wrapping_shl"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (u8, u8) -> u8;
export fn{Rs} shr (a: u8, b: u8) = {Method{"wrapping_shr"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (u8, u8) -> u8;
export fn{Rs} wrl (a: u8, b: u8) = {Method{"rotate_left"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (u8, u8) -> u8;
export fn{Rs} wrr (a: u8, b: u8) = {Method{"rotate_right"} :: (u8, Deref{u32}) -> u8}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (u8, u8) -> u8;

export fn{Rs} add Method{"wrapping_add"} :: (u16, Deref{u16}) -> u16;
export fn{Js} add Method{"wrappingAdd"} :: (u16, u16) -> u16;
export fn{Rs} sub Method{"wrapping_sub"} :: (u16, Deref{u16}) -> u16;
export fn{Js} sub Method{"wrappingSub"} :: (u16, u16) -> u16;
export fn{Rs} mul Method{"wrapping_mul"} :: (u16, Deref{u16}) -> u16;
export fn{Js} mul Method{"wrappingMul"} :: (u16, u16) -> u16;
export fn{Rs} div Method{"wrapping_div"} :: (u16, Deref{u16}) -> u16;
export fn{Js} div Method{"wrappingDiv"} :: (u16, u16) -> u16;
export fn{Rs} mod Method{"wrapping_rem"} :: (u16, Deref{u16}) -> u16;
export fn{Js} mod Method{"wrappingMod"} :: (u16, u16) -> u16;
export fn{Rs} pow (a: u16, b: u16) = {Method{"wrapping_pow"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (u16, u16) -> u16;
export fn{Rs} and Infix{"&"} :: (Deref{u16}, Deref{u16}) -> u16;
export fn{Js} and "((a, b) => new alan_std.U16(a & b))" <- RootBacking :: (u16, u16) -> u16;
export fn{Rs} or Infix{"|"} :: (Deref{u16}, Deref{u16}) -> u16;
export fn{Js} or "((a, b) => new alan_std.U16(a | b))" <- RootBacking :: (u16, u16) -> u16;
export fn{Rs} xor Infix{"^"} :: (Deref{u16}, Deref{u16}) -> u16;
export fn{Js} xor "((a, b) => new alan_std.U16(a ^ b))" <- RootBacking :: (u16, u16) -> u16;
export fn{Rs} not Prefix{"!"} :: Deref{u16} -> u16;
export fn{Js} not Method{"not"} :: u16 -> u16;
export fn nand (a: u16, b: u16) = a.and(b).not;
export fn nor (a: u16, b: u16) = a.or(b).not;
export fn xnor (a: u16, b: u16) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{u16}, Deref{u16}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u16, u16) -> bool;
export fn min (a: u16, b: u16) = if(a.lte(b), a, b);
export fn max (a: u16, b: u16) = if(a.gte(b), a, b);
export fn{Rs} shl (a: u16, b: u16) = {Method{"wrapping_shl"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (u16, u16) -> u16;
export fn{Rs} shr (a: u16, b: u16) = {Method{"wrapping_shr"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (u16, u16) -> u16;
export fn{Rs} wrl (a: u16, b: u16) = {Method{"rotate_left"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (u16, u16) -> u16;
export fn{Rs} wrr (a: u16, b: u16) = {Method{"rotate_right"} :: (u16, Deref{u32}) -> u16}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (u16, u16) -> u16;

export fn{Rs} add Method{"wrapping_add"} :: (u32, Deref{u32}) -> u32;
export fn{Js} add Method{"wrappingAdd"} :: (u32, u32) -> u32;
export fn{Rs} sub Method{"wrapping_sub"} :: (u32, Deref{u32}) -> u32;
export fn{Js} sub Method{"wrappingSub"} :: (u32, u32) -> u32;
export fn{Rs} mul Method{"wrapping_mul"} :: (u32, Deref{u32}) -> u32;
export fn{Js} mul Method{"wrappingMul"} :: (u32, u32) -> u32;
export fn{Rs} div Method{"wrapping_div"} :: (u32, Deref{u32}) -> u32;
export fn{Js} div Method{"wrappingDiv"} :: (u32, u32) -> u32;
export fn{Rs} mod Method{"wrapping_rem"} :: (u32, Deref{u32}) -> u32;
export fn{Js} mod Method{"wrappingMod"} :: (u32, u32) -> u32;
export fn{Rs} pow (a: u32, b: u32) = {Method{"wrapping_pow"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (u32, u32) -> u32;
export fn{Rs} and Infix{"&"} :: (Deref{u32}, Deref{u32}) -> u32;
export fn{Js} and "((a, b) => new alan_std.U32(a & b))" <- RootBacking :: (u32, u32) -> u32;
export fn{Rs} or Infix{"|"} :: (Deref{u32}, Deref{u32}) -> u32;
export fn{Js} or "((a, b) => new alan_std.U32(a | b))" <- RootBacking :: (u32, u32) -> u32;
export fn{Rs} xor Infix{"^"} :: (Deref{u32}, Deref{u32}) -> u32;
export fn{Js} xor "((a, b) => new alan_std.U32(a ^ b))" <- RootBacking :: (u32, u32) -> u32;
export fn{Rs} not Prefix{"!"} :: Deref{u32} -> u32;
export fn{Js} not Method{"not"} :: u32 -> u32;
export fn nand (a: u32, b: u32) = a.and(b).not;
export fn nor (a: u32, b: u32) = a.or(b).not;
export fn xnor (a: u32, b: u32) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{u32}, Deref{u32}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u32, u32) -> bool;
export fn min (a: u32, b: u32) = if(a.lte(b), a, b);
export fn max (a: u32, b: u32) = if(a.gte(b), a, b);
export fn{Rs} shl (a: u32, b: u32) = {Method{"wrapping_shl"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (u32, u32) -> u32;
export fn{Rs} shr (a: u32, b: u32) = {Method{"wrapping_shr"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (u32, u32) -> u32;
export fn{Rs} wrl (a: u32, b: u32) = {Method{"rotate_left"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (u32, u32) -> u32;
export fn{Rs} wrr (a: u32, b: u32) = {Method{"rotate_right"} :: (u32, Deref{u32}) -> u32}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (u32, u32) -> u32;

export fn{Rs} add Method{"wrapping_add"} :: (u64, Deref{u64}) -> u64;
export fn{Js} add Method{"wrappingAdd"} :: (u64, u64) -> u64;
export fn{Rs} sub Method{"wrapping_sub"} :: (u64, Deref{u64}) -> u64;
export fn{Js} sub Method{"wrappingSub"} :: (u64, u64) -> u64;
export fn{Rs} mul Method{"wrapping_mul"} :: (u64, Deref{u64}) -> u64;
export fn{Js} mul Method{"wrappingMul"} :: (u64, u64) -> u64;
export fn{Rs} div Method{"wrapping_div"} :: (u64, Deref{u64}) -> u64;
export fn{Js} div Method{"wrappingDiv"} :: (u64, u64) -> u64;
export fn{Rs} mod Method{"wrapping_rem"} :: (u64, Deref{u64}) -> u64;
export fn{Js} mod Method{"wrappingMod"} :: (u64, u64) -> u64;
export fn{Rs} pow (a: u64, b: u64) = {Method{"wrapping_pow"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
export fn{Js} pow Method{"wrappingPow"} :: (u64, u64) -> u64;
export fn{Rs} and Infix{"&"} :: (Deref{u64}, Deref{u64}) -> u64;
export fn{Js} and "((a, b) => new alan_std.U64(a & b))" <- RootBacking :: (u64, u64) -> u64;
export fn{Rs} or Infix{"|"} :: (Deref{u64}, Deref{u64}) -> u64;
export fn{Js} or "((a, b) => new alan_std.U64(a | b))" <- RootBacking :: (u64, u64) -> u64;
export fn{Rs} xor Infix{"^"} :: (Deref{u64}, Deref{u64}) -> u64;
export fn{Js} xor "((a, b) => new alan_std.U64(a ^ b))" <- RootBacking :: (u64, u64) -> u64;
export fn{Rs} not Prefix{"!"} :: Deref{u64} -> u64;
export fn{Js} not Method{"not"} :: u64 -> u64;
export fn nand (a: u64, b: u64) = a.and(b).not;
export fn nor (a: u64, b: u64) = a.or(b).not;
export fn xnor (a: u64, b: u64) = a.xor(b).not;
export fn{Rs} eq Infix{"=="} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{u64}, Deref{u64}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (u64, u64) -> bool;
export fn min (a: u64, b: u64) = if(a.lte(b), a, b);
export fn max (a: u64, b: u64) = if(a.gte(b), a, b);
export fn{Rs} shl (a: u64, b: u64) = {Method{"wrapping_shl"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
export fn{Js} shl Method{"wrappingShl"} :: (u64, u64) -> u64;
export fn{Rs} shr (a: u64, b: u64) = {Method{"wrapping_shr"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
export fn{Js} shr Method{"wrappingShr"} :: (u64, u64) -> u64;
export fn{Rs} wrl (a: u64, b: u64) = {Method{"rotate_left"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
export fn{Js} wrl Method{"rotateLeft"} :: (u64, u64) -> u64;
export fn{Rs} wrr (a: u64, b: u64) = {Method{"rotate_right"} :: (u64, Deref{u32}) -> u64}(a, b.u32);
export fn{Js} wrr Method{"rotateRight"} :: (u64, u64) -> u64;

/// Float-related functions and function bindings
export fn{Rs} add Infix{"+"} :: (f32, f32) -> f32;
export fn{Js} add "((a, b) => new alan_std.F32(a.val + b.val))" <- RootBacking :: (f32, f32) -> f32;
export fn{Rs} sub Infix{"-"} :: (f32, f32) -> f32;
export fn{Js} sub "((a, b) => new alan_std.F32(a.val - b.val))" <- RootBacking :: (f32, f32) -> f32;
export fn{Rs} mul Infix{"*"} :: (f32, f32) -> f32;
export fn{Js} mul "((a, b) => new alan_std.F32(a.val * b.val))" <- RootBacking :: (f32, f32) -> f32;
export fn{Rs} div Infix{"/"} :: (f32, f32) -> f32;
export fn{Js} div "((a, b) => new alan_std.F32(a.val / b.val))" <- RootBacking :: (f32, f32) -> f32;
export fn{Rs} sqrt Method{"sqrt"} :: f32 -> f32;
export fn{Js} sqrt "((a) => new alan_std.F32(Math.sqrt(a)))" <- RootBacking :: f32 -> f32;
export fn{Rs} pow Method{"powf"} :: (f32, Deref{f32}) -> f32;
export fn{Js} pow "((a, b) => new alan_std.F32(a.val ** b.val))" <- RootBacking :: (f32, f32) -> f32;
export fn{Rs} neg Prefix{"-"} :: Deref{f32} -> f32;
export fn{Js} neg "((a) => new alan_std.F32(-a.val))" <- RootBacking :: f32 -> f32;
export fn{Rs} eq Infix{"=="} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.F32(a.val == b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.F32(a.val != b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{f32}, Deref{f32}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (f32, f32) -> bool;
export fn min (a: f32, b: f32) = if(a.lte(b), a, b);
export fn max (a: f32, b: f32) = if(a.gte(b), a, b);

export fn{Rs} add Infix{"+"} :: (f64, f64) -> f64;
export fn{Js} add "((a, b) => new alan_std.F64(a.val + b.val))" <- RootBacking :: (f64, f64) -> f64;
export fn{Rs} sub Infix{"-"} :: (f64, f64) -> f64;
export fn{Js} sub "((a, b) => new alan_std.F64(a.val - b.val))" <- RootBacking :: (f64, f64) -> f64;
export fn{Rs} mul Infix{"*"} :: (f64, f64) -> f64;
export fn{Js} mul "((a, b) => new alan_std.F64(a.val * b.val))" <- RootBacking :: (f64, f64) -> f64;
export fn{Rs} div Infix{"/"} :: (f64, f64) -> f64;
export fn{Js} div "((a, b) => new alan_std.F64(a.val / b.val))" <- RootBacking :: (f64, f64) -> f64;
export fn{Rs} sqrt Method{"sqrt"} :: f64 -> f64;
export fn{Js} sqrt "((a) => new alan_std.F64(Math.sqrt(a)))" <- RootBacking :: f64 -> f64;
export fn{Rs} pow Method{"powf"} :: (f64, Deref{f64}) -> f64;
export fn{Js} pow "((a, b) => new alan_std.F64(a.val ** b.val))" <- RootBacking :: (f64, f64) -> f64;
export fn{Rs} neg Prefix{"-"} :: Deref{f64} -> f64;
export fn{Js} neg "((a) => new alan_std.F64(-a.val))" <- RootBacking :: f64 -> f64;
export fn{Rs} eq Infix{"=="} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.F64(a.val == b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn{Rs} neq Infix{"!="} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.F64(a.val != b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn{Rs} lt Infix{"<"} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.F64(a.val < b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn{Rs} lte Infix{"<="} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.F64(a.val <= b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn{Rs} gt Infix{">"} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.F64(a.val > b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn{Rs} gte Infix{">="} :: (Deref{f64}, Deref{f64}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.F64(a.val >= b.val))" <- RootBacking :: (f64, f64) -> bool;
export fn min (a: f64, b: f64) = if(a.lte(b), a, b);
export fn max (a: f64, b: f64) = if(a.gte(b), a, b);

/// String related bindings
export fn{Rs} string "format!" :: ("{}", i8) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: i8 -> string;
export fn{Rs} string "format!" :: ("{}", i16) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: i16 -> string;
export fn{Rs} string "format!" :: ("{}", i32) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: i32 -> string;
export fn{Rs} string "format!" :: ("{}", i64) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: i64 -> string;
export fn{Rs} string "format!" :: ("{}", u8) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: u8 -> string;
export fn{Rs} string "format!" :: ("{}", u16) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: u16 -> string;
export fn{Rs} string "format!" :: ("{}", u32) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: u32 -> string;
export fn{Rs} string "format!" :: ("{}", u64) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: u64 -> string;
export fn{Rs} string "format!" :: ("{}", f32) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: f32 -> string;
export fn{Rs} string "format!" :: ("{}", f64) -> string;
export fn{Js} string "new alan_std.Str" <- RootBacking :: f64 -> string;
export fn string(b: bool) = if(b, "true", "false");
export fn string(s: string) = s;
export fn{Rs} concat "format!" :: ("{}{}", string, string) -> string;
export fn{Js} concat "((a, b) => new alan_std.Str(a.val + b.val))" <- RootBacking :: (string, string) -> string;
export fn{Rs} repeat (a: string, n: i64) = {Method{"repeat"} :: (string, Deref{Binds{"usize"}}) -> string}(
  a,
  {Cast{"usize"} :: Deref{i64} -> Binds{"usize"}}(n));
export fn{Js} repeat "((s, n) => new alan_std.Str(s.val.repeat(Number(n.val))))" <- RootBacking :: (string, i64) -> string;
export fn replace Method{"replace"} :: (string, string, string) -> string;
export fn{Rs} split "alan_std::splitstring" <- RootBacking :: (string, string) -> string[];
export fn{Js} split "((a, b) => a.val.split(b.val).map(v => new alan_std.Str(v)))" <- RootBacking :: (string, string) -> string[];
export fn{Rs} len (s: string) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Array{Binds{"char"}} -> Binds{"usize"}}(
    {Method{"collect::<Vec<char>>"} :: Own{Binds{"std::str::Chars"}} -> Array{Binds{"char"}}}(
      {Method{"chars"} :: string -> Binds{"std::str::Chars"}}(s))));
export fn{Js} len "((s) => new alan_std.I64(s.val.length))" :: string -> i64;
export fn{Rs} get "alan_std::getstring" <- RootBacking :: (string, i64) -> string!;
export fn{Js} get "((s, i) => { let idx = Number(i.val); if (idx >= 0 && idx < s.val.length) { return new alan_std.Str(s.val[idx]); } else { return new alan_std.AlanError(new alan_std.Str(`Index ${idx} is out-of-bounds for a string length of ${s.val.length}`)); } })" :: (string, i64) -> string!;
export fn{Rs} trim Method{"trim"} :: string -> string;
export fn{Js} trim "((s) => new alan_std.Str(s.val.trim()))" <- RootBacking :: string -> string;
export fn{Rs} index "alan_std::indexstring" <- RootBacking :: (string, string) -> i64!;
export fn{Js} index "((a, b) => { let idx = a.val.indexOf(b.val); if (idx < 0) { return new alan_std.AlanError(new alan_std.Str(`Could not find ${b.val} in ${a.val}`)); } else { return new alan_std.I64(idx); } })" <- RootBacking :: (string, string) -> i64!;
// TODO: Optimize this by using `as_str` inline, but need a `Str` type, which I *really* don't want to terrorize the user with
export fn{Rs} eq Infix{"=="} :: (Own{string}, Own{string}) -> bool;
export fn{Js} eq "((a, b) => new alan_std.Bool(a.val == b.val))" <- RootBacking :: (string, string) -> bool;
export fn{Rs} neq Infix{"!="} :: (Own{string}, Own{string}) -> bool;
export fn{Js} neq "((a, b) => new alan_std.Bool(a.val != b.val))" <- RootBacking :: (string, string) -> bool;
export fn{Rs} lt Infix{"<"} :: (Own{string}, Own{string}) -> bool;
export fn{Js} lt "((a, b) => new alan_std.Bool(a.val < b.val))" <- RootBacking :: (string, string) -> bool;
export fn{Rs} lte Infix{"<="} :: (Own{string}, Own{string}) -> bool;
export fn{Js} lte "((a, b) => new alan_std.Bool(a.val <= b.val))" <- RootBacking :: (string, string) -> bool;
export fn{Rs} gt Infix{">"} :: (Own{string}, Own{string}) -> bool;
export fn{Js} gt "((a, b) => new alan_std.Bool(a.val > b.val))" <- RootBacking :: (string, string) -> bool;
export fn{Rs} gte Infix{">="} :: (Own{string}, Own{string}) -> bool;
export fn{Js} gte "((a, b) => new alan_std.Bool(a.val >= b.val))" <- RootBacking :: (string, string) -> bool;
export fn min (a: string, b: string) = if(a.lte(b), fn () = a.clone(), fn () = b.clone());
export fn max (a: string, b: string) = if(a.gte(b), fn () = a.clone(), fn () = b.clone());
export fn{Rs} join Method{"join"} :: (string[], string) -> string;
export fn{Js} join "((a, b) => new alan_std.Str([...a.map(v => v.val)].join(b.val)))" <- RootBacking :: (string[], string) -> string;
export fn{Rs} join{S}(a: string[S], s: string) = {Method{"join"} :: (string[S], string) -> string}(a, s);
export fn{Js} join{S}(a: string[S], s: string) = {"((a, s) => new alan_std.Str(a.map(v => v.val).join(s.val)))" <- RootBacking :: (string[S], string) -> string}(a, s);

/// Array related bindings
export fn{Rs} len{T} (a: T[]) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: T[] -> Binds{"usize"}}(a));
export fn{Js} len{T} (a: T[]) = {Property{"length"} :: T[] -> i32}(a).i64;
export fn{Rs} get{T} "alan_std::getarray" <- RootBacking :: (T[], i64) -> T?;
export fn{Js} get{T} (a: T[], i: i64) = if(i.gte(0).and(i.lt(a.len)),
  fn = {Method{"at"} :: (T[], i32) -> T}(a, i.i32));
export fn push{T} (a: Mut{T[]}, v: T) = {Method{"push"} :: (Mut{T[]}, Own{T})}(a, v);
export fn{Rs} pop{T} (a: Mut{T[]}) -> T? = {Method{"pop"} :: Mut{T[]} -> T?}(a);
export fn{Js} pop{T} (a: Mut{T[]}) -> T? = {"((a) => a || null)" :: T? -> T?}({Method{"pop"} :: Mut{T[]} -> T?}(a));
export fn{Rs} map{T, U} "alan_std::map_onearg" <- RootBacking :: (T[], T -> U) -> U[];
export fn{Js} map{T, U} (a: T[], f: T -> U) = {"Promise.all" :: U[] -> U[]}({Method{"map"} :: (T[], T -> U) -> U[]}(a, f));
export fn{Rs} map{T, U} "alan_std::map_twoarg" <- RootBacking :: (T[], (T, i64) -> U) -> U[];
export fn{Js} map{T, U} (a: T[], f: (T, i64) -> U) = {"Promise.all" :: U[] -> U[]}({Method{"map"} :: (T[], (T, i32) -> U) -> U[]}(a, fn (v: T, i: i32) = f(v, i.i64)));
export fn{Rs} parmap{T, U} "alan_std::parmap_onearg" <- RootBacking :: (T[], T -> U) -> U[];
export fn{Rs} filter{T} "alan_std::filter_onearg" <- RootBacking :: (T[], T -> bool) -> T[];
export fn{Js} filter{T} (a: T[], f: T -> bool) = {"(async (a, f) => { let out = []; for (let v of a) { if ((await f(v)).val) { out.push(v); } } return out; })" :: (T[], T -> bool) -> T[]}(a, f);
export fn{Rs} filter{T} "alan_std::filter_twoarg" <- RootBacking :: (T[], (T, i64) -> bool) -> T[];
export fn{Js} filter{T} (a: T[], f: (T, i64) -> bool) = {"(async (a, f) => { let out = []; for (let i = 0; i < a.length; i++) { if ((await f(a[i], BigInt(i))).val) { out.push(a[i]); } } return out; })" :: (T[], (T, i64) -> bool) -> T[]}(a, f);
export fn{Rs} reduce{T} "alan_std::reduce_sametype" <- RootBacking :: (T[], (T, T) -> T) -> T?;
export fn{Js} reduce{T} (a: T[], f: (T, T) -> T) = {"(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[], (T, T) -> T) -> T?}(a, f);
export fn{Rs} reduce{T} "alan_std::reduce_sametype_idx" <- RootBacking :: (T[], (T, T, i64) -> T) -> T?;
export fn{Js} reduce{T} (a: T[], f: (T, T, i64) -> T) = {"(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i], BigInt(i)); } return out; })" :: (T[], (T, T, i64) -> T) -> T?}(a, f);
export fn{Rs} reduce{T, U} "alan_std::reduce_difftype" <- RootBacking :: (T[], U, (U, T) -> U) -> U;
export fn{Js} reduce{T, U} (a: T[], i: U, f: (U, T) -> U) = {"(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[], U, (U, T) -> U) -> U}(a, i, f);
export fn{Rs} reduce{T, U} "alan_std::reduce_difftype_idx" <- RootBacking :: (T[], U, (U, T, i64) -> U) -> U;
export fn{Js} reduce{T, U} (a: T[], i: U, f: (U, T, i64) -> U) = {"(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i], BigInt(i)); } return out; })" :: (T[], U, (U, T, i64) -> U) -> U}(a, i, f);
export fn{Rs} concat{T} "alan_std::concat" <- RootBacking :: (T[], T[]) -> T[];
export fn{Js} concat{T} (a: T[], b: T[]) -> T[] = {Method{"concat"} :: (T[], T[]) -> T[]}(a, b);
export fn{Rs} append{T} "alan_std::append" <- RootBacking :: (Mut{T[]}, T[]);
export fn{Rs} filled{T} "alan_std::filled" <- RootBacking :: (T, i64) -> T[];
export fn{Rs} has{T} (a: T[], v: T) = {Method{"contains"} :: (T[], T) -> bool}(a, v);
export fn{Js} has{T} (a: T[], v: T) = a.reduce(false, fn (out: bool, t: T) = if(out, true, t == v));
export fn{Rs} has{T} "alan_std::hasfnarray" <- RootBacking :: (T[], T -> bool) -> bool;
export fn{Js} has{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return true; } } return false; })" :: (T[], T -> bool) -> bool}(a, f);
export fn{Rs} find{T} "alan_std::findarray" <- RootBacking :: (T[], T -> bool) -> T?;
export fn{Js} find{T} (a: T[], f: T -> bool) -> T? = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return v; } } return null; })" :: (T[], T -> bool) -> T?}(a, f);
// TODO: The `if` syntactic sugar will make these `if` calls much nicer
export fn index{T}(a: Array{T}, v: T) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(val.eq(v), Maybe(idx), out)));
export fn index{T}(a: Array{T}, f: T -> bool) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(f(val), idx)));
export fn index{T}(a: Array{T}, f: (T, i64) -> bool) = a.reduce(
  Maybe{i64}(),
  fn (out: Maybe{i64}, val: T, idx: i64) = if(out.exists, out, if(f(val, idx), idx)));
export fn{Rs} every{T} "alan_std::everyarray" <- RootBacking :: (T[], T -> bool) -> bool;
export fn{Js} every{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if (!(await f(v)).val) { return false; } } return true; })" :: (T[], T -> bool) -> bool}(a, f);
export fn{Rs} some{T} "alan_std::somearray" <- RootBacking :: (T[], T -> bool) -> bool;
export fn{Js} some{T} (a: T[], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return true; } } return false; })" :: (T[], T -> bool) -> bool}(a, f);
export fn{Rs} repeat{T} "alan_std::repeatarray" <- RootBacking :: (T[], i64) -> T[];
export fn{Js} repeat{T} (a: T[], c: i64) = {"((a, c) => { let out = []; for (let i = 0n; i < c; i++) { out.push(...a); } return out; })" :: (T[], i64) -> T[]}(a, c);
export fn{Rs} store{T} "alan_std::storearray" <- RootBacking :: (Mut{T[]}, i64, T) -> void!;
export fn{Js} store{T} (a: T[], i: i64, v: T) = {"((a, i, v) => { if (i < 0n || i > BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is greater than the length of the array`)); } else { a.splice(Number(i), 0, v); } })" :: (T[], i64, T) -> void!}(a, i, v);
export fn{Rs} delete{T} "alan_std::deletearray" <- RootBacking :: (Mut{T[]}, i64) -> T!;
export fn{Js} delete{T} (a: T[], i: i64) = {"((a, i) => { if (i < 0n || i >= BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is beyond the bounds of the array`)); } else { return a.splice(Number(i), 1)[0]; } })" :: (T[], i64) -> T!}(a, i);

/// Buffer related bindings
export fn{Rs} get{T, S} "alan_std::getbuffer" <- RootBacking :: (T[S], i64) -> T?;
export fn len{T, S}(T[S]) = {S}();
export fn{Js} get{T, S} (b: T[S], i: i64) = if(i.gte(0).and(i.lt(b.len)),
  fn = {Method{"at"} :: (T[S], i32) -> T}(a, i.i32));
export fn{Rs} map{T, S, U} "alan_std::mapbuffer_onearg" <- RootBacking :: (T[S], T -> U) -> (U[S]);
export fn{Js} map{T, S, U} (a: T[S], f: T -> U) = {"Promise.all" :: Buffer{U, S} -> Buffer{U, S}}({Method{"map"} :: (Buffer{T, S}, T -> U) -> Buffer{U, S}}(a, f));
export fn{Rs} map{T, S, U} "alan_std::mapbuffer_twoarg" <- RootBacking :: (T[S], (T, i64) -> U) -> (U[S]);
export fn{Js} map{T, S, U} (a: T[S], f: (T, i64) -> U) = {"Promise.all" :: Buffer{U, S} -> Buffer{U, S}}({Method{"map"} :: (Buffer{T, S}, (T, i32) -> U) -> Buffer{U, S}}(a, fn (v: T, i: i32) = f(v, i.i64)));
export fn{Rs} reduce{T, S} "alan_std::reducebuffer_sametype" <- RootBacking :: (T[S], (T, T) -> T) -> T?;
export fn{Js} reduce{T, S} (a: T[S], f: (T, T) -> T) = {"(async (a, f) => { if (a.length === 0) { return null; } let out = a[0]; for (let i = 1; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[S], (T, T) -> T) -> T?}(a, f);
export fn{Rs} reduce{T, S, U} "alan_std::reducebuffer_difftype" <- RootBacking :: (T[S], U, (U, T) -> U) -> U;
export fn{Js} reduce{T, S, U} (a: T[S], i: U, f: (U, T) -> U) = {"(async (a, i, f) => { let out = i; for (let i = 0; i < a.length; i++) { out = await f(out, a[i]); } return out; })" :: (T[S], U, (U, T) -> U) -> U}(a, i, f);
export fn{Rs} has{T, S} "alan_std::hasbuffer" <- RootBacking :: (T[S], T) -> bool;
export fn{Js} has{T, S} (a: T[S], v: T) = a.reduce(false, fn (out: bool, t: T) = if(out, true, t == v));
export fn{Rs} has{T, S} "alan_std::hasfnbuffer" <- RootBacking :: (T[S], T -> bool) -> bool;
export fn{Js} has{T, S} (a: T[S], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return true; } } return false; })" :: (T[S], T -> bool) -> bool}(a, f);
export fn{Rs} find{T, S} "alan_std::findbuffer" <- RootBacking :: (T[S], T -> bool) -> T?;
export fn{Js} find{T, S} (a: T[S], f: T -> bool) -> T? = {"(async (a, f) => { for (let v of a) { if ((await f(v)).val) { return v; } } return null; })" :: (T[S], T -> bool) -> T?}(a, f);
export fn{Rs} every{T, S} "alan_std::everybuffer" <- RootBacking :: (T[S], T -> bool) -> bool;
export fn{Js} every{T, S} (a: T[S], f: T -> bool) = {"(async (a, f) => { for (let v of a) { if (!(await f(v)).val) { return false; } } return true; })" :: (T[S], T -> bool) -> bool}(a, f);
fn{Rs} concatInner{T, S, N} "alan_std::concatbuffer" <- RootBacking :: (Mut{T[S + N]}, T[S], T[N]);
export fn{Rs} concat{T, S, N}(a: T[S], b: T[N]) {
  // I can't bind directly into Rust because Rust can't add const integer type parameters together.
  // It's *theoretically* possible to generate a new Rust function in each case with the required
  // sizes, but it will be really difficult, so I'm implementing this for now with the intent to
  // eventually replace it.
  let o = {T[S + N]}(a[0].getOrExit);
  concatInner(o, a, b);
  return o;
}
// TODO: Get return type inference working so I can uncomment this
//export fn{Js} concat{T, S, N} (a: T[S], b: T[N]) -> T[S + N] = {Method{"concat"} :: (T[S], T[N]) -> T[S + N]}(a, b);
// TODO: Be able to resolve explicit integer constant values as the integer type so it can be
// grabbed by the type inference system. For now, repeat for buffers outputs an array, instead.
export fn{Rs} repeat{T, S} "alan_std::repeatbuffertoarray" <- RootBacking :: (T[S], i64) -> T[];
export fn{Js} repeat{T, S} (a: T[S], c: i64) = {"((a, c) => { let out = []; for (let i = 0n; i < c; i++) { out.push(...a); } return out; })" :: (T[S], i64) -> T[]}(a, c);
export fn{Rs} store{T, S} "alan_std::storebuffer" <- RootBacking :: (Mut{T[S]}, i64, T) -> T!;
export fn{Js} store{T, S} (a: T[S], i: i64, v: T) = {"((a, i, v) => { if (i < 0n || i > BigInt(a.length)) { return new alan_std.AlanError(new alan_std.Str(`Provided array index ${i.toString()} is greater than the length of the array`)); } else { let out = a[Number(i)]; a[Number(i)] = v; return out; } })" :: (T[S], i64, T) -> T!}(a, i, v);

/// Dictionary-related bindings
export fn{Rs} Dict{K, V} "alan_std::OrderedHashMap::new" <- RootBacking :: () -> Dict{K, V};
export fn{Js} Dict{K, V} "new Map" :: () -> Dict{K, V};
export fn Dict{K, V}(k: K, v: V) {
  let out = Dict{K, V}();
  out.store(k, v);
  return out;
}
export fn Dict{K, V}(a: Array{(K, V)}) = a.reduce(Dict{K, V}(), fn (d: Dict{K, V}, v: (K, V)) {
  d.store(v.0, v.1);
  return d;
});
export fn{Rs} has{K, V} (d: Dict{K, V}, k: K) = {Method{"contains_key"} :: (Dict{K, V}, K) -> bool}(d, k);
export fn{Js} has{K, V} (d: Dict{K, V}, k: K) = {"((d, k) => d.has(k?.val ?? k))" :: (Dict{K, V}, K) -> bool}(d, k);
export fn{Rs} get{K, V} "alan_std::getdict" <- RootBacking :: (Dict{K, V}, K) -> V?;
export fn{Js} get{K, V} (d: Dict{K, V}, k: K) = {"((d, k) => d.get(k?.val ?? k) || null)" :: (Dict{K, V}, K) -> V?}(d, k);
export fn{Rs} store{K, V} (d: Mut{Dict{K, V}}, k: K, v: V) {
  {Method{"insert"} :: (Mut{Dict{K, V}}, Own{K}, Own{V}) -> V?}(d, k, v);
}
export fn{Js} store{K, V} (d: Mut{Dict{K, V}}, k: K, v: V) {
  let out = d.get(k);
  {"((s, k, v) => s.set(k?.val ?? k, v))" :: (Dict{K, V}, K, V) -> void}(d, k, v);
  return out;
}
export fn{Rs} len{K, V} (d: Dict{K, V}) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Dict{K, V} -> Binds{"usize"}}(d));
export fn{Js} len{K, V} (d: Dict{K, V}) = {Property{"size"} :: Dict{K, V} -> i32}(d).i64;
export fn{Rs} keys{K, V} "alan_std::keysdict" <- RootBacking :: Dict{K, V} -> K[];
export fn{Js} keys{K, V} (d: Dict{K, V}) = {"Array.from" :: K[] -> K[]}({Method{"keys"} :: Dict{K, V} -> K[]}(d));
// TODO: Figure out how to eliminate this weirdness
export fn{Js} keys{V} (d: Dict{i8, V}) = {"((d) => d.keys().map((k) => new alan_std.I8(k)))" :: Dict{i8, V} -> i8[]}(d);
export fn{Js} keys{V} (d: Dict{i16, V}) = {"((d) => d.keys().map((k) => new alan_std.I16(k)))" :: Dict{i16, V} -> i16[]}(d);
export fn{Js} keys{V} (d: Dict{i32, V}) = {"((d) => d.keys().map((k) => new alan_std.I32(k)))" :: Dict{i32, V} -> i32[]}(d);
export fn{Js} keys{V} (d: Dict{i64, V}) = {"((d) => d.keys().map((k) => new alan_std.I64(k)))" :: Dict{i64, V} -> i64[]}(d);
export fn{Js} keys{V} (d: Dict{u8, V}) = {"((d) => d.keys().map((k) => new alan_std.U8(k)))" :: Dict{u8, V} -> u8[]}(d);
export fn{Js} keys{V} (d: Dict{u16, V}) = {"((d) => d.keys().map((k) => new alan_std.U16(k)))" :: Dict{u16, V} -> u16[]}(d);
export fn{Js} keys{V} (d: Dict{u32, V}) = {"((d) => d.keys().map((k) => new alan_std.U32(k)))" :: Dict{u32, V} -> u32[]}(d);
export fn{Js} keys{V} (d: Dict{u64, V}) = {"((d) => d.keys().map((k) => new alan_std.U64(k)))" :: Dict{u64, V} -> u64[]}(d);
export fn{Js} keys{V} (d: Dict{f32, V}) = {"((d) => d.keys().map((k) => new alan_std.F32(k)))" :: Dict{f32, V} -> f32[]}(d);
export fn{Js} keys{V} (d: Dict{f64, V}) = {"((d) => d.keys().map((k) => new alan_std.F64(k)))" :: Dict{f64, V} -> f64[]}(d);
export fn{Js} keys{V} (d: Dict{bool, V}) = {"((d) => d.keys().map((k) => new alan_std.Bool(k)))" :: Dict{bool, V} -> bool[]}(d);
export fn{Js} keys{V} (d: Dict{string, V}) = {"((d) => d.keys().map((k) => new alan_std.Str(k)))" :: Dict{string, V} -> string[]}(d);
export fn{Rs} vals{K, V} "alan_std::valsdict" <- RootBacking :: Dict{K, V} -> V[];
export fn{Js} vals{K, V} (d: Dict{K, V}) = {"Array.from" :: V[] -> V[]}({Method{"values"} :: Dict{K, V} -> V[]}(d));
export fn{Rs} Array{K, V} "alan_std::arraydict" <- RootBacking :: Dict{K, V} -> (K, V)[];
// export fn{Js} Array{K, V} "Array.from" :: Dict{K, V} -> (K, V)[];
// TODO: Figure out how to avoid this map
export fn{Js} Array{K, V} "((d) => Array.from(d).map(kv => ({ arg0: kv[0], arg1: kv[1] })))" :: Dict{K, V} -> (K, V)[];
export fn{Js} Array{V} (d: Dict{i8, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I8(kv[0]), arg1: kv[1] })))" :: Dict{i8, V} -> (i8, V)[]}(d);
export fn{Js} Array{V} (d: Dict{i16, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I16(kv[0]), arg1: kv[1] })))" :: Dict{i16, V} -> (i16, V)[]}(d);
export fn{Js} Array{V} (d: Dict{i32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I32(kv[0]), arg1: kv[1] })))" :: Dict{i32, V} -> (i32, V)[]}(d);
export fn{Js} Array{V} (d: Dict{i64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.I64(kv[0]), arg1: kv[1] })))" :: Dict{i64, V} -> (i64, V)[]}(d);
export fn{Js} Array{V} (d: Dict{u8, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U8(kv[0]), arg1: kv[1] })))" :: Dict{u8, V} -> (u8, V)[]}(d);
export fn{Js} Array{V} (d: Dict{u16, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U16(kv[0]), arg1: kv[1] })))" :: Dict{u16, V} -> (u16, V)[]}(d);
export fn{Js} Array{V} (d: Dict{u32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U32(kv[0]), arg1: kv[1] })))" :: Dict{u32, V} -> (u32, V)[]}(d);
export fn{Js} Array{V} (d: Dict{u64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.U64(kv[0]), arg1: kv[1] })))" :: Dict{u64, V} -> (u64, V)[]}(d);
export fn{Js} Array{V} (d: Dict{f32, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.F32(kv[0]), arg1: kv[1] })))" :: Dict{f32, V} -> (f32, V)[]}(d);
export fn{Js} Array{V} (d: Dict{f64, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.F64(kv[0]), arg1: kv[1] })))" :: Dict{f64, V} -> (f64, V)[]}(d);
export fn{Js} Array{V} (d: Dict{bool, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.Bool(kv[0]), arg1: kv[1] })))" :: Dict{bool, V} -> (bool, V)[]}(d);
export fn{Js} Array{V} (d: Dict{string, V}) = {"((d) => Array.from(d).map(kv => ({ arg0: new alan_std.Str(kv[0]), arg1: kv[1] })))" :: Dict{string, V} -> (string, V)[]}(d);
export fn{Rs} concat{K, V} "alan_std::concatdict" <- RootBacking :: (Dict{K, V}, Dict{K, V}) -> Dict{K, V};
export fn{Js} concat{K, V} "((a, b) => new Map([...a, ...b]))" :: (Dict{K, V}, Dict{K, V}) -> Dict{K, V};

/// Set-related bindings
export fn Set{V}(v: V) {
  let out = Set{V}();
  out.store(v);
  return out;
}
export fn Set{V}(a: Array{V}) = a.reduce(Set{V}(), fn (s: Set{V}, v: V) {
  s.store(v);
  return s;
});
export fn{Rs} Set{V} "std::collections::HashSet::new" :: () -> Set{V};
export fn{Js} Set{V} "new Set" :: () -> Set{V};
export fn{Rs} store{V} (s: Mut{Set{V}}, v: V) {
  {Method{"insert"} :: (Mut{Set{V}}, Own{V}) -> bool}(s, v);
}
export fn{Js} store{V} (s: Mut{Set{V}}, v: V) {
  {"((s, v) => s.add(v?.val ?? v))" :: (Set{V}, V) -> Set{V}}(s, v);
}
export fn{Rs} has{V} (s: Set{V}, v: V) = {Method{"contains"} :: (Set{V}, V) -> bool}(s, v);
export fn{Js} has{V} (s: Set{V}, v: V) = {"((s, v) => s.has(v?.val ?? v))" :: (Set{V}, V) -> bool}(s, v);
export fn{Rs} len{V} (s: Set{V}) = {Cast{"i64"} :: Deref{Binds{"usize"}} -> i64}(
  {Method{"len"} :: Set{V} -> Binds{"usize"}}(s));
export fn{Js} len{V} (s: Set{V}) = {Property{"size"} :: Set{V} -> i32}(s).i64;
export fn{Rs} Array{V} "alan_std::arrayset" <- RootBacking :: Set{V} -> V[];
export fn{Js} Array{V} "Array.from" :: Set{V} -> V[];
export fn{Rs} union{V} "alan_std::unionset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
export fn{Js} union{V} (a: Set{V}, b: Set{V}) = {Method{"union"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
export fn or{V}(a: Set{V}, b: Set{V}) = union(a, b);
export fn{Rs} intersect{V} "alan_std::intersectset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
export fn{Js} intersect{V} (a: Set{V}, b: Set{V}) = {Method{"intersection"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
export fn and{V}(a: Set{V}, b: Set{V}) = intersect(a, b);
export fn{Rs} difference{V} "alan_std::differenceset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
export fn{Js} difference{V} (a: Set{V}, b: Set{V}) = {Method{"difference"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
export fn div{V}(a: Set{V}, b: Set{V}) = difference(a, b);
export fn{Rs} symmetricDifference{V} "alan_std::symmetric_differenceset" <- RootBacking :: (Set{V}, Set{V}) -> Set{V};
export fn{Js} symmetricDifference{V} (a: Set{V}, b: Set{V}) = {Method{"symmetricDifference"} :: (Set{V}, Set{V}) -> Set{V}}(a, b);
export fn xor{V}(a: Set{V}, b: Set{V}) = symmetricDifference(a, b);
export fn{Rs} product{V} "alan_std::productset" <- RootBacking :: (Set{V}, Set{V}) -> Set{(V, V)};
export fn{Js} product{V} "((a, b) => { let out = new Set(); for (let arg0 of a) { for (let arg1 of b) { out.add({ arg0, arg1 }); } } return out; })" :: (Set{V}, Set{V}) -> Set{(V, V)};
export fn mul{V}(a: Set{V}, b: Set{V}) = product(a, b);

/// Tree implementation

// The Tree type houses all of the values attached to a tree in an array and two secondary arrays to
// hold the metadata on which value is the parent and which are children, if any. The parent value
// `void` if it has no parent and a positive integer otherwise.
export type Tree{T} =
  vals: Array{T},
  parents: Array{Maybe{i64}},
  children: Array{Array{i64}};

// The Node type simply holds the index to look into the tree for a particular value-parent-children
// triplet, where that index is reffered to as a node ID. This allows node-based code to be written
// while not actually having a recursive data structure that a traditional Node type would defined.
export type Node{T} =
  id: i64,
  tree: Tree{T};

export fn Tree{T}(rootVal: T) = Tree{T}(
  Array{T}(rootVal),
  Array{Maybe{i64}}(Maybe{i64}()),
  Array{Array{i64}}(Array{i64}()));
export fn Tree{T}(n: Node{T}) = n.tree;

// TODO: This is a more correct solution, but any Tree constructed by us will always have the root
// node be the first element of the array, so we're just doing that so we don't have a `Maybe` here
/*export fn rootNode{T}(t: Tree{T}) -> Maybe{Node{T}} {
  let rootIdx = t.parents.index(Maybe{i64}());
  return if(
    rootIdx.exists,
    fn () -> Node{T} = Node{T}(rootIdx.getOrExit, t)
  );
}*/
export fn rootNode{T}(t: Tree{T}) = Node{T}(0, t);

export fn len{T}(t: Tree{T}) = t.vals.len;

export fn Node{T}(t: Tree{T}, i: i64) = if(t.len.gt(i), fn () = Node{T}(i, t));

export fn parent{T}(n: Node{T}) {
  let parentId = n.tree.parents[n.id];
  return if(parentId.exists,
    if(parentId.getOrExit.exists,
      fn () = Node{T}(parentId.getOrExit.getOrExit, n.tree)),
      Maybe{Node{T}}());
}

export fn children{T}(n: Node{T}) = if(
  n.tree.len.gt(n.id),
  fn () {
    let childIds = n.tree.children[n.id].getOr(Array{i64}());
    return childIds
      .filter(fn (id: i64) = n.tree.parents[id].getOr(-1).eq(n.id))
      .map(fn (id: i64) = Node{T}(id, n.tree));
  },
  fn () = Array{Node{T}}());

export fn children{T}(t: Tree{T}) = t.rootNode.children;

export fn addChild{T}(n: Node{T}, val: T) {
  let idx = n.tree.len;
  let parentIdx = n.id;
  n.tree.vals.push(val);
  n.tree.parents.push(Maybe{i64}(parentIdx));
  n.tree.children.push(Array{i64}());
  return Node{T}(idx, n.tree);
}
export fn addChild{T}(n: Node{T}, t: Tree{T}) {
  let idxOffset = n.tree.len;
  let idx = idxOffset.clone(); // TODO: Lower stage of compiler should be doing this
  let parentIdx = n.id;
  n.tree.vals.append(t.vals);
  n.tree.parents.append(t.parents.map(fn (pId: Maybe{i64}) = if(pId.exists,
    fn () = Maybe{i64}(pId.getOrExit + idxOffset),
    fn () = Maybe{i64}(idx))));
  n.tree.children.append(
    t.children.map(
      fn (ids: Array{i64}) = ids.map(
        fn (id: i64) = id + idxOffset)));
  return Node{T}(idx, n.tree);
}
export fn addChild{T}(t: Tree{T}, val: T) = t.rootNode.addChild(val);


// TODO: Implement `addChild` when the child is itself a `Node{T}`

// TODO: Implement `prune` to pull a node out of the tree and re-attach its children to its own
// parent.

// TODO: Implement `subtree` to create a new tree consisting of the specified node as its root and
// only its own children as the children of the tree.

export fn getOr{T}(n: Node{T}, default: T) = n.tree.vals[n.id].getOr(default);

export fn Array{T}(t: Tree{T}) = t.vals.map(
  fn (_: T, i: i64) = Node{T}(t, i).getOrExit);

export fn map{T, U}(t: Tree{T}, mapper: (Node{T}) -> Node{U}) = Tree{U}(
  t.Array.map(mapper),
  t.parents.clone(),
  t.children.clone());
export fn map{T, U}(t: Tree{T}, mapper: (Node{T}, i64) -> Node{U}) = Tree{U}(
  t.Array.map(mapper),
  t.parents,
  t.children);

export fn every{T}(t: Tree{T}, f: (Node{T}) -> bool) = t.Array.every(f);

export fn some{T}(t: Tree{T}, f: (Node{T}) -> bool) = t.Array.some(f);

export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}) -> Node{T}) = t.Array.reduce(f);
export fn reduce{T}(t: Tree{T}, f: (Node{T}, Node{T}, i64) -> Node{T}) = t.Array.reduce(f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}) -> U) = t.Array.reduce(i, f);
export fn reduce{T, U}(t: Tree{T}, i: U, f: (U, Node{T}, i64) -> U) = t.Array.reduce(i, f);

export fn find{T}(t: Tree{T}, f: (T) -> bool) = t.Array.find(f);

/// Thread-related bindings
export fn{Rs} wait (t: i64) = {"std::thread::sleep" :: Own{Duration}}(
  {"std::time::Duration::from_millis" :: Own{u64} -> Duration}(t.u64)
);
export fn{Js} wait "((t) => new Promise((r) => setTimeout(() => { r(performance.now()) }, Number(t))))" :: i64 -> f64;

/// Time-related bindings
export fn{Rs} now "std::time::Instant::now" :: () -> Instant;
export fn{Js} now "performance.now" :: () -> Performance;
export fn{Rs} elapsed Method{"elapsed"} :: Instant -> Duration;
export fn{Js} elapsed "((p) => (performance.now() - p) / 1000.0)" :: Performance -> f64;

/// Uuid-related bindings
export fn{Rs} uuid "alan_std::Uuid::new_v4" <- RootBacking :: () -> uuid;
export fn{Rs} string "format!" :: ("{}", uuid) -> string;

/// GPU-related bindings

// The base bindings to create buffers of memory on the GPU, construct a plan for a compute shader,
// execute it, and read the buffer back to the CPU
export type{Rs} BufferUsages = Binds{"alan_std::BufferUsages" <- RootBacking};
export type{Rs} GBuffer = Binds{"alan_std::GBuffer" <- RootBacking};
export type{Rs} GPGPU = Binds{"alan_std::GPGPU" <- RootBacking};
export fn{Rs} mapReadBuffer "alan_std::map_read_buffer_type" <- RootBacking :: () -> BufferUsages;
export fn{Rs} storageBuffer "alan_std::storage_buffer_type" <- RootBacking :: () -> BufferUsages;
export fn{Rs} GBuffer "alan_std::create_buffer_init" <- RootBacking :: (BufferUsages, i32[]) -> GBuffer;
export fn{Rs} GBuffer "alan_std::create_empty_buffer" <- RootBacking :: (BufferUsages, i64) -> GBuffer;
export fn{Rs} GBuffer(vals: i32[]) = GBuffer(storageBuffer(), vals);
export fn{Rs} GBuffer{T}(vals: T[]) = GBuffer(storageBuffer(), vals.map(fn (v: T) -> i32 = v.i32));
export fn{Rs} GBuffer(size: i64) = GBuffer(storageBuffer(), size);
export fn{Rs} len "alan_std::bufferlen" <- RootBacking :: GBuffer -> i64;
export fn{Rs} id "alan_std::buffer_id" <- RootBacking :: GBuffer -> string;
export fn{Rs} GPGPU "alan_std::GPGPU::new" <- RootBacking :: (Own{string}, Own{Array{Array{GBuffer}}}, Deref{i64[3]}) -> GPGPU;
export fn{Rs} GPGPU(src: string, buf: GBuffer) -> GPGPU {
  // In order to support larger arrays, we need to split the buffer length across them. Each of
  // indices is allowed to be up to 65535 (yes, a 16-bit integer) leading to a maximum length of
  // 65535^3, or about 2.815x10^14 elements (about 281 trillion elements). Not quite up to the
  // 64-bit address space limit 2^64 or about 1.845x10^19 or about 18 quintillion elements, but
  // enough for exactly 1PB of 32-bit numbers in an array, so we should be good.
  // For now, the 65535 limit should be hardcoded by the shader author and an early exit
  // conditional check if the shader is operating on a nonexistent array index. This may change
  // in the future if the performance penalty of the bounds check is considered too high.
  //
  // Explaining the equation itself, the array length, L, needs to be split into X, Y, and Z
  // parts where L = X + A*Y + B*Z, with X, Y, and Z bound between 0 and 65534 (inclusive) while
  // A is 65535 and B is 65535^2 or 4294836225. Computing each dimension is to take the original
  // length of the array (which is the buffer size divided by 4 because we're only supporting
  // 32-bit numbers for now) and then getting the division and remainder first by the B constant,
  // and the Z limit becomes the division + 1, while the remainder is executed division and
  // remainder on the A constant, division + 1, and this remainder becomes the X limit (plus 1).
  // Including this big explanation in case I've made an off-by-one error here ;)
  let l = buf.len();
  let zDiv = l.div(4_294_836_225);
  let z = zDiv.add(1);
  let zRem = l.mod(4_294_836_225);
  let yDiv = zRem.div(65_535);
  let y = yDiv.add(1);
  let yRem = zRem.mod(65_535);
  let x = max(yRem, 1);
  return GPGPU(src, [[buf]], {i64[3]}(x, y, z));
}
export fn{Rs} run "alan_std::gpu_run" <- RootBacking :: GPGPU;
export fn{Rs} read{T} "alan_std::read_buffer" <- RootBacking :: GBuffer -> T[];

// The WgpuType provides a mechanism to build up the logic for a compute shader with normal-looking
// Alan code, not requiring to think in two different languages at the same time. All of the GPU
// types hereafter are derivative of this type
export type{Rs} WgpuType{N} =
  typeName: N,
  varName: string, // Key to the next field
  statements: Dict{string, string},
  buffers: Set{GBuffer};

// Scalar types and constructors
export type{Rs} gu32 = WgpuType{"u32"};
export type{Rs} gi32 = WgpuType{"i32"};
export type{Rs} gf32 = WgpuType{"f32"};
export type{Rs} gbool = WgpuType{"bool"};

// TODO: Better constraining on the input types allowed. It will still fail to compile, but the
// error message isn't great at the moment.
export fn{Rs} build{N}(ret: N) {
  // TODO: Don't assume all of the buffers involved here are storage buffers
  // Also TODO: Support other buffer types than i32
  let bufferArray = Array{GBuffer}().concat(ret.buffers.Array); // TODO: Shouldn't need this concat
  // let bufferArray = ret.buffers.Array;
  let wgslHeader = bufferArray.map(fn (gb: GBuffer, i: i64) {
    return "@group(0)\n@binding("
      .concat(i.string)
      .concat(")\nvar<storage, read_write> ")
      .concat(gb.id)
      .concat(": array<i32>;\n");
  }).join("\n");
  let wgslFunctionHeader = "@compute\n@workgroup_size(1)\nfn main(@builtin(global_invocation_id) id: vec3u) {\n";
  let wgslFunctionBody = ret.statements.Array.map(fn (kv: (string, string)) {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () = "", fn () {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let wgsl = wgslHeader.concat(wgslFunctionHeader).concat(wgslFunctionBody).concat("}");
  let maxGlobalIdArray = ret
    .statements['@builtin(global_invocation_id) id: vec3u']
    .getOr('0,0,0')
    .split(',')
    .map(fn (s: string) = s.i64.getOr(0));
  let maxGlobalId = {i64[3]}(
    maxGlobalIdArray[0].getOr(0),
    maxGlobalIdArray[1].getOr(0),
    maxGlobalIdArray[2].getOr(0)
  );
  let buffers = Array{Array{GBuffer}}();
  buffers.push(bufferArray);
  return GPGPU(wgsl, buffers, maxGlobalId);
}

fn{Rs} gPrimitiveConvert{I, O}(i: I) {
  let typename = {O.typeName}();
  let varName = typename.concat('_').concat(uuid().string.replace('-', '_'));
  let statement = "var "
    .concat(varName)
    .concat(" = ")
    .concat(typename)
    .concat('(')
    .concat(i.varName)
    .concat(')');
  let statements = i.statements.clone().concat(Dict(varName, statement));
  let buffers = i.buffers.clone();
  return {O}(varName, statements, buffers);
}
export fn{Rs} gu32(u: u32) = gu32(u.string, Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gu32(gi: gi32) = gPrimitiveConvert{gi32, gu32}(gi);
export fn{Rs} gu32(gf: gf32) = gPrimitiveConvert{gf32, gu32}(gf);
export fn{Rs} gu32(gb: gbool) = gPrimitiveConvert{gbool, gu32}(gb);
export fn{Rs} gu32{T}(u: T) = gu32(u.u32);

export fn{Rs} gi32(i: i32) = gi32(i.string, Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gi32(gu: gu32) = gPrimitiveConvert{gu32, gi32}(gu);
export fn{Rs} gi32(gf: gf32) = gPrimitiveConvert{gf32, gi32}(gf);
export fn{Rs} gi32(gb: gbool) = gPrimitiveConvert{gbool, gi32}(gb);
export fn{Rs} gi32{T}(i: T) = gi32(i.i32);

export fn{Rs} gf32(f: f32) = gf32(f.string, Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gf32(gu: gu32) = gPrimitiveConvert{gu32, gf32}(gu);
export fn{Rs} gf32(gi: gi32) = gPrimitiveConvert{gi32, gf32}(gi);
export fn{Rs} gf32(gb: gbool) = gPrimitiveConvert{gbool, gf32}(gb);
export fn{Rs} gf32{T}(f: T) = gf32(f.f32);

export fn{Rs} gbool(b: bool) = gbool(b.string, Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gbool(gu: gu32) = gPrimitiveConvert{gu32, gbool}(gu);
export fn{Rs} gbool(gi: gi32) = gPrimitiveConvert{gi32, gbool}(gi);
export fn{Rs} gbool(gf: gf32) = gPrimitiveConvert{gf32, gbool}(gf);
export fn{Rs} gbool{T}(b: T) = gbool(b.bool);

// Vector types and constructors
export type{Rs} gvec2u = WgpuType{"vec2u"};
export type{Rs} gvec2i = WgpuType{"vec2i"};
export type{Rs} gvec2f = WgpuType{"vec2f"};
export type{Rs} gvec2b = WgpuType{"vec2<bool>"};
export type{Rs} gvec3u = WgpuType{"vec3u"};
export type{Rs} gvec3i = WgpuType{"vec3i"};
export type{Rs} gvec3f = WgpuType{"vec3f"};
export type{Rs} gvec3b = WgpuType{"vec3<bool>"};
export type{Rs} gvec4u = WgpuType{"vec4u"};
export type{Rs} gvec4i = WgpuType{"vec4i"};
export type{Rs} gvec4f = WgpuType{"vec4f"};
export type{Rs} gvec4b = WgpuType{"vec4<bool>"};

fn{Rs} gvec2Primitive{I, O}(a: I, b: I) {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(statement, statements, buffers);
}

export fn{Rs} gvec2u() = gvec2u("vec2u()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec2u(a: gu32, b: gu32) = gvec2Primitive{gu32, gvec2u}(a, b);
export fn{Rs} gvec2u{T}(a: T, b: T) = gvec2u(a.gu32, b.gu32);

export fn{Rs} gvec2i() = gvec2i("vec2i()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec2i(a: gi32, b: gi32) = gvec2Primitive{gi32, gvec2i}(a, b);
export fn{Rs} gvec2i{T}(a: T, b: T) = gvec2i(a.gi32, b.gi32);

export fn{Rs} gvec2f() = gvec2f("vec2f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec2f(a: gf32, b: gf32) = gvec2Primitive{gf32, gvec2f}(a, b);
export fn{Rs} gvec2f{T}(a: T, b: T) = gvec2f(a.gf32, b.gf32);

export fn{Rs} gvec2b() = gvec2b("vec2<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec2b(a: gbool, b: gbool) = gvec2Primitive{gbool, gvec2b}(a, b);
export fn{Rs} gvec2b{T}(a: T, b: T) = gvec2b(a.gbool, b.gbool);

fn{Rs} gvec3Primitive{I, O}(a: I, b: I, c: I) {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return {O}(statement, statements, buffers);
}

export fn{Rs} gvec3u() = gvec3u("vec3u()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec3u(a: gu32, b: gu32, c: gu32) = gvec3Primitive{gu32, gvec3u}(a, b, c);
export fn{Rs} gvec3u{T}(a: T, b: T, c: T) = gvec3u(a.gu32, b.gu32, c.gu32);

export fn{Rs} gvec3i() = gvec3i("vec3i()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec3i(a: gi32, b: gi32, c: gi32) = gvec3Primitive{gi32, gvec3i}(a, b, c);
export fn{Rs} gvec3i{T}(a: T, b: T, c: T) = gvec3i(a.gi32, b.gi32, c.gi32);

export fn{Rs} gvec3f() = gvec3f("vec3f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec3f(a: gf32, b: gf32, c: gf32) = gvec3Primitive{gf32, gvec3f}(a, b, c);
export fn{Rs} gvec3f{T}(a: T, b: T, c: T) = gvec3f(a.gf32, b.gf32, c.gf32);

export fn{Rs} gvec3b() = gvec3b("vec3<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec3b(a: gbool, b: gbool, c: gbool) = gvec3Primitive{gbool, gvec3b}(a, b, c);
export fn{Rs} gvec3b{T}(a: T, b: T, c: T) = gvec3b(a.gbool, b.gbool, c.gbool);

fn{Rs} gvec4Primitive{I, O}(a: I, b: I, c: I, d: I) {
  let typename = {O.typeName}();
  let statement = typename
    .concat('(')
    .concat(a.varName)
    .concat(', ')
    .concat(b.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(', ')
    .concat(d.varName)
    .concat(')');
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return {O}(statement, statements, buffers);
}

export fn{Rs} gvec4u() = gvec4u("vec4u()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec4u(a: gu32, b: gu32, c: gu32, d: gu32) = gvec4Primitive{gu32, gvec4u}(
  a, b, c, d
);
export fn{Rs} gvec4u{T}(a: T, b: T, c: T, d: T) = gvec4u(a.gu32, b.gu32, c.gu32, d.gu32);

export fn{Rs} gvec4i() = gvec4i("vec4i()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec4i(a: gi32, b: gi32, c: gi32, d: gi32) = gvec4Primitive{gi32, gvec4i}(
  a, b, c, d
);
export fn{Rs} gvec4i{T}(a: T, b: T, c: T, d: T) = gvec4i(a.gi32, b.gi32, c.gi32, d.gi32);

export fn{Rs} gvec4f() = gvec4f("vec4f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec4f(a: gf32, b: gf32, c: gf32, d: gf32) = gvec4Primitive{gf32, gvec4f}(
  a, b, c, d
);
export fn{Rs} gvec4f{T}(a: T, b: T, c: T, d: T) = gvec4f(a.gf32, b.gf32, c.gf32, d.gf32);

export fn{Rs} gvec4b() = gvec4b("vec4<bool>()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gvec4b(a: gbool, b: gbool, c: gbool, d: gbool) = gvec4Primitive{gbool, gvec4b}(
  a, b, c, d
);
export fn{Rs} gvec4b{T}(a: T, b: T, c: T, d: T) = gvec4b(a.gbool, b.gbool, c.gbool, d.gbool);

// The global_invocation_id; the entry value to a compute shader, and it's constructor, a
// specialized version of gvec3u that initializes a bit differently.
export fn{Rs} gFor(x: u32, y: u32, z: u32) {
  let initialStatement = "@builtin(global_invocation_id) id: vec3u";
  let statements = Dict(initialStatement, x.string.concat(',').concat(y.string).concat(',').concat(z.string));
  return gvec3u('id', statements, Set{GBuffer}());
}
export fn{Rs} gFor{T}(x: T, y: T, z: T) = gFor(x.u32, y.u32, z.u32);
export fn{Rs} gFor{T}(x: T, y: T) = gFor(x.u32, y.u32, 1.u32);
export fn{Rs} gFor{T}(x: T) = gFor(x.u32, 1.u32, 1.u32).x;

// Matrix types
export type{Rs} gmat2x2f = WgpuType{"mat2x2f"};
export type{Rs} gmat2x3f = WgpuType{"mat2x3f"};
export type{Rs} gmat2x4f = WgpuType{"mat2x4f"};
export type{Rs} gmat3x2f = WgpuType{"mat3x2f"};
export type{Rs} gmat3x3f = WgpuType{"mat3x3f"};
export type{Rs} gmat3x4f = WgpuType{"mat3x4f"};
export type{Rs} gmat4x2f = WgpuType{"mat4x2f"};
export type{Rs} gmat4x3f = WgpuType{"mat4x3f"};
export type{Rs} gmat4x4f = WgpuType{"mat4x4f"};

export fn{Rs} gmat2x2f() = gmat2x2f("mat2x2f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat2x2f(a: gvec2f, b: gvec2f) {
  let statement = "mat2x2f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x2f(statement, statements, buffers);
}
export fn{Rs} gmat2x2f(a: gf32, b: gf32, c: gf32, d: gf32) {
  let statement = "mat2x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat2x2f(statement, statements, buffers);
}

export fn{Rs} gmat2x3f() = gmat2x3f("mat2x3f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat2x3f(a: gvec3f, b: gvec3f) {
  let statement = "mat2x3f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x3f(statement, statements, buffers);
}
export fn{Rs} gmat2x3f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) {
  let statement = "mat2x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat2x3f(statement, statements, buffers);
}

export fn{Rs} gmat2x4f() = gmat2x4f("mat2x4f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat2x4f(a: gvec4f, b: gvec4f) {
  let statement = "mat2x4f(".concat(a.varName).concat(", ").concat(b.varName).concat(")");
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return gmat2x4f(statement, statements, buffers);
}
export fn{Rs} gmat2x4f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32, g: gf32, h: gf32) {
  let statement = "mat2x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat2x4f(statement, statements, buffers);
}

export fn{Rs} gmat3x2f() = gmat3x2f("mat3x2f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat3x2f(a: gvec2f, b: gvec2f, c: gvec2f) {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x2f(statement, statements, buffers);
}
export fn{Rs} gmat3x2f(a: gf32, b: gf32, c: gf32, d: gf32, e: gf32, f: gf32) {
  let statement = "mat3x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers);
  return gmat3x2f(statement, statements, buffers);
}

export fn{Rs} gmat3x3f() = gmat3x3f("mat3x3f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat3x3f(a: gvec3f, b: gvec3f, c: gvec3f) {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x3f(statement, statements, buffers);
}
export fn{Rs} gmat3x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32
) {
  let statement = "mat3x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers);
  return gmat3x3f(statement, statements, buffers);
}

export fn{Rs} gmat3x4f() = gmat3x4f("mat3x4f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat3x4f(a: gvec4f, b: gvec4f, c: gvec4f) {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers);
  return gmat3x4f(statement, statements, buffers);
}
export fn{Rs} gmat3x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) {
  let statement = "mat3x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat3x4f(statement, statements, buffers);
}

export fn{Rs} gmat4x2f() = gmat4x2f("mat4x2f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat4x2f(a: gvec2f, b: gvec2f, c: gvec2f, d: gvec2f) {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x2f(statement, statements, buffers);
}
export fn{Rs} gmat4x2f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32
) {
  let statement = "mat4x2f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers);
  return gmat4x2f(statement, statements, buffers);
}

export fn{Rs} gmat4x3f() = gmat4x3f("mat4x3f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat4x3f(a: gvec3f, b: gvec3f, c: gvec3f, d: gvec3f) {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x3f(statement, statements, buffers);
}
export fn{Rs} gmat4x3f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32
) {
  let statement = "mat4x3f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers);
  return gmat4x3f(statement, statements, buffers);
}

export fn{Rs} gmat4x4f() = gmat4x4f("mat4x4f()", Dict{string, string}(), Set{GBuffer}());
export fn{Rs} gmat4x4f(a: gvec4f, b: gvec4f, c: gvec4f, d: gvec4f) {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(")");
  let statements = a.statements.concat(b.statements).concat(c.statements).concat(d.statements);
  let buffers = a.buffers.union(b.buffers).union(c.buffers).union(d.buffers);
  return gmat4x4f(statement, statements, buffers);
}
export fn{Rs} gmat4x4f(
  a: gf32,
  b: gf32,
  c: gf32,
  d: gf32,
  e: gf32,
  f: gf32,
  g: gf32,
  h: gf32,
  i: gf32,
  j: gf32,
  k: gf32,
  l: gf32,
  m: gf32,
  n: gf32,
  o: gf32,
  p: gf32
) {
  let statement = "mat4x4f("
    .concat(a.varName)
    .concat(", ")
    .concat(b.varName)
    .concat(", ")
    .concat(c.varName)
    .concat(", ")
    .concat(d.varName)
    .concat(", ")
    .concat(e.varName)
    .concat(", ")
    .concat(f.varName)
    .concat(", ")
    .concat(g.varName)
    .concat(", ")
    .concat(h.varName)
    .concat(", ")
    .concat(i.varName)
    .concat(", ")
    .concat(j.varName)
    .concat(", ")
    .concat(k.varName)
    .concat(", ")
    .concat(l.varName)
    .concat(", ")
    .concat(m.varName)
    .concat(", ")
    .concat(n.varName)
    .concat(", ")
    .concat(o.varName)
    .concat(", ")
    .concat(p.varName)
    .concat(")");
  let statements = a.statements
    .concat(b.statements)
    .concat(c.statements)
    .concat(d.statements)
    .concat(e.statements)
    .concat(f.statements)
    .concat(g.statements)
    .concat(h.statements)
    .concat(i.statements)
    .concat(j.statements)
    .concat(k.statements)
    .concat(l.statements)
    .concat(m.statements)
    .concat(n.statements)
    .concat(o.statements)
    .concat(p.statements);
  let buffers = a.buffers
    .union(b.buffers)
    .union(c.buffers)
    .union(d.buffers)
    .union(e.buffers)
    .union(f.buffers)
    .union(g.buffers)
    .union(h.buffers)
    .union(i.buffers)
    .union(j.buffers)
    .union(k.buffers)
    .union(l.buffers)
    .union(m.buffers)
    .union(n.buffers)
    .union(o.buffers)
    .union(p.buffers);
  return gmat4x4f(statement, statements, buffers);
}

// TODO: Fixed-length buffers within wgsl

// TODO: How to handle structs?

// GPU Type accessors

export fn{Rs} x(v: gvec2u) {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec2u) {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec2u) = v.x;
export fn{Rs} j(v: gvec2u) = v.y;
export fn{Rs} r(v: gvec2u) = v.x;
export fn{Rs} g(v: gvec2u) = v.y;

fn{Rs} gvec22u(v: gvec2u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec2u) = gvec22u(v, '.xy');
export fn{Rs} yx(v: gvec2u) = gvec22u(v, '.yx');
export fn{Rs} ij(v: gvec2u) = v.xy;
export fn{Rs} ji(v: gvec2u) = v.yx;
export fn{Rs} rg(v: gvec2u) = v.xy;
export fn{Rs} gr(v: gvec2u) = v.yx;

export fn{Rs} x(v: gvec2i) {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec2i) {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec2i) = v.x;
export fn{Rs} j(v: gvec2i) = v.y;
export fn{Rs} r(v: gvec2i) = v.x;
export fn{Rs} g(v: gvec2i) = v.y;

fn{Rs} gvec22i(v: gvec2i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec2i) = gvec22i(v, '.xy');
export fn{Rs} yx(v: gvec2i) = gvec22i(v, '.yx');
export fn{Rs} ij(v: gvec2i) = v.xy;
export fn{Rs} ji(v: gvec2i) = v.yx;
export fn{Rs} rg(v: gvec2i) = v.xy;
export fn{Rs} gr(v: gvec2i) = v.yx;

export fn{Rs} x(v: gvec2f) {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec2f) {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec2f) = v.x;
export fn{Rs} j(v: gvec2f) = v.y;
export fn{Rs} r(v: gvec2f) = v.x;
export fn{Rs} g(v: gvec2f) = v.y;

fn{Rs} gvec22f(v: gvec2f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec2f) = gvec22f(v, '.xy');
export fn{Rs} yx(v: gvec2f) = gvec22f(v, '.yx');
export fn{Rs} ij(v: gvec2f) = v.xy;
export fn{Rs} ji(v: gvec2f) = v.yx;
export fn{Rs} rg(v: gvec2f) = v.xy;
export fn{Rs} gr(v: gvec2f) = v.yx;

export fn{Rs} x(v: gvec2b) {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec2b) {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec2b) = v.x;
export fn{Rs} j(v: gvec2b) = v.y;
export fn{Rs} r(v: gvec2b) = v.x;
export fn{Rs} g(v: gvec2b) = v.y;

fn{Rs} gvec22b(v: gvec2b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec2b) = gvec22b(v, '.xy');
export fn{Rs} yx(v: gvec2b) = gvec22b(v, '.yx');
export fn{Rs} ij(v: gvec2b) = v.xy;
export fn{Rs} ji(v: gvec2b) = v.yx;
export fn{Rs} rg(v: gvec2b) = v.xy;
export fn{Rs} gr(v: gvec2b) = v.yx;

export fn{Rs} x(v: gvec3u) {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec3u) {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec3u) {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec3u) = v.x;
export fn{Rs} j(v: gvec3u) = v.y;
export fn{Rs} k(v: gvec3u) = v.z;
export fn{Rs} r(v: gvec3u) = v.x;
export fn{Rs} g(v: gvec3u) = v.y;
export fn{Rs} b(v: gvec3u) = v.z;

fn{Rs} gvec32u(v: gvec3u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec3u) = gvec32u(v, '.xy');
export fn{Rs} yx(v: gvec3u) = gvec32u(v, '.yx');
export fn{Rs} xz(v: gvec3u) = gvec32u(v, '.xz');
export fn{Rs} zx(v: gvec3u) = gvec32u(v, '.zx');
export fn{Rs} yz(v: gvec3u) = gvec32u(v, '.yz');
export fn{Rs} zy(v: gvec3u) = gvec32u(v, '.zy');
export fn{Rs} ij(v: gvec3u) = v.xy;
export fn{Rs} ji(v: gvec3u) = v.yx;
export fn{Rs} ik(v: gvec3u) = v.xz;
export fn{Rs} ki(v: gvec3u) = v.zx;
export fn{Rs} jk(v: gvec3u) = v.yz;
export fn{Rs} kj(v: gvec3u) = v.zy;
export fn{Rs} rg(v: gvec3u) = v.xy;
export fn{Rs} gr(v: gvec3u) = v.yx;
export fn{Rs} rb(v: gvec3u) = v.xz;
export fn{Rs} br(v: gvec3u) = v.zx;
export fn{Rs} gb(v: gvec3u) = v.yz;
export fn{Rs} bg(v: gvec3u) = v.zy;

fn{Rs} gvec33u(v: gvec3u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
export fn{Rs} xyz(v: gvec3u) = gvec33u(v, '.xyz');
export fn{Rs} xzy(v: gvec3u) = gvec33u(v, '.xzy');
export fn{Rs} yxz(v: gvec3u) = gvec33u(v, '.yxz');
export fn{Rs} yzx(v: gvec3u) = gvec33u(v, '.yzx');
export fn{Rs} zxy(v: gvec3u) = gvec33u(v, '.zxy');
export fn{Rs} zyx(v: gvec3u) = gvec33u(v, '.zyx');
export fn{Rs} ijk(v: gvec3u) = v.xyz;
export fn{Rs} ikj(v: gvec3u) = v.xzy;
export fn{Rs} jik(v: gvec3u) = v.yxz;
export fn{Rs} jki(v: gvec3u) = v.yzx;
export fn{Rs} kij(v: gvec3u) = v.zxy;
export fn{Rs} kji(v: gvec3u) = v.zyx;
export fn{Rs} rgb(v: gvec3u) = v.xyz;
export fn{Rs} rbg(v: gvec3u) = v.xzy;
export fn{Rs} grb(v: gvec3u) = v.yxz;
export fn{Rs} gbr(v: gvec3u) = v.yzx;
export fn{Rs} brg(v: gvec3u) = v.zxy;
export fn{Rs} bgr(v: gvec3u) = v.zyx;

export fn{Rs} x(v: gvec3i) {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec3i) {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec3i) {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec3i) = v.x;
export fn{Rs} j(v: gvec3i) = v.y;
export fn{Rs} k(v: gvec3i) = v.z;
export fn{Rs} r(v: gvec3i) = v.x;
export fn{Rs} g(v: gvec3i) = v.y;
export fn{Rs} b(v: gvec3i) = v.z;

fn{Rs} gvec32i(v: gvec3i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec3i) = gvec32i(v, '.xy');
export fn{Rs} yx(v: gvec3i) = gvec32i(v, '.yx');
export fn{Rs} xz(v: gvec3i) = gvec32i(v, '.xz');
export fn{Rs} zx(v: gvec3i) = gvec32i(v, '.zx');
export fn{Rs} yz(v: gvec3i) = gvec32i(v, '.yz');
export fn{Rs} zy(v: gvec3i) = gvec32i(v, '.zy');
export fn{Rs} ij(v: gvec3i) = v.xy;
export fn{Rs} ji(v: gvec3i) = v.yx;
export fn{Rs} ik(v: gvec3i) = v.xz;
export fn{Rs} ki(v: gvec3i) = v.zx;
export fn{Rs} jk(v: gvec3i) = v.yz;
export fn{Rs} kj(v: gvec3i) = v.zy;
export fn{Rs} rg(v: gvec3i) = v.xy;
export fn{Rs} gr(v: gvec3i) = v.yx;
export fn{Rs} rb(v: gvec3i) = v.xz;
export fn{Rs} br(v: gvec3i) = v.zx;
export fn{Rs} gb(v: gvec3i) = v.yz;
export fn{Rs} bg(v: gvec3i) = v.zy;

fn{Rs} gvec33i(v: gvec3i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
export fn{Rs} xyz(v: gvec3i) = gvec33i(v, '.xyz');
export fn{Rs} xzy(v: gvec3i) = gvec33i(v, '.xzy');
export fn{Rs} yxz(v: gvec3i) = gvec33i(v, '.yxz');
export fn{Rs} yzx(v: gvec3i) = gvec33i(v, '.yzx');
export fn{Rs} zxy(v: gvec3i) = gvec33i(v, '.zxy');
export fn{Rs} zyx(v: gvec3i) = gvec33i(v, '.zyx');
export fn{Rs} ijk(v: gvec3i) = v.xyz;
export fn{Rs} ikj(v: gvec3i) = v.xzy;
export fn{Rs} jik(v: gvec3i) = v.yxz;
export fn{Rs} jki(v: gvec3i) = v.yzx;
export fn{Rs} kij(v: gvec3i) = v.zxy;
export fn{Rs} kji(v: gvec3i) = v.zyx;
export fn{Rs} rgb(v: gvec3i) = v.xyz;
export fn{Rs} rbg(v: gvec3i) = v.xzy;
export fn{Rs} grb(v: gvec3i) = v.yxz;
export fn{Rs} gbr(v: gvec3i) = v.yzx;
export fn{Rs} brg(v: gvec3i) = v.zxy;
export fn{Rs} bgr(v: gvec3i) = v.zyx;

export fn{Rs} x(v: gvec3f) {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec3f) {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec3f) {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec3f) = v.x;
export fn{Rs} j(v: gvec3f) = v.y;
export fn{Rs} k(v: gvec3f) = v.z;
export fn{Rs} r(v: gvec3f) = v.x;
export fn{Rs} g(v: gvec3f) = v.y;
export fn{Rs} b(v: gvec3f) = v.z;

fn{Rs} gvec32f(v: gvec3f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec3f) = gvec32f(v, '.xy');
export fn{Rs} yx(v: gvec3f) = gvec32f(v, '.yx');
export fn{Rs} xz(v: gvec3f) = gvec32f(v, '.xz');
export fn{Rs} zx(v: gvec3f) = gvec32f(v, '.zx');
export fn{Rs} yz(v: gvec3f) = gvec32f(v, '.yz');
export fn{Rs} zy(v: gvec3f) = gvec32f(v, '.zy');
export fn{Rs} ij(v: gvec3f) = v.xy;
export fn{Rs} ji(v: gvec3f) = v.yx;
export fn{Rs} ik(v: gvec3f) = v.xz;
export fn{Rs} ki(v: gvec3f) = v.zx;
export fn{Rs} jk(v: gvec3f) = v.yz;
export fn{Rs} kj(v: gvec3f) = v.zy;
export fn{Rs} rg(v: gvec3f) = v.xy;
export fn{Rs} gr(v: gvec3f) = v.yx;
export fn{Rs} rb(v: gvec3f) = v.xz;
export fn{Rs} br(v: gvec3f) = v.zx;
export fn{Rs} gb(v: gvec3f) = v.yz;
export fn{Rs} bg(v: gvec3f) = v.zy;

fn{Rs} gvec33f(v: gvec3f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
export fn{Rs} xyz(v: gvec3f) = gvec33f(v, '.xyz');
export fn{Rs} xzy(v: gvec3f) = gvec33f(v, '.xzy');
export fn{Rs} yxz(v: gvec3f) = gvec33f(v, '.yxz');
export fn{Rs} yzx(v: gvec3f) = gvec33f(v, '.yzx');
export fn{Rs} zxy(v: gvec3f) = gvec33f(v, '.zxy');
export fn{Rs} zyx(v: gvec3f) = gvec33f(v, '.zyx');
export fn{Rs} ijk(v: gvec3f) = v.xyz;
export fn{Rs} ikj(v: gvec3f) = v.xzy;
export fn{Rs} jik(v: gvec3f) = v.yxz;
export fn{Rs} jki(v: gvec3f) = v.yzx;
export fn{Rs} kij(v: gvec3f) = v.zxy;
export fn{Rs} kji(v: gvec3f) = v.zyx;
export fn{Rs} rgb(v: gvec3f) = v.xyz;
export fn{Rs} rbg(v: gvec3f) = v.xzy;
export fn{Rs} grb(v: gvec3f) = v.yxz;
export fn{Rs} gbr(v: gvec3f) = v.yzx;
export fn{Rs} brg(v: gvec3f) = v.zxy;
export fn{Rs} bgr(v: gvec3f) = v.zyx;

export fn{Rs} x(v: gvec3b) {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec3b) {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec3b) {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec3b) = v.x;
export fn{Rs} j(v: gvec3b) = v.y;
export fn{Rs} k(v: gvec3b) = v.z;
export fn{Rs} r(v: gvec3b) = v.x;
export fn{Rs} g(v: gvec3b) = v.y;
export fn{Rs} b(v: gvec3b) = v.z;

fn{Rs} gvec32b(v: gvec3b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec3b) = gvec32b(v, '.xy');
export fn{Rs} yx(v: gvec3b) = gvec32b(v, '.yx');
export fn{Rs} xz(v: gvec3b) = gvec32b(v, '.xz');
export fn{Rs} zx(v: gvec3b) = gvec32b(v, '.zx');
export fn{Rs} yz(v: gvec3b) = gvec32b(v, '.yz');
export fn{Rs} zy(v: gvec3b) = gvec32b(v, '.zy');
export fn{Rs} ij(v: gvec3b) = v.xy;
export fn{Rs} ji(v: gvec3b) = v.yx;
export fn{Rs} ik(v: gvec3b) = v.xz;
export fn{Rs} ki(v: gvec3b) = v.zx;
export fn{Rs} jk(v: gvec3b) = v.yz;
export fn{Rs} kj(v: gvec3b) = v.zy;
export fn{Rs} rg(v: gvec3b) = v.xy;
export fn{Rs} gr(v: gvec3b) = v.yx;
export fn{Rs} rb(v: gvec3b) = v.xz;
export fn{Rs} br(v: gvec3b) = v.zx;
export fn{Rs} gb(v: gvec3b) = v.yz;
export fn{Rs} bg(v: gvec3b) = v.zy;

fn{Rs} gvec33b(v: gvec3b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
export fn{Rs} xyz(v: gvec3b) = gvec33b(v, '.xyz');
export fn{Rs} xzy(v: gvec3b) = gvec33b(v, '.xzy');
export fn{Rs} yxz(v: gvec3b) = gvec33b(v, '.yxz');
export fn{Rs} yzx(v: gvec3b) = gvec33b(v, '.yzx');
export fn{Rs} zxy(v: gvec3b) = gvec33b(v, '.zxy');
export fn{Rs} zyx(v: gvec3b) = gvec33b(v, '.zyx');
export fn{Rs} ijk(v: gvec3b) = v.xyz;
export fn{Rs} ikj(v: gvec3b) = v.xzy;
export fn{Rs} jik(v: gvec3b) = v.yxz;
export fn{Rs} jki(v: gvec3b) = v.yzx;
export fn{Rs} kij(v: gvec3b) = v.zxy;
export fn{Rs} kji(v: gvec3b) = v.zyx;
export fn{Rs} rgb(v: gvec3b) = v.xyz;
export fn{Rs} rbg(v: gvec3b) = v.xzy;
export fn{Rs} grb(v: gvec3b) = v.yxz;
export fn{Rs} gbr(v: gvec3b) = v.yzx;
export fn{Rs} brg(v: gvec3b) = v.zxy;
export fn{Rs} bgr(v: gvec3b) = v.zyx;

export fn{Rs} x(v: gvec4u) {
  let varName = v.varName.concat('.x');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec4u) {
  let varName = v.varName.concat('.y');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec4u) {
  let varName = v.varName.concat('.z');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} w(v: gvec4u) {
  let varName = v.varName.concat('.w');
  return gu32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec4u) = v.x;
export fn{Rs} j(v: gvec4u) = v.y;
export fn{Rs} k(v: gvec4u) = v.z;
export fn{Rs} l(v: gvec4u) = v.w;
export fn{Rs} r(v: gvec4u) = v.x;
export fn{Rs} g(v: gvec4u) = v.y;
export fn{Rs} b(v: gvec4u) = v.z;
export fn{Rs} a(v: gvec4u) = v.w;

fn{Rs} gvec42u(v: gvec4u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2u(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec4u) = gvec42u(v, '.xy');
export fn{Rs} yx(v: gvec4u) = gvec42u(v, '.yx');
export fn{Rs} xz(v: gvec4u) = gvec42u(v, '.xz');
export fn{Rs} zx(v: gvec4u) = gvec42u(v, '.zx');
export fn{Rs} xw(v: gvec4u) = gvec42u(v, '.xw');
export fn{Rs} wx(v: gvec4u) = gvec42u(v, '.wx');
export fn{Rs} yz(v: gvec4u) = gvec42u(v, '.yz');
export fn{Rs} zy(v: gvec4u) = gvec42u(v, '.zy');
export fn{Rs} yw(v: gvec4u) = gvec42u(v, '.yw');
export fn{Rs} wy(v: gvec4u) = gvec42u(v, '.wy');
export fn{Rs} zw(v: gvec4u) = gvec42u(v, '.zw');
export fn{Rs} wz(v: gvec4u) = gvec42u(v, '.wz');
export fn{Rs} ij(v: gvec4u) = v.xy;
export fn{Rs} ji(v: gvec4u) = v.yx;
export fn{Rs} ik(v: gvec4u) = v.xz;
export fn{Rs} ki(v: gvec4u) = v.zx;
export fn{Rs} il(v: gvec4u) = v.xw;
export fn{Rs} li(v: gvec4u) = v.wx;
export fn{Rs} jk(v: gvec4u) = v.yz;
export fn{Rs} kj(v: gvec4u) = v.zy;
export fn{Rs} jl(v: gvec4u) = v.yw;
export fn{Rs} lj(v: gvec4u) = v.wy;
export fn{Rs} kl(v: gvec4u) = v.zw;
export fn{Rs} lk(v: gvec4u) = v.wz;
export fn{Rs} rg(v: gvec4u) = v.xy;
export fn{Rs} gr(v: gvec4u) = v.yx;
export fn{Rs} rb(v: gvec4u) = v.xz;
export fn{Rs} br(v: gvec4u) = v.zx;
export fn{Rs} ra(v: gvec4u) = v.xw;
export fn{Rs} ar(v: gvec4u) = v.wx;
export fn{Rs} gb(v: gvec4u) = v.yz;
export fn{Rs} bg(v: gvec4u) = v.zy;
export fn{Rs} ga(v: gvec4u) = v.yw;
export fn{Rs} ag(v: gvec4u) = v.wy;
export fn{Rs} ba(v: gvec4u) = v.zw;
export fn{Rs} ab(v: gvec4u) = v.wz;

fn{Rs} gvec43u(v: gvec4u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3u(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn{Rs} xyz(v: gvec4u) = gvec43u(v, '.xyz'); // 123
export fn{Rs} xyw(v: gvec4u) = gvec43u(v, '.xyw'); // 124
export fn{Rs} xzy(v: gvec4u) = gvec43u(v, '.xzy'); // 132
export fn{Rs} xzw(v: gvec4u) = gvec43u(v, '.xzw'); // 134
export fn{Rs} xwy(v: gvec4u) = gvec43u(v, '.xwy'); // 142
export fn{Rs} xwz(v: gvec4u) = gvec43u(v, '.xwz'); // 143
export fn{Rs} yxz(v: gvec4u) = gvec43u(v, '.yxz'); // 213
export fn{Rs} yxw(v: gvec4u) = gvec43u(v, '.yxw'); // 214
export fn{Rs} yzx(v: gvec4u) = gvec43u(v, '.yzx'); // 231
export fn{Rs} yzw(v: gvec4u) = gvec43u(v, '.yzw'); // 234
export fn{Rs} ywx(v: gvec4u) = gvec43u(v, '.ywx'); // 241
export fn{Rs} ywz(v: gvec4u) = gvec43u(v, '.ywz'); // 243
export fn{Rs} zxy(v: gvec4u) = gvec43u(v, '.zxy'); // 312
export fn{Rs} zxw(v: gvec4u) = gvec43u(v, '.zxw'); // 314
export fn{Rs} zyx(v: gvec4u) = gvec43u(v, '.zyx'); // 321
export fn{Rs} zyw(v: gvec4u) = gvec43u(v, '.zyw'); // 324
export fn{Rs} zwx(v: gvec4u) = gvec43u(v, '.zwx'); // 341
export fn{Rs} zwy(v: gvec4u) = gvec43u(v, '.zwy'); // 342
export fn{Rs} wxy(v: gvec4u) = gvec43u(v, '.wxy'); // 412
export fn{Rs} wxz(v: gvec4u) = gvec43u(v, '.wxz'); // 413
export fn{Rs} wyx(v: gvec4u) = gvec43u(v, '.wyx'); // 421
export fn{Rs} wyz(v: gvec4u) = gvec43u(v, '.wyz'); // 423
export fn{Rs} wzx(v: gvec4u) = gvec43u(v, '.wzx'); // 431
export fn{Rs} wzy(v: gvec4u) = gvec43u(v, '.wzy'); // 432
export fn{Rs} ijk(v: gvec4u) = v.xyz;
export fn{Rs} ijl(v: gvec4u) = v.xyw;
export fn{Rs} ikj(v: gvec4u) = v.xzy;
export fn{Rs} ikl(v: gvec4u) = v.xzw;
export fn{Rs} ilj(v: gvec4u) = v.xwy;
export fn{Rs} ilk(v: gvec4u) = v.xwz;
export fn{Rs} jik(v: gvec4u) = v.yxz;
export fn{Rs} jil(v: gvec4u) = v.yxw;
export fn{Rs} jki(v: gvec4u) = v.yzx;
export fn{Rs} jkl(v: gvec4u) = v.yzw;
export fn{Rs} jli(v: gvec4u) = v.ywx;
export fn{Rs} jlk(v: gvec4u) = v.ywz;
export fn{Rs} kij(v: gvec4u) = v.zxy;
export fn{Rs} kil(v: gvec4u) = v.zxw;
export fn{Rs} kji(v: gvec4u) = v.zyx;
export fn{Rs} kjl(v: gvec4u) = v.zyw;
export fn{Rs} kli(v: gvec4u) = v.zwx;
export fn{Rs} klj(v: gvec4u) = v.zwy;
export fn{Rs} lij(v: gvec4u) = v.wxy;
export fn{Rs} lik(v: gvec4u) = v.wxz;
export fn{Rs} lji(v: gvec4u) = v.wyx;
export fn{Rs} ljk(v: gvec4u) = v.wyz;
export fn{Rs} lki(v: gvec4u) = v.wzx;
export fn{Rs} lkj(v: gvec4u) = v.wzy;
export fn{Rs} rgb(v: gvec4u) = v.xyz;
export fn{Rs} rga(v: gvec4u) = v.xyw;
export fn{Rs} rbg(v: gvec4u) = v.xzy;
export fn{Rs} rba(v: gvec4u) = v.xzw;
export fn{Rs} rag(v: gvec4u) = v.xwy;
export fn{Rs} rab(v: gvec4u) = v.xwz;
export fn{Rs} grb(v: gvec4u) = v.yxz;
export fn{Rs} gra(v: gvec4u) = v.yxw;
export fn{Rs} gbr(v: gvec4u) = v.yzx;
export fn{Rs} gba(v: gvec4u) = v.yzw;
export fn{Rs} gar(v: gvec4u) = v.ywx;
export fn{Rs} gab(v: gvec4u) = v.ywz;
export fn{Rs} brg(v: gvec4u) = v.zxy;
export fn{Rs} bra(v: gvec4u) = v.zxw;
export fn{Rs} bgr(v: gvec4u) = v.zyx;
export fn{Rs} bga(v: gvec4u) = v.zyw;
export fn{Rs} bar(v: gvec4u) = v.zwx;
export fn{Rs} bag(v: gvec4u) = v.zwy;
export fn{Rs} arb(v: gvec4u) = v.wxy;
export fn{Rs} arg(v: gvec4u) = v.wxz;
export fn{Rs} abr(v: gvec4u) = v.wyx;
export fn{Rs} abg(v: gvec4u) = v.wyz;
export fn{Rs} agr(v: gvec4u) = v.wzx;
export fn{Rs} agb(v: gvec4u) = v.wzy;

fn{Rs} gvec44u(v: gvec4u, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4u(varName, v.statements, v.buffers);
}
export fn{Rs} xyzw(v: gvec4u) = gvec44u(v, '.xyzw'); // 1234
export fn{Rs} xywz(v: gvec4u) = gvec44u(v, '.xywz'); // 1243
export fn{Rs} xzyw(v: gvec4u) = gvec44u(v, '.xzyw'); // 1324
export fn{Rs} xzwy(v: gvec4u) = gvec44u(v, '.xzwy'); // 1342
export fn{Rs} xwyz(v: gvec4u) = gvec44u(v, '.xwyz'); // 1423
export fn{Rs} xwzy(v: gvec4u) = gvec44u(v, '.xwzy'); // 1432
export fn{Rs} yxzw(v: gvec4u) = gvec44u(v, '.yxzw'); // 2134
export fn{Rs} yxwz(v: gvec4u) = gvec44u(v, '.yxwz'); // 2143
export fn{Rs} yzxw(v: gvec4u) = gvec44u(v, '.yzxw'); // 2314
export fn{Rs} yzwx(v: gvec4u) = gvec44u(v, '.yzwx'); // 2341
export fn{Rs} ywxz(v: gvec4u) = gvec44u(v, '.ywxz'); // 2413
export fn{Rs} ywzx(v: gvec4u) = gvec44u(v, '.ywzx'); // 2431
export fn{Rs} zxyw(v: gvec4u) = gvec44u(v, '.zxyw'); // 3124
export fn{Rs} zxwy(v: gvec4u) = gvec44u(v, '.zxwy'); // 3142
export fn{Rs} zyxw(v: gvec4u) = gvec44u(v, '.zyxw'); // 3214
export fn{Rs} zywx(v: gvec4u) = gvec44u(v, '.zywx'); // 3241
export fn{Rs} zwxy(v: gvec4u) = gvec44u(v, '.zwxy'); // 3412
export fn{Rs} zwyx(v: gvec4u) = gvec44u(v, '.zwyx'); // 3421
export fn{Rs} wxyz(v: gvec4u) = gvec44u(v, '.wxyz'); // 4123
export fn{Rs} wxzy(v: gvec4u) = gvec44u(v, '.wxzy'); // 4132
export fn{Rs} wyxz(v: gvec4u) = gvec44u(v, '.wyxz'); // 4213
export fn{Rs} wyzx(v: gvec4u) = gvec44u(v, '.wyzx'); // 4231
export fn{Rs} wzxy(v: gvec4u) = gvec44u(v, '.wzxy'); // 4312
export fn{Rs} wzyx(v: gvec4u) = gvec44u(v, '.wzyx'); // 4321
export fn{Rs} ijkl(v: gvec4u) = v.xyzw;
export fn{Rs} ijlk(v: gvec4u) = v.xywz;
export fn{Rs} ikjl(v: gvec4u) = v.xzyw;
export fn{Rs} iklj(v: gvec4u) = v.xzwy;
export fn{Rs} iljk(v: gvec4u) = v.xwyz;
export fn{Rs} ilkj(v: gvec4u) = v.xwzy;
export fn{Rs} jikl(v: gvec4u) = v.yxzw;
export fn{Rs} jilk(v: gvec4u) = v.yxwz;
export fn{Rs} jkil(v: gvec4u) = v.yzxw;
export fn{Rs} jkli(v: gvec4u) = v.yzwx;
export fn{Rs} jlik(v: gvec4u) = v.ywxz;
export fn{Rs} jlki(v: gvec4u) = v.ywzx;
export fn{Rs} kijl(v: gvec4u) = v.zxyw;
export fn{Rs} kilj(v: gvec4u) = v.zxwy;
export fn{Rs} kjil(v: gvec4u) = v.zyxw;
export fn{Rs} kjli(v: gvec4u) = v.zywx;
export fn{Rs} klij(v: gvec4u) = v.zwxy;
export fn{Rs} klji(v: gvec4u) = v.zwyx;
export fn{Rs} lijk(v: gvec4u) = v.wxyz;
export fn{Rs} likj(v: gvec4u) = v.wxzy;
export fn{Rs} ljik(v: gvec4u) = v.wyxz;
export fn{Rs} ljki(v: gvec4u) = v.wyzx;
export fn{Rs} lkij(v: gvec4u) = v.wzxy;
export fn{Rs} lkji(v: gvec4u) = v.wzyx;
export fn{Rs} rgba(v: gvec4u) = v.xyzw;
export fn{Rs} rgab(v: gvec4u) = v.xywz;
export fn{Rs} rbga(v: gvec4u) = v.xzyw;
export fn{Rs} rbag(v: gvec4u) = v.xzwy;
export fn{Rs} ragb(v: gvec4u) = v.xwyz;
export fn{Rs} rabg(v: gvec4u) = v.xwzy;
export fn{Rs} grba(v: gvec4u) = v.yxzw;
export fn{Rs} grab(v: gvec4u) = v.yxwz;
export fn{Rs} gbra(v: gvec4u) = v.yzxw;
export fn{Rs} gbar(v: gvec4u) = v.yzwx;
export fn{Rs} garb(v: gvec4u) = v.ywxz;
export fn{Rs} gabr(v: gvec4u) = v.ywzx;
export fn{Rs} argb(v: gvec4u) = v.wxyz;
export fn{Rs} arbg(v: gvec4u) = v.wxzy;
export fn{Rs} agrb(v: gvec4u) = v.wyxz;
export fn{Rs} agbr(v: gvec4u) = v.wyzx;
export fn{Rs} abrg(v: gvec4u) = v.wzxy;
export fn{Rs} abgr(v: gvec4u) = v.wzyx;

export fn{Rs} x(v: gvec4i) {
  let varName = v.varName.concat('.x');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec4i) {
  let varName = v.varName.concat('.y');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec4i) {
  let varName = v.varName.concat('.z');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} w(v: gvec4i) {
  let varName = v.varName.concat('.w');
  return gi32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec4i) = v.x;
export fn{Rs} j(v: gvec4i) = v.y;
export fn{Rs} k(v: gvec4i) = v.z;
export fn{Rs} l(v: gvec4i) = v.w;
export fn{Rs} r(v: gvec4i) = v.x;
export fn{Rs} g(v: gvec4i) = v.y;
export fn{Rs} b(v: gvec4i) = v.z;
export fn{Rs} a(v: gvec4i) = v.w;

fn{Rs} gvec42i(v: gvec4i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2i(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec4i) = gvec42i(v, '.xy');
export fn{Rs} yx(v: gvec4i) = gvec42i(v, '.yx');
export fn{Rs} xz(v: gvec4i) = gvec42i(v, '.xz');
export fn{Rs} zx(v: gvec4i) = gvec42i(v, '.zx');
export fn{Rs} xw(v: gvec4i) = gvec42i(v, '.xw');
export fn{Rs} wx(v: gvec4i) = gvec42i(v, '.wx');
export fn{Rs} yz(v: gvec4i) = gvec42i(v, '.yz');
export fn{Rs} zy(v: gvec4i) = gvec42i(v, '.zy');
export fn{Rs} yw(v: gvec4i) = gvec42i(v, '.yw');
export fn{Rs} wy(v: gvec4i) = gvec42i(v, '.wy');
export fn{Rs} zw(v: gvec4i) = gvec42i(v, '.zw');
export fn{Rs} wz(v: gvec4i) = gvec42i(v, '.wz');
export fn{Rs} ij(v: gvec4i) = v.xy;
export fn{Rs} ji(v: gvec4i) = v.yx;
export fn{Rs} ik(v: gvec4i) = v.xz;
export fn{Rs} ki(v: gvec4i) = v.zx;
export fn{Rs} il(v: gvec4i) = v.xw;
export fn{Rs} li(v: gvec4i) = v.wx;
export fn{Rs} jk(v: gvec4i) = v.yz;
export fn{Rs} kj(v: gvec4i) = v.zy;
export fn{Rs} jl(v: gvec4i) = v.yw;
export fn{Rs} lj(v: gvec4i) = v.wy;
export fn{Rs} kl(v: gvec4i) = v.zw;
export fn{Rs} lk(v: gvec4i) = v.wz;
export fn{Rs} rg(v: gvec4i) = v.xy;
export fn{Rs} gr(v: gvec4i) = v.yx;
export fn{Rs} rb(v: gvec4i) = v.xz;
export fn{Rs} br(v: gvec4i) = v.zx;
export fn{Rs} ra(v: gvec4i) = v.xw;
export fn{Rs} ar(v: gvec4i) = v.wx;
export fn{Rs} gb(v: gvec4i) = v.yz;
export fn{Rs} bg(v: gvec4i) = v.zy;
export fn{Rs} ga(v: gvec4i) = v.yw;
export fn{Rs} ag(v: gvec4i) = v.wy;
export fn{Rs} ba(v: gvec4i) = v.zw;
export fn{Rs} ab(v: gvec4i) = v.wz;

fn{Rs} gvec43i(v: gvec4i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3i(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn{Rs} xyz(v: gvec4i) = gvec43i(v, '.xyz'); // 123
export fn{Rs} xyw(v: gvec4i) = gvec43i(v, '.xyw'); // 124
export fn{Rs} xzy(v: gvec4i) = gvec43i(v, '.xzy'); // 132
export fn{Rs} xzw(v: gvec4i) = gvec43i(v, '.xzw'); // 134
export fn{Rs} xwy(v: gvec4i) = gvec43i(v, '.xwy'); // 142
export fn{Rs} xwz(v: gvec4i) = gvec43i(v, '.xwz'); // 143
export fn{Rs} yxz(v: gvec4i) = gvec43i(v, '.yxz'); // 213
export fn{Rs} yxw(v: gvec4i) = gvec43i(v, '.yxw'); // 214
export fn{Rs} yzx(v: gvec4i) = gvec43i(v, '.yzx'); // 231
export fn{Rs} yzw(v: gvec4i) = gvec43i(v, '.yzw'); // 234
export fn{Rs} ywx(v: gvec4i) = gvec43i(v, '.ywx'); // 241
export fn{Rs} ywz(v: gvec4i) = gvec43i(v, '.ywz'); // 243
export fn{Rs} zxy(v: gvec4i) = gvec43i(v, '.zxy'); // 312
export fn{Rs} zxw(v: gvec4i) = gvec43i(v, '.zxw'); // 314
export fn{Rs} zyx(v: gvec4i) = gvec43i(v, '.zyx'); // 321
export fn{Rs} zyw(v: gvec4i) = gvec43i(v, '.zyw'); // 324
export fn{Rs} zwx(v: gvec4i) = gvec43i(v, '.zwx'); // 341
export fn{Rs} zwy(v: gvec4i) = gvec43i(v, '.zwy'); // 342
export fn{Rs} wxy(v: gvec4i) = gvec43i(v, '.wxy'); // 412
export fn{Rs} wxz(v: gvec4i) = gvec43i(v, '.wxz'); // 413
export fn{Rs} wyx(v: gvec4i) = gvec43i(v, '.wyx'); // 421
export fn{Rs} wyz(v: gvec4i) = gvec43i(v, '.wyz'); // 423
export fn{Rs} wzx(v: gvec4i) = gvec43i(v, '.wzx'); // 431
export fn{Rs} wzy(v: gvec4i) = gvec43i(v, '.wzy'); // 432
export fn{Rs} ijk(v: gvec4i) = v.xyz;
export fn{Rs} ijl(v: gvec4i) = v.xyw;
export fn{Rs} ikj(v: gvec4i) = v.xzy;
export fn{Rs} ikl(v: gvec4i) = v.xzw;
export fn{Rs} ilj(v: gvec4i) = v.xwy;
export fn{Rs} ilk(v: gvec4i) = v.xwz;
export fn{Rs} jik(v: gvec4i) = v.yxz;
export fn{Rs} jil(v: gvec4i) = v.yxw;
export fn{Rs} jki(v: gvec4i) = v.yzx;
export fn{Rs} jkl(v: gvec4i) = v.yzw;
export fn{Rs} jli(v: gvec4i) = v.ywx;
export fn{Rs} jlk(v: gvec4i) = v.ywz;
export fn{Rs} kij(v: gvec4i) = v.zxy;
export fn{Rs} kil(v: gvec4i) = v.zxw;
export fn{Rs} kji(v: gvec4i) = v.zyx;
export fn{Rs} kjl(v: gvec4i) = v.zyw;
export fn{Rs} kli(v: gvec4i) = v.zwx;
export fn{Rs} klj(v: gvec4i) = v.zwy;
export fn{Rs} lij(v: gvec4i) = v.wxy;
export fn{Rs} lik(v: gvec4i) = v.wxz;
export fn{Rs} lji(v: gvec4i) = v.wyx;
export fn{Rs} ljk(v: gvec4i) = v.wyz;
export fn{Rs} lki(v: gvec4i) = v.wzx;
export fn{Rs} lkj(v: gvec4i) = v.wzy;
export fn{Rs} rgb(v: gvec4i) = v.xyz;
export fn{Rs} rga(v: gvec4i) = v.xyw;
export fn{Rs} rbg(v: gvec4i) = v.xzy;
export fn{Rs} rba(v: gvec4i) = v.xzw;
export fn{Rs} rag(v: gvec4i) = v.xwy;
export fn{Rs} rab(v: gvec4i) = v.xwz;
export fn{Rs} grb(v: gvec4i) = v.yxz;
export fn{Rs} gra(v: gvec4i) = v.yxw;
export fn{Rs} gbr(v: gvec4i) = v.yzx;
export fn{Rs} gba(v: gvec4i) = v.yzw;
export fn{Rs} gar(v: gvec4i) = v.ywx;
export fn{Rs} gab(v: gvec4i) = v.ywz;
export fn{Rs} brg(v: gvec4i) = v.zxy;
export fn{Rs} bra(v: gvec4i) = v.zxw;
export fn{Rs} bgr(v: gvec4i) = v.zyx;
export fn{Rs} bga(v: gvec4i) = v.zyw;
export fn{Rs} bar(v: gvec4i) = v.zwx;
export fn{Rs} bag(v: gvec4i) = v.zwy;
export fn{Rs} arb(v: gvec4i) = v.wxy;
export fn{Rs} arg(v: gvec4i) = v.wxz;
export fn{Rs} abr(v: gvec4i) = v.wyx;
export fn{Rs} abg(v: gvec4i) = v.wyz;
export fn{Rs} agr(v: gvec4i) = v.wzx;
export fn{Rs} agb(v: gvec4i) = v.wzy;

fn{Rs} gvec44i(v: gvec4i, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4i(varName, v.statements, v.buffers);
}
export fn{Rs} xyzw(v: gvec4i) = gvec44i(v, '.xyzw'); // 1234
export fn{Rs} xywz(v: gvec4i) = gvec44i(v, '.xywz'); // 1243
export fn{Rs} xzyw(v: gvec4i) = gvec44i(v, '.xzyw'); // 1324
export fn{Rs} xzwy(v: gvec4i) = gvec44i(v, '.xzwy'); // 1342
export fn{Rs} xwyz(v: gvec4i) = gvec44i(v, '.xwyz'); // 1423
export fn{Rs} xwzy(v: gvec4i) = gvec44i(v, '.xwzy'); // 1432
export fn{Rs} yxzw(v: gvec4i) = gvec44i(v, '.yxzw'); // 2134
export fn{Rs} yxwz(v: gvec4i) = gvec44i(v, '.yxwz'); // 2143
export fn{Rs} yzxw(v: gvec4i) = gvec44i(v, '.yzxw'); // 2314
export fn{Rs} yzwx(v: gvec4i) = gvec44i(v, '.yzwx'); // 2341
export fn{Rs} ywxz(v: gvec4i) = gvec44i(v, '.ywxz'); // 2413
export fn{Rs} ywzx(v: gvec4i) = gvec44i(v, '.ywzx'); // 2431
export fn{Rs} zxyw(v: gvec4i) = gvec44i(v, '.zxyw'); // 3124
export fn{Rs} zxwy(v: gvec4i) = gvec44i(v, '.zxwy'); // 3142
export fn{Rs} zyxw(v: gvec4i) = gvec44i(v, '.zyxw'); // 3214
export fn{Rs} zywx(v: gvec4i) = gvec44i(v, '.zywx'); // 3241
export fn{Rs} zwxy(v: gvec4i) = gvec44i(v, '.zwxy'); // 3412
export fn{Rs} zwyx(v: gvec4i) = gvec44i(v, '.zwyx'); // 3421
export fn{Rs} wxyz(v: gvec4i) = gvec44i(v, '.wxyz'); // 4123
export fn{Rs} wxzy(v: gvec4i) = gvec44i(v, '.wxzy'); // 4132
export fn{Rs} wyxz(v: gvec4i) = gvec44i(v, '.wyxz'); // 4213
export fn{Rs} wyzx(v: gvec4i) = gvec44i(v, '.wyzx'); // 4231
export fn{Rs} wzxy(v: gvec4i) = gvec44i(v, '.wzxy'); // 4312
export fn{Rs} wzyx(v: gvec4i) = gvec44i(v, '.wzyx'); // 4321
export fn{Rs} ijkl(v: gvec4i) = v.xyzw;
export fn{Rs} ijlk(v: gvec4i) = v.xywz;
export fn{Rs} ikjl(v: gvec4i) = v.xzyw;
export fn{Rs} iklj(v: gvec4i) = v.xzwy;
export fn{Rs} iljk(v: gvec4i) = v.xwyz;
export fn{Rs} ilkj(v: gvec4i) = v.xwzy;
export fn{Rs} jikl(v: gvec4i) = v.yxzw;
export fn{Rs} jilk(v: gvec4i) = v.yxwz;
export fn{Rs} jkil(v: gvec4i) = v.yzxw;
export fn{Rs} jkli(v: gvec4i) = v.yzwx;
export fn{Rs} jlik(v: gvec4i) = v.ywxz;
export fn{Rs} jlki(v: gvec4i) = v.ywzx;
export fn{Rs} kijl(v: gvec4i) = v.zxyw;
export fn{Rs} kilj(v: gvec4i) = v.zxwy;
export fn{Rs} kjil(v: gvec4i) = v.zyxw;
export fn{Rs} kjli(v: gvec4i) = v.zywx;
export fn{Rs} klij(v: gvec4i) = v.zwxy;
export fn{Rs} klji(v: gvec4i) = v.zwyx;
export fn{Rs} lijk(v: gvec4i) = v.wxyz;
export fn{Rs} likj(v: gvec4i) = v.wxzy;
export fn{Rs} ljik(v: gvec4i) = v.wyxz;
export fn{Rs} ljki(v: gvec4i) = v.wyzx;
export fn{Rs} lkij(v: gvec4i) = v.wzxy;
export fn{Rs} lkji(v: gvec4i) = v.wzyx;
export fn{Rs} rgba(v: gvec4i) = v.xyzw;
export fn{Rs} rgab(v: gvec4i) = v.xywz;
export fn{Rs} rbga(v: gvec4i) = v.xzyw;
export fn{Rs} rbag(v: gvec4i) = v.xzwy;
export fn{Rs} ragb(v: gvec4i) = v.xwyz;
export fn{Rs} rabg(v: gvec4i) = v.xwzy;
export fn{Rs} grba(v: gvec4i) = v.yxzw;
export fn{Rs} grab(v: gvec4i) = v.yxwz;
export fn{Rs} gbra(v: gvec4i) = v.yzxw;
export fn{Rs} gbar(v: gvec4i) = v.yzwx;
export fn{Rs} garb(v: gvec4i) = v.ywxz;
export fn{Rs} gabr(v: gvec4i) = v.ywzx;
export fn{Rs} argb(v: gvec4i) = v.wxyz;
export fn{Rs} arbg(v: gvec4i) = v.wxzy;
export fn{Rs} agrb(v: gvec4i) = v.wyxz;
export fn{Rs} agbr(v: gvec4i) = v.wyzx;
export fn{Rs} abrg(v: gvec4i) = v.wzxy;
export fn{Rs} abgr(v: gvec4i) = v.wzyx;

export fn{Rs} x(v: gvec4f) {
  let varName = v.varName.concat('.x');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec4f) {
  let varName = v.varName.concat('.y');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec4f) {
  let varName = v.varName.concat('.z');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} w(v: gvec4f) {
  let varName = v.varName.concat('.w');
  return gf32(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec4f) = v.x;
export fn{Rs} j(v: gvec4f) = v.y;
export fn{Rs} k(v: gvec4f) = v.z;
export fn{Rs} l(v: gvec4f) = v.w;
export fn{Rs} r(v: gvec4f) = v.x;
export fn{Rs} g(v: gvec4f) = v.y;
export fn{Rs} b(v: gvec4f) = v.z;
export fn{Rs} a(v: gvec4f) = v.w;

fn{Rs} gvec42f(v: gvec4f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2f(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec4f) = gvec42f(v, '.xy');
export fn{Rs} yx(v: gvec4f) = gvec42f(v, '.yx');
export fn{Rs} xz(v: gvec4f) = gvec42f(v, '.xz');
export fn{Rs} zx(v: gvec4f) = gvec42f(v, '.zx');
export fn{Rs} xw(v: gvec4f) = gvec42f(v, '.xw');
export fn{Rs} wx(v: gvec4f) = gvec42f(v, '.wx');
export fn{Rs} yz(v: gvec4f) = gvec42f(v, '.yz');
export fn{Rs} zy(v: gvec4f) = gvec42f(v, '.zy');
export fn{Rs} yw(v: gvec4f) = gvec42f(v, '.yw');
export fn{Rs} wy(v: gvec4f) = gvec42f(v, '.wy');
export fn{Rs} zw(v: gvec4f) = gvec42f(v, '.zw');
export fn{Rs} wz(v: gvec4f) = gvec42f(v, '.wz');
export fn{Rs} ij(v: gvec4f) = v.xy;
export fn{Rs} ji(v: gvec4f) = v.yx;
export fn{Rs} ik(v: gvec4f) = v.xz;
export fn{Rs} ki(v: gvec4f) = v.zx;
export fn{Rs} il(v: gvec4f) = v.xw;
export fn{Rs} li(v: gvec4f) = v.wx;
export fn{Rs} jk(v: gvec4f) = v.yz;
export fn{Rs} kj(v: gvec4f) = v.zy;
export fn{Rs} jl(v: gvec4f) = v.yw;
export fn{Rs} lj(v: gvec4f) = v.wy;
export fn{Rs} kl(v: gvec4f) = v.zw;
export fn{Rs} lk(v: gvec4f) = v.wz;
export fn{Rs} rg(v: gvec4f) = v.xy;
export fn{Rs} gr(v: gvec4f) = v.yx;
export fn{Rs} rb(v: gvec4f) = v.xz;
export fn{Rs} br(v: gvec4f) = v.zx;
export fn{Rs} ra(v: gvec4f) = v.xw;
export fn{Rs} ar(v: gvec4f) = v.wx;
export fn{Rs} gb(v: gvec4f) = v.yz;
export fn{Rs} bg(v: gvec4f) = v.zy;
export fn{Rs} ga(v: gvec4f) = v.yw;
export fn{Rs} ag(v: gvec4f) = v.wy;
export fn{Rs} ba(v: gvec4f) = v.zw;
export fn{Rs} ab(v: gvec4f) = v.wz;

fn{Rs} gvec43f(v: gvec4f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3f(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn{Rs} xyz(v: gvec4f) = gvec43f(v, '.xyz'); // 123
export fn{Rs} xyw(v: gvec4f) = gvec43f(v, '.xyw'); // 124
export fn{Rs} xzy(v: gvec4f) = gvec43f(v, '.xzy'); // 132
export fn{Rs} xzw(v: gvec4f) = gvec43f(v, '.xzw'); // 134
export fn{Rs} xwy(v: gvec4f) = gvec43f(v, '.xwy'); // 142
export fn{Rs} xwz(v: gvec4f) = gvec43f(v, '.xwz'); // 143
export fn{Rs} yxz(v: gvec4f) = gvec43f(v, '.yxz'); // 213
export fn{Rs} yxw(v: gvec4f) = gvec43f(v, '.yxw'); // 214
export fn{Rs} yzx(v: gvec4f) = gvec43f(v, '.yzx'); // 231
export fn{Rs} yzw(v: gvec4f) = gvec43f(v, '.yzw'); // 234
export fn{Rs} ywx(v: gvec4f) = gvec43f(v, '.ywx'); // 241
export fn{Rs} ywz(v: gvec4f) = gvec43f(v, '.ywz'); // 243
export fn{Rs} zxy(v: gvec4f) = gvec43f(v, '.zxy'); // 312
export fn{Rs} zxw(v: gvec4f) = gvec43f(v, '.zxw'); // 314
export fn{Rs} zyx(v: gvec4f) = gvec43f(v, '.zyx'); // 321
export fn{Rs} zyw(v: gvec4f) = gvec43f(v, '.zyw'); // 324
export fn{Rs} zwx(v: gvec4f) = gvec43f(v, '.zwx'); // 341
export fn{Rs} zwy(v: gvec4f) = gvec43f(v, '.zwy'); // 342
export fn{Rs} wxy(v: gvec4f) = gvec43f(v, '.wxy'); // 412
export fn{Rs} wxz(v: gvec4f) = gvec43f(v, '.wxz'); // 413
export fn{Rs} wyx(v: gvec4f) = gvec43f(v, '.wyx'); // 421
export fn{Rs} wyz(v: gvec4f) = gvec43f(v, '.wyz'); // 423
export fn{Rs} wzx(v: gvec4f) = gvec43f(v, '.wzx'); // 431
export fn{Rs} wzy(v: gvec4f) = gvec43f(v, '.wzy'); // 432
export fn{Rs} ijk(v: gvec4f) = v.xyz;
export fn{Rs} ijl(v: gvec4f) = v.xyw;
export fn{Rs} ikj(v: gvec4f) = v.xzy;
export fn{Rs} ikl(v: gvec4f) = v.xzw;
export fn{Rs} ilj(v: gvec4f) = v.xwy;
export fn{Rs} ilk(v: gvec4f) = v.xwz;
export fn{Rs} jik(v: gvec4f) = v.yxz;
export fn{Rs} jil(v: gvec4f) = v.yxw;
export fn{Rs} jki(v: gvec4f) = v.yzx;
export fn{Rs} jkl(v: gvec4f) = v.yzw;
export fn{Rs} jli(v: gvec4f) = v.ywx;
export fn{Rs} jlk(v: gvec4f) = v.ywz;
export fn{Rs} kij(v: gvec4f) = v.zxy;
export fn{Rs} kil(v: gvec4f) = v.zxw;
export fn{Rs} kji(v: gvec4f) = v.zyx;
export fn{Rs} kjl(v: gvec4f) = v.zyw;
export fn{Rs} kli(v: gvec4f) = v.zwx;
export fn{Rs} klj(v: gvec4f) = v.zwy;
export fn{Rs} lij(v: gvec4f) = v.wxy;
export fn{Rs} lik(v: gvec4f) = v.wxz;
export fn{Rs} lji(v: gvec4f) = v.wyx;
export fn{Rs} ljk(v: gvec4f) = v.wyz;
export fn{Rs} lki(v: gvec4f) = v.wzx;
export fn{Rs} lkj(v: gvec4f) = v.wzy;
export fn{Rs} rgb(v: gvec4f) = v.xyz;
export fn{Rs} rga(v: gvec4f) = v.xyw;
export fn{Rs} rbg(v: gvec4f) = v.xzy;
export fn{Rs} rba(v: gvec4f) = v.xzw;
export fn{Rs} rag(v: gvec4f) = v.xwy;
export fn{Rs} rab(v: gvec4f) = v.xwz;
export fn{Rs} grb(v: gvec4f) = v.yxz;
export fn{Rs} gra(v: gvec4f) = v.yxw;
export fn{Rs} gbr(v: gvec4f) = v.yzx;
export fn{Rs} gba(v: gvec4f) = v.yzw;
export fn{Rs} gar(v: gvec4f) = v.ywx;
export fn{Rs} gab(v: gvec4f) = v.ywz;
export fn{Rs} brg(v: gvec4f) = v.zxy;
export fn{Rs} bra(v: gvec4f) = v.zxw;
export fn{Rs} bgr(v: gvec4f) = v.zyx;
export fn{Rs} bga(v: gvec4f) = v.zyw;
export fn{Rs} bar(v: gvec4f) = v.zwx;
export fn{Rs} bag(v: gvec4f) = v.zwy;
export fn{Rs} arb(v: gvec4f) = v.wxy;
export fn{Rs} arg(v: gvec4f) = v.wxz;
export fn{Rs} abr(v: gvec4f) = v.wyx;
export fn{Rs} abg(v: gvec4f) = v.wyz;
export fn{Rs} agr(v: gvec4f) = v.wzx;
export fn{Rs} agb(v: gvec4f) = v.wzy;

fn{Rs} gvec44f(v: gvec4f, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4f(varName, v.statements, v.buffers);
}
export fn{Rs} xyzw(v: gvec4f) = gvec44f(v, '.xyzw'); // 1234
export fn{Rs} xywz(v: gvec4f) = gvec44f(v, '.xywz'); // 1243
export fn{Rs} xzyw(v: gvec4f) = gvec44f(v, '.xzyw'); // 1324
export fn{Rs} xzwy(v: gvec4f) = gvec44f(v, '.xzwy'); // 1342
export fn{Rs} xwyz(v: gvec4f) = gvec44f(v, '.xwyz'); // 1423
export fn{Rs} xwzy(v: gvec4f) = gvec44f(v, '.xwzy'); // 1432
export fn{Rs} yxzw(v: gvec4f) = gvec44f(v, '.yxzw'); // 2134
export fn{Rs} yxwz(v: gvec4f) = gvec44f(v, '.yxwz'); // 2143
export fn{Rs} yzxw(v: gvec4f) = gvec44f(v, '.yzxw'); // 2314
export fn{Rs} yzwx(v: gvec4f) = gvec44f(v, '.yzwx'); // 2341
export fn{Rs} ywxz(v: gvec4f) = gvec44f(v, '.ywxz'); // 2413
export fn{Rs} ywzx(v: gvec4f) = gvec44f(v, '.ywzx'); // 2431
export fn{Rs} zxyw(v: gvec4f) = gvec44f(v, '.zxyw'); // 3124
export fn{Rs} zxwy(v: gvec4f) = gvec44f(v, '.zxwy'); // 3142
export fn{Rs} zyxw(v: gvec4f) = gvec44f(v, '.zyxw'); // 3214
export fn{Rs} zywx(v: gvec4f) = gvec44f(v, '.zywx'); // 3241
export fn{Rs} zwxy(v: gvec4f) = gvec44f(v, '.zwxy'); // 3412
export fn{Rs} zwyx(v: gvec4f) = gvec44f(v, '.zwyx'); // 3421
export fn{Rs} wxyz(v: gvec4f) = gvec44f(v, '.wxyz'); // 4123
export fn{Rs} wxzy(v: gvec4f) = gvec44f(v, '.wxzy'); // 4132
export fn{Rs} wyxz(v: gvec4f) = gvec44f(v, '.wyxz'); // 4213
export fn{Rs} wyzx(v: gvec4f) = gvec44f(v, '.wyzx'); // 4231
export fn{Rs} wzxy(v: gvec4f) = gvec44f(v, '.wzxy'); // 4312
export fn{Rs} wzyx(v: gvec4f) = gvec44f(v, '.wzyx'); // 4321
export fn{Rs} ijkl(v: gvec4f) = v.xyzw;
export fn{Rs} ijlk(v: gvec4f) = v.xywz;
export fn{Rs} ikjl(v: gvec4f) = v.xzyw;
export fn{Rs} iklj(v: gvec4f) = v.xzwy;
export fn{Rs} iljk(v: gvec4f) = v.xwyz;
export fn{Rs} ilkj(v: gvec4f) = v.xwzy;
export fn{Rs} jikl(v: gvec4f) = v.yxzw;
export fn{Rs} jilk(v: gvec4f) = v.yxwz;
export fn{Rs} jkil(v: gvec4f) = v.yzxw;
export fn{Rs} jkli(v: gvec4f) = v.yzwx;
export fn{Rs} jlik(v: gvec4f) = v.ywxz;
export fn{Rs} jlki(v: gvec4f) = v.ywzx;
export fn{Rs} kijl(v: gvec4f) = v.zxyw;
export fn{Rs} kilj(v: gvec4f) = v.zxwy;
export fn{Rs} kjil(v: gvec4f) = v.zyxw;
export fn{Rs} kjli(v: gvec4f) = v.zywx;
export fn{Rs} klij(v: gvec4f) = v.zwxy;
export fn{Rs} klji(v: gvec4f) = v.zwyx;
export fn{Rs} lijk(v: gvec4f) = v.wxyz;
export fn{Rs} likj(v: gvec4f) = v.wxzy;
export fn{Rs} ljik(v: gvec4f) = v.wyxz;
export fn{Rs} ljki(v: gvec4f) = v.wyzx;
export fn{Rs} lkij(v: gvec4f) = v.wzxy;
export fn{Rs} lkji(v: gvec4f) = v.wzyx;
export fn{Rs} rgba(v: gvec4f) = v.xyzw;
export fn{Rs} rgab(v: gvec4f) = v.xywz;
export fn{Rs} rbga(v: gvec4f) = v.xzyw;
export fn{Rs} rbag(v: gvec4f) = v.xzwy;
export fn{Rs} ragb(v: gvec4f) = v.xwyz;
export fn{Rs} rabg(v: gvec4f) = v.xwzy;
export fn{Rs} grba(v: gvec4f) = v.yxzw;
export fn{Rs} grab(v: gvec4f) = v.yxwz;
export fn{Rs} gbra(v: gvec4f) = v.yzxw;
export fn{Rs} gbar(v: gvec4f) = v.yzwx;
export fn{Rs} garb(v: gvec4f) = v.ywxz;
export fn{Rs} gabr(v: gvec4f) = v.ywzx;
export fn{Rs} argb(v: gvec4f) = v.wxyz;
export fn{Rs} arbg(v: gvec4f) = v.wxzy;
export fn{Rs} agrb(v: gvec4f) = v.wyxz;
export fn{Rs} agbr(v: gvec4f) = v.wyzx;
export fn{Rs} abrg(v: gvec4f) = v.wzxy;
export fn{Rs} abgr(v: gvec4f) = v.wzyx;

export fn{Rs} x(v: gvec4b) {
  let varName = v.varName.concat('.x');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} y(v: gvec4b) {
  let varName = v.varName.concat('.y');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} z(v: gvec4b) {
  let varName = v.varName.concat('.z');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} w(v: gvec4b) {
  let varName = v.varName.concat('.w');
  return gbool(varName, v.statements, v.buffers);
}
export fn{Rs} i(v: gvec4b) = v.x;
export fn{Rs} j(v: gvec4b) = v.y;
export fn{Rs} k(v: gvec4b) = v.z;
export fn{Rs} l(v: gvec4b) = v.w;
export fn{Rs} r(v: gvec4b) = v.x;
export fn{Rs} g(v: gvec4b) = v.y;
export fn{Rs} b(v: gvec4b) = v.z;
export fn{Rs} a(v: gvec4b) = v.w;

fn{Rs} gvec42b(v: gvec4b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec2b(varName, v.statements, v.buffers);
}
export fn{Rs} xy(v: gvec4b) = gvec42b(v, '.xy');
export fn{Rs} yx(v: gvec4b) = gvec42b(v, '.yx');
export fn{Rs} xz(v: gvec4b) = gvec42b(v, '.xz');
export fn{Rs} zx(v: gvec4b) = gvec42b(v, '.zx');
export fn{Rs} xw(v: gvec4b) = gvec42b(v, '.xw');
export fn{Rs} wx(v: gvec4b) = gvec42b(v, '.wx');
export fn{Rs} yz(v: gvec4b) = gvec42b(v, '.yz');
export fn{Rs} zy(v: gvec4b) = gvec42b(v, '.zy');
export fn{Rs} yw(v: gvec4b) = gvec42b(v, '.yw');
export fn{Rs} wy(v: gvec4b) = gvec42b(v, '.wy');
export fn{Rs} zw(v: gvec4b) = gvec42b(v, '.zw');
export fn{Rs} wz(v: gvec4b) = gvec42b(v, '.wz');
export fn{Rs} ij(v: gvec4b) = v.xy;
export fn{Rs} ji(v: gvec4b) = v.yx;
export fn{Rs} ik(v: gvec4b) = v.xz;
export fn{Rs} ki(v: gvec4b) = v.zx;
export fn{Rs} il(v: gvec4b) = v.xw;
export fn{Rs} li(v: gvec4b) = v.wx;
export fn{Rs} jk(v: gvec4b) = v.yz;
export fn{Rs} kj(v: gvec4b) = v.zy;
export fn{Rs} jl(v: gvec4b) = v.yw;
export fn{Rs} lj(v: gvec4b) = v.wy;
export fn{Rs} kl(v: gvec4b) = v.zw;
export fn{Rs} lk(v: gvec4b) = v.wz;
export fn{Rs} rg(v: gvec4b) = v.xy;
export fn{Rs} gr(v: gvec4b) = v.yx;
export fn{Rs} rb(v: gvec4b) = v.xz;
export fn{Rs} br(v: gvec4b) = v.zx;
export fn{Rs} ra(v: gvec4b) = v.xw;
export fn{Rs} ar(v: gvec4b) = v.wx;
export fn{Rs} gb(v: gvec4b) = v.yz;
export fn{Rs} bg(v: gvec4b) = v.zy;
export fn{Rs} ga(v: gvec4b) = v.yw;
export fn{Rs} ag(v: gvec4b) = v.wy;
export fn{Rs} ba(v: gvec4b) = v.zw;
export fn{Rs} ab(v: gvec4b) = v.wz;

fn{Rs} gvec43b(v: gvec4b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec3b(varName, v.statements, v.buffers);
}
// 1 = x, i, r; 2 = y, j, g; 3 = z, k, b; 4 = w, l, a
export fn{Rs} xyz(v: gvec4b) = gvec43b(v, '.xyz'); // 123
export fn{Rs} xyw(v: gvec4b) = gvec43b(v, '.xyw'); // 124
export fn{Rs} xzy(v: gvec4b) = gvec43b(v, '.xzy'); // 132
export fn{Rs} xzw(v: gvec4b) = gvec43b(v, '.xzw'); // 134
export fn{Rs} xwy(v: gvec4b) = gvec43b(v, '.xwy'); // 142
export fn{Rs} xwz(v: gvec4b) = gvec43b(v, '.xwz'); // 143
export fn{Rs} yxz(v: gvec4b) = gvec43b(v, '.yxz'); // 213
export fn{Rs} yxw(v: gvec4b) = gvec43b(v, '.yxw'); // 214
export fn{Rs} yzx(v: gvec4b) = gvec43b(v, '.yzx'); // 231
export fn{Rs} yzw(v: gvec4b) = gvec43b(v, '.yzw'); // 234
export fn{Rs} ywx(v: gvec4b) = gvec43b(v, '.ywx'); // 241
export fn{Rs} ywz(v: gvec4b) = gvec43b(v, '.ywz'); // 243
export fn{Rs} zxy(v: gvec4b) = gvec43b(v, '.zxy'); // 312
export fn{Rs} zxw(v: gvec4b) = gvec43b(v, '.zxw'); // 314
export fn{Rs} zyx(v: gvec4b) = gvec43b(v, '.zyx'); // 321
export fn{Rs} zyw(v: gvec4b) = gvec43b(v, '.zyw'); // 324
export fn{Rs} zwx(v: gvec4b) = gvec43b(v, '.zwx'); // 341
export fn{Rs} zwy(v: gvec4b) = gvec43b(v, '.zwy'); // 342
export fn{Rs} wxy(v: gvec4b) = gvec43b(v, '.wxy'); // 412
export fn{Rs} wxz(v: gvec4b) = gvec43b(v, '.wxz'); // 413
export fn{Rs} wyx(v: gvec4b) = gvec43b(v, '.wyx'); // 421
export fn{Rs} wyz(v: gvec4b) = gvec43b(v, '.wyz'); // 423
export fn{Rs} wzx(v: gvec4b) = gvec43b(v, '.wzx'); // 431
export fn{Rs} wzy(v: gvec4b) = gvec43b(v, '.wzy'); // 432
export fn{Rs} ijk(v: gvec4b) = v.xyz;
export fn{Rs} ijl(v: gvec4b) = v.xyw;
export fn{Rs} ikj(v: gvec4b) = v.xzy;
export fn{Rs} ikl(v: gvec4b) = v.xzw;
export fn{Rs} ilj(v: gvec4b) = v.xwy;
export fn{Rs} ilk(v: gvec4b) = v.xwz;
export fn{Rs} jik(v: gvec4b) = v.yxz;
export fn{Rs} jil(v: gvec4b) = v.yxw;
export fn{Rs} jki(v: gvec4b) = v.yzx;
export fn{Rs} jkl(v: gvec4b) = v.yzw;
export fn{Rs} jli(v: gvec4b) = v.ywx;
export fn{Rs} jlk(v: gvec4b) = v.ywz;
export fn{Rs} kij(v: gvec4b) = v.zxy;
export fn{Rs} kil(v: gvec4b) = v.zxw;
export fn{Rs} kji(v: gvec4b) = v.zyx;
export fn{Rs} kjl(v: gvec4b) = v.zyw;
export fn{Rs} kli(v: gvec4b) = v.zwx;
export fn{Rs} klj(v: gvec4b) = v.zwy;
export fn{Rs} lij(v: gvec4b) = v.wxy;
export fn{Rs} lik(v: gvec4b) = v.wxz;
export fn{Rs} lji(v: gvec4b) = v.wyx;
export fn{Rs} ljk(v: gvec4b) = v.wyz;
export fn{Rs} lki(v: gvec4b) = v.wzx;
export fn{Rs} lkj(v: gvec4b) = v.wzy;
export fn{Rs} rgb(v: gvec4b) = v.xyz;
export fn{Rs} rga(v: gvec4b) = v.xyw;
export fn{Rs} rbg(v: gvec4b) = v.xzy;
export fn{Rs} rba(v: gvec4b) = v.xzw;
export fn{Rs} rag(v: gvec4b) = v.xwy;
export fn{Rs} rab(v: gvec4b) = v.xwz;
export fn{Rs} grb(v: gvec4b) = v.yxz;
export fn{Rs} gra(v: gvec4b) = v.yxw;
export fn{Rs} gbr(v: gvec4b) = v.yzx;
export fn{Rs} gba(v: gvec4b) = v.yzw;
export fn{Rs} gar(v: gvec4b) = v.ywx;
export fn{Rs} gab(v: gvec4b) = v.ywz;
export fn{Rs} brg(v: gvec4b) = v.zxy;
export fn{Rs} bra(v: gvec4b) = v.zxw;
export fn{Rs} bgr(v: gvec4b) = v.zyx;
export fn{Rs} bga(v: gvec4b) = v.zyw;
export fn{Rs} bar(v: gvec4b) = v.zwx;
export fn{Rs} bag(v: gvec4b) = v.zwy;
export fn{Rs} arb(v: gvec4b) = v.wxy;
export fn{Rs} arg(v: gvec4b) = v.wxz;
export fn{Rs} abr(v: gvec4b) = v.wyx;
export fn{Rs} abg(v: gvec4b) = v.wyz;
export fn{Rs} agr(v: gvec4b) = v.wzx;
export fn{Rs} agb(v: gvec4b) = v.wzy;

fn{Rs} gvec44b(v: gvec4b, a: string) {
  // TODO: Add some type safety on the kinds of strings you can pass in here
  let varName = v.varName.concat(a);
  return gvec4b(varName, v.statements, v.buffers);
}
export fn{Rs} xyzw(v: gvec4b) = gvec44b(v, '.xyzw'); // 1234
export fn{Rs} xywz(v: gvec4b) = gvec44b(v, '.xywz'); // 1243
export fn{Rs} xzyw(v: gvec4b) = gvec44b(v, '.xzyw'); // 1324
export fn{Rs} xzwy(v: gvec4b) = gvec44b(v, '.xzwy'); // 1342
export fn{Rs} xwyz(v: gvec4b) = gvec44b(v, '.xwyz'); // 1423
export fn{Rs} xwzy(v: gvec4b) = gvec44b(v, '.xwzy'); // 1432
export fn{Rs} yxzw(v: gvec4b) = gvec44b(v, '.yxzw'); // 2134
export fn{Rs} yxwz(v: gvec4b) = gvec44b(v, '.yxwz'); // 2143
export fn{Rs} yzxw(v: gvec4b) = gvec44b(v, '.yzxw'); // 2314
export fn{Rs} yzwx(v: gvec4b) = gvec44b(v, '.yzwx'); // 2341
export fn{Rs} ywxz(v: gvec4b) = gvec44b(v, '.ywxz'); // 2413
export fn{Rs} ywzx(v: gvec4b) = gvec44b(v, '.ywzx'); // 2431
export fn{Rs} zxyw(v: gvec4b) = gvec44b(v, '.zxyw'); // 3124
export fn{Rs} zxwy(v: gvec4b) = gvec44b(v, '.zxwy'); // 3142
export fn{Rs} zyxw(v: gvec4b) = gvec44b(v, '.zyxw'); // 3214
export fn{Rs} zywx(v: gvec4b) = gvec44b(v, '.zywx'); // 3241
export fn{Rs} zwxy(v: gvec4b) = gvec44b(v, '.zwxy'); // 3412
export fn{Rs} zwyx(v: gvec4b) = gvec44b(v, '.zwyx'); // 3421
export fn{Rs} wxyz(v: gvec4b) = gvec44b(v, '.wxyz'); // 4123
export fn{Rs} wxzy(v: gvec4b) = gvec44b(v, '.wxzy'); // 4132
export fn{Rs} wyxz(v: gvec4b) = gvec44b(v, '.wyxz'); // 4213
export fn{Rs} wyzx(v: gvec4b) = gvec44b(v, '.wyzx'); // 4231
export fn{Rs} wzxy(v: gvec4b) = gvec44b(v, '.wzxy'); // 4312
export fn{Rs} wzyx(v: gvec4b) = gvec44b(v, '.wzyx'); // 4321
export fn{Rs} ijkl(v: gvec4b) = v.xyzw;
export fn{Rs} ijlk(v: gvec4b) = v.xywz;
export fn{Rs} ikjl(v: gvec4b) = v.xzyw;
export fn{Rs} iklj(v: gvec4b) = v.xzwy;
export fn{Rs} iljk(v: gvec4b) = v.xwyz;
export fn{Rs} ilkj(v: gvec4b) = v.xwzy;
export fn{Rs} jikl(v: gvec4b) = v.yxzw;
export fn{Rs} jilk(v: gvec4b) = v.yxwz;
export fn{Rs} jkil(v: gvec4b) = v.yzxw;
export fn{Rs} jkli(v: gvec4b) = v.yzwx;
export fn{Rs} jlik(v: gvec4b) = v.ywxz;
export fn{Rs} jlki(v: gvec4b) = v.ywzx;
export fn{Rs} kijl(v: gvec4b) = v.zxyw;
export fn{Rs} kilj(v: gvec4b) = v.zxwy;
export fn{Rs} kjil(v: gvec4b) = v.zyxw;
export fn{Rs} kjli(v: gvec4b) = v.zywx;
export fn{Rs} klij(v: gvec4b) = v.zwxy;
export fn{Rs} klji(v: gvec4b) = v.zwyx;
export fn{Rs} lijk(v: gvec4b) = v.wxyz;
export fn{Rs} likj(v: gvec4b) = v.wxzy;
export fn{Rs} ljik(v: gvec4b) = v.wyxz;
export fn{Rs} ljki(v: gvec4b) = v.wyzx;
export fn{Rs} lkij(v: gvec4b) = v.wzxy;
export fn{Rs} lkji(v: gvec4b) = v.wzyx;
export fn{Rs} rgba(v: gvec4b) = v.xyzw;
export fn{Rs} rgab(v: gvec4b) = v.xywz;
export fn{Rs} rbga(v: gvec4b) = v.xzyw;
export fn{Rs} rbag(v: gvec4b) = v.xzwy;
export fn{Rs} ragb(v: gvec4b) = v.xwyz;
export fn{Rs} rabg(v: gvec4b) = v.xwzy;
export fn{Rs} grba(v: gvec4b) = v.yxzw;
export fn{Rs} grab(v: gvec4b) = v.yxwz;
export fn{Rs} gbra(v: gvec4b) = v.yzxw;
export fn{Rs} gbar(v: gvec4b) = v.yzwx;
export fn{Rs} garb(v: gvec4b) = v.ywxz;
export fn{Rs} gabr(v: gvec4b) = v.ywzx;
export fn{Rs} brga(v: gvec4b) = v.zxyw;
export fn{Rs} brag(v: gvec4b) = v.zxwy;
export fn{Rs} bgra(v: gvec4b) = v.zyxw;
export fn{Rs} bgar(v: gvec4b) = v.zywx;
export fn{Rs} barg(v: gvec4b) = v.zwxy;
export fn{Rs} bagr(v: gvec4b) = v.zwyx;
export fn{Rs} argb(v: gvec4b) = v.wxyz;
export fn{Rs} arbg(v: gvec4b) = v.wxzy;
export fn{Rs} agrb(v: gvec4b) = v.wyxz;
export fn{Rs} agbr(v: gvec4b) = v.wyzx;
export fn{Rs} abrg(v: gvec4b) = v.wzxy;
export fn{Rs} abgr(v: gvec4b) = v.wzyx;

// TODO: Improve GBuffer to support other buffer types
export fn{Rs} get(gb: GBuffer, i: gu32) {
  let statement = gb.id.concat('[').concat(i.varName).concat(']');
  let buffers = i.buffers.union(Set(gb));
  return gi32(statement, i.statements, buffers);
}

export fn{Rs} store(a: gi32, b: gi32) {
    let statement = a.varName.concat(" = ").concat(b.varName);
    let statements = a.statements.concat(b.statements).concat(Dict(statement, statement));
    let buffers = a.buffers.union(b.buffers);
    return gi32(statement, statements, buffers);
}

// GPU Math

fn{Rs} gneg{I}(v: I) {
  let varName = '(-'.concat(v.varName).concat(')');
  return {I}(varName, v.statements, v.buffers);
}
export fn{Rs} neg(v: gi32) = gneg{gi32}(v);
export fn{Rs} neg(v: gf32) = gneg{gf32}(v);
export fn{Rs} neg(v: gvec2i) = gneg{gvec2i}(v);
export fn{Rs} neg(v: gvec2f) = gneg{gvec2f}(v);
export fn{Rs} neg(v: gvec3i) = gneg{gvec3i}(v);
export fn{Rs} neg(v: gvec3f) = gneg{gvec3f}(v);
export fn{Rs} neg(v: gvec4i) = gneg{gvec4i}(v);
export fn{Rs} neg(v: gvec4f) = gneg{gvec4f}(v);

fn{Rs} gadd{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' + ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {A}(varName, statements, buffers);
}
export fn{Rs} add(a: gu32, b: gu32) = gadd(a, b);
export fn{Rs} add{T}(a: gu32, b: T) = add(a, b.gu32);
export fn{Rs} add{T}(a: T, b: gu32) = add(a.gu32, b);

export fn{Rs} add(a: gi32, b: gi32) = gadd(a, b);
export fn{Rs} add{T}(a: gi32, b: T) = add(a, b.gi32);
export fn{Rs} add{T}(a: T, b: gi32) = add(a.gi32, b);

export fn{Rs} add(a: gf32, b: gf32) = gadd(a, b);
export fn{Rs} add{T}(a: gf32, b: T) = add(a, b.gf32);
export fn{Rs} add{T}(a: T, b: gf32) = add(a.gf32, b);

export fn{Rs} add(a: gvec2u, b: gvec2u) = gadd(a, b);
export fn{Rs} add(a: gvec2u, b: gu32) = gadd(a, b);
// Because addition is commutative, I can do this
export fn{Rs} add(a: gu32, b: gvec2u) = gadd(b, a);

export fn{Rs} add(a: gvec2i, b: gvec2i) = gadd(a, b);
export fn{Rs} add(a: gvec2i, b: gi32) = gadd(a, b);
export fn{Rs} add(a: gi32, b: gvec2i) = gadd(b, a);

export fn{Rs} add(a: gvec2f, b: gvec2f) = gadd(a, b);
export fn{Rs} add(a: gvec2f, b: gf32) = gadd(a, b);
export fn{Rs} add(a: gf32, b: gvec2f) = gadd(b, a);

export fn{Rs} add(a: gvec3u, b: gvec3u) = gadd(a, b);
export fn{Rs} add(a: gvec3u, b: gu32) = gadd(a, b);
export fn{Rs} add(a: gu32, b: gvec3u) = gadd(b, a);

export fn{Rs} add(a: gvec3i, b: gvec3i) = gadd(a, b);
export fn{Rs} add(a: gvec3i, b: gi32) = gadd(a, b);
export fn{Rs} add(a: gi32, b: gvec3i) = gadd(b, a);

export fn{Rs} add(a: gvec3f, b: gvec3f) = gadd(a, b);
export fn{Rs} add(a: gvec3f, b: gf32) = gadd(a, b);
export fn{Rs} add(a: gf32, b: gvec3f) = gadd(b, a);

export fn{Rs} add(a: gvec4u, b: gvec4u) = gadd(a, b);
export fn{Rs} add(a: gvec4u, b: gu32) = gadd(a, b);
export fn{Rs} add(a: gu32, b: gvec4u) = gadd(b, a);

export fn{Rs} add(a: gvec4i, b: gvec4i) = gadd(a, b);
export fn{Rs} add(a: gvec4i, b: gi32) = gadd(a, b);
export fn{Rs} add(a: gi32, b: gvec4i) = gadd(b, a);

export fn{Rs} add(a: gvec4f, b: gvec4f) = gadd(a, b);
export fn{Rs} add(a: gvec4f, b: gf32) = gadd(a, b);
export fn{Rs} add(a: gf32, b: gvec4f) = gadd(b, a);

export fn{Rs} add(a: gmat2x2f, b: gmat2x2f) = gadd(a, b);
export fn{Rs} add(a: gmat2x3f, b: gmat2x3f) = gadd(a, b);
export fn{Rs} add(a: gmat2x4f, b: gmat2x4f) = gadd(a, b);
export fn{Rs} add(a: gmat3x2f, b: gmat3x2f) = gadd(a, b);
export fn{Rs} add(a: gmat3x3f, b: gmat3x3f) = gadd(a, b);
export fn{Rs} add(a: gmat3x4f, b: gmat3x4f) = gadd(a, b);
export fn{Rs} add(a: gmat4x2f, b: gmat4x2f) = gadd(a, b);
export fn{Rs} add(a: gmat4x3f, b: gmat4x3f) = gadd(a, b);
export fn{Rs} add(a: gmat4x4f, b: gmat4x4f) = gadd(a, b);

fn{Rs} gsub{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {A}(varName, statements, buffers);
}
fn{Rs} gsubRev{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' - ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {B}(varName, statements, buffers);
}
export fn{Rs} sub(a: gu32, b: gu32) = gsub(a, b);
export fn{Rs} sub{T}(a: gu32, b: T) = sub(a, b.gu32);
export fn{Rs} sub{T}(a: T, b: gu32) = sub(a.gu32, b);

export fn{Rs} sub(a: gi32, b: gi32) = gsub(a, b);
export fn{Rs} sub{T}(a: gi32, b: T) = sub(a, b.gi32);
export fn{Rs} sub{T}(a: T, b: gi32) = sub(a.gi32, b);

export fn{Rs} sub(a: gf32, b: gf32) = gsub(a, b);
export fn{Rs} sub{T}(a: gf32, b: T) = sub(a, b.gf32);
export fn{Rs} sub{T}(a: T, b: gf32) = sub(a.gf32, b);

export fn{Rs} sub(a: gvec2u, b: gvec2u) = gsub(a, b);
export fn{Rs} sub(a: gvec2u, b: gu32) = gsub(a, b);
export fn{Rs} sub(a: gu32, b: gvec2u) = gsubRev(a, b);

export fn{Rs} sub(a: gvec2i, b: gvec2i) = gsub(a, b);
export fn{Rs} sub(a: gvec2i, b: gi32) = gsub(a, b);
export fn{Rs} sub(a: gi32, b: gvec2i) = gsubRev(a, b);

export fn{Rs} sub(a: gvec2f, b: gvec2f) = gsub(a, b);
export fn{Rs} sub(a: gvec2f, b: gf32) = gsub(a, b);
export fn{Rs} sub(a: gf32, b: gvec2f) = gsubRev(a, b);

export fn{Rs} sub(a: gvec3u, b: gvec3u) = gsub(a, b);
export fn{Rs} sub(a: gvec3u, b: gu32) = gsub(a, b);
export fn{Rs} sub(a: gu32, b: gvec3u) = gsubRev(a, b);

export fn{Rs} sub(a: gvec3i, b: gvec3i) = gsub(a, b);
export fn{Rs} sub(a: gvec3i, b: gi32) = gsub(a, b);
export fn{Rs} sub(a: gi32, b: gvec3i) = gsubRev(a, b);

export fn{Rs} sub(a: gvec3f, b: gvec3f) = gsub(a, b);
export fn{Rs} sub(a: gvec3f, b: gf32) = gsub(a, b);
export fn{Rs} sub(a: gf32, b: gvec3f) = gsubRev(a, b);

export fn{Rs} sub(a: gvec4u, b: gvec4u) = gsub(a, b);
export fn{Rs} sub(a: gvec4u, b: gu32) = gsub(a, b);
export fn{Rs} sub(a: gu32, b: gvec4u) = gsubRev(a, b);

export fn{Rs} sub(a: gvec4i, b: gvec4i) = gsub(a, b);
export fn{Rs} sub(a: gvec4i, b: gi32) = gsub(a, b);
export fn{Rs} sub(a: gi32, b: gvec4i) = gsubRev(a, b);

export fn{Rs} sub(a: gvec4f, b: gvec4f) = gsub(a, b);
export fn{Rs} sub(a: gvec4f, b: gf32) = gsub(a, b);
export fn{Rs} sub(a: gf32, b: gvec4f) = gsubRev(a, b);

export fn{Rs} sub(a: gmat2x2f, b: gmat2x2f) = gsub(a, b);
export fn{Rs} sub(a: gmat2x3f, b: gmat2x3f) = gsub(a, b);
export fn{Rs} sub(a: gmat2x4f, b: gmat2x4f) = gsub(a, b);
export fn{Rs} sub(a: gmat3x2f, b: gmat3x2f) = gsub(a, b);
export fn{Rs} sub(a: gmat3x3f, b: gmat3x3f) = gsub(a, b);
export fn{Rs} sub(a: gmat3x4f, b: gmat3x4f) = gsub(a, b);
export fn{Rs} sub(a: gmat4x2f, b: gmat4x2f) = gsub(a, b);
export fn{Rs} sub(a: gmat4x3f, b: gmat4x3f) = gsub(a, b);
export fn{Rs} sub(a: gmat4x4f, b: gmat4x4f) = gsub(a, b);

fn{Rs} gmul{A, B, C}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' * ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {C}(varName, statements, buffers);
}
fn{Rs} gmul{A, B}(a: A, b: B) = gmul{A, B, A}(a, b);
export fn{Rs} mul(a: gu32, b: gu32) = gmul(a, b);
export fn{Rs} mul{T}(a: gu32, b: T) = mul(a, b.gu32);
export fn{Rs} mul{T}(a: T, b: gu32) = mul(a.gu32, b);

export fn{Rs} mul(a: gi32, b: gi32) = gmul(a, b);
export fn{Rs} mul{T}(a: gi32, b: T) = mul(a, b.gi32);
export fn{Rs} mul{T}(a: T, b: gi32) = mul(a.gi32, b);

export fn{Rs} mul(a: gf32, b: gf32) = gmul(a, b);
export fn{Rs} mul{T}(a: gf32, b: T) = mul(a, b.gf32);
export fn{Rs} mul{T}(a: T, b: gf32) = mul(a.gf32, b);

export fn{Rs} mul(a: gvec2u, b: gvec2u) = gmul(a, b);
export fn{Rs} mul(a: gvec2u, b: gu32) = gmul(a, b);
// Same thing here, using the commutative property
export fn{Rs} mul(a: gu32, b: gvec2u) = gmul(b, a);

export fn{Rs} mul(a: gvec2i, b: gvec2i) = gmul(a, b);
export fn{Rs} mul(a: gvec2i, b: gi32) = gmul(a, b);
export fn{Rs} mul(a: gi32, b: gvec2i) = gmul(b, a);

export fn{Rs} mul(a: gvec2f, b: gvec2f) = gmul(a, b);
export fn{Rs} mul(a: gvec2f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gvec2f) = gmul(b, a);

export fn{Rs} mul(a: gvec3u, b: gvec3u) = gmul(a, b);
export fn{Rs} mul(a: gvec3u, b: gu32) = gmul(a, b);
export fn{Rs} mul(a: gu32, b: gvec3u) = gmul(b, a);

export fn{Rs} mul(a: gvec3i, b: gvec3i) = gmul(a, b);
export fn{Rs} mul(a: gvec3i, b: gi32) = gmul(a, b);
export fn{Rs} mul(a: gi32, b: gvec3i) = gmul(b, a);

export fn{Rs} mul(a: gvec3f, b: gvec3f) = gmul(a, b);
export fn{Rs} mul(a: gvec3f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gvec3f) = gmul(b, a);

export fn{Rs} mul(a: gvec4u, b: gvec4u) = gmul(a, b);
export fn{Rs} mul(a: gvec4u, b: gu32) = gmul(a, b);
export fn{Rs} mul(a: gu32, b: gvec4u) = gmul(b, a);

export fn{Rs} mul(a: gvec4i, b: gvec4i) = gmul(a, b);
export fn{Rs} mul(a: gvec4i, b: gi32) = gmul(a, b);
export fn{Rs} mul(a: gi32, b: gvec4i) = gmul(b, a);

export fn{Rs} mul(a: gvec4f, b: gvec4f) = gmul(a, b);
export fn{Rs} mul(a: gvec4f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gvec4f) = gmul(b, a);

// Matrix multiplication, though, needs some special consideration, most of the time
export fn{Rs} mul(a: gmat2x2f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat2x2f) = gmul(b, a);
export fn{Rs} mul(a: gmat2x2f, b: gvec2f) = gmul{gmat2x2f, gvec2f, gvec2f}(a, b);
export fn{Rs} mul(a: gvec2f, b: gmat2x2f) = gmul{gvec2f, gmat2x2f, gvec2f}(a, b);
export fn{Rs} mul(a: gmat2x2f, b: gmat2x2f) = gmul(a, b);
export fn{Rs} mul(a: gmat2x2f, b: gmat3x2f) = gmul{gmat2x2f, gmat3x2f, gmat3x2f}(a, b);
export fn{Rs} mul(a: gmat2x2f, b: gmat4x2f) = gmul{gmat2x2f, gmat4x2f, gmat4x2f}(a, b);

export fn{Rs} mul(a: gmat2x3f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat2x3f) = gmul(b, a);
export fn{Rs} mul(a: gmat2x3f, b: gvec2f) = gmul{gmat2x3f, gvec2f, gvec3f}(a, b);
export fn{Rs} mul(a: gvec3f, b: gmat2x3f) = gmul{gvec3f, gmat2x3f, gvec2f}(a, b);
export fn{Rs} mul(a: gmat2x3f, b: gmat2x2f) = gmul(a, b);
export fn{Rs} mul(a: gmat2x3f, b: gmat3x2f) = gmul{gmat2x3f, gmat3x2f, gmat3x3f}(a, b);
export fn{Rs} mul(a: gmat2x3f, b: gmat4x2f) = gmul{gmat2x3f, gmat4x2f, gmat4x3f}(a, b);

export fn{Rs} mul(a: gmat2x4f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat2x4f) = gmul(b, a);
export fn{Rs} mul(a: gmat2x4f, b: gvec2f) = gmul{gmat2x4f, gvec2f, gvec4f}(a, b);
export fn{Rs} mul(a: gvec4f, b: gmat2x4f) = gmul{gvec4f, gmat2x4f, gvec2f}(a, b);
export fn{Rs} mul(a: gmat2x4f, b: gmat2x2f) = gmul(a, b);
export fn{Rs} mul(a: gmat2x4f, b: gmat3x2f) = gmul{gmat2x4f, gmat3x2f, gmat3x4f}(a, b);
export fn{Rs} mul(a: gmat2x4f, b: gmat4x2f) = gmul{gmat2x4f, gmat4x2f, gmat4x4f}(a, b);

export fn{Rs} mul(a: gmat3x2f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat3x2f) = gmul(b, a);
export fn{Rs} mul(a: gmat3x2f, b: gvec3f) = gmul{gmat3x2f, gvec3f, gvec2f}(a, b);
export fn{Rs} mul(a: gvec2f, b: gmat3x2f) = gmul{gvec2f, gmat3x2f, gvec3f}(a, b);
export fn{Rs} mul(a: gmat3x2f, b: gmat2x3f) = gmul{gmat3x2f, gmat2x3f, gmat2x2f}(a, b);
export fn{Rs} mul(a: gmat3x2f, b: gmat3x3f) = gmul(a, b);
export fn{Rs} mul(a: gmat3x2f, b: gmat4x3f) = gmul{gmat3x2f, gmat4x3f, gmat4x2f}(a, b);

export fn{Rs} mul(a: gmat3x3f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat3x3f) = gmul(b, a);
export fn{Rs} mul(a: gmat3x3f, b: gvec3f) = gmul{gmat3x3f, gvec3f, gvec3f}(a, b);
export fn{Rs} mul(a: gvec3f, b: gmat3x3f) = gmul(a, b);
export fn{Rs} mul(a: gmat3x3f, b: gmat2x3f) = gmul{gmat3x3f, gmat2x3f, gmat2x3f}(a, b);
export fn{Rs} mul(a: gmat3x3f, b: gmat3x3f) = gmul(a, b);
export fn{Rs} mul(a: gmat3x3f, b: gmat4x3f) = gmul{gmat3x3f, gmat4x3f, gmat4x3f}(a, b);

export fn{Rs} mul(a: gmat3x4f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat3x4f) = gmul(b, a);
export fn{Rs} mul(a: gmat3x4f, b: gvec3f) = gmul{gmat3x4f, gvec3f, gvec4f}(a, b);
export fn{Rs} mul(a: gvec4f, b: gmat3x4f) = gmul{gvec4f, gmat3x4f, gvec3f}(a, b);
export fn{Rs} mul(a: gmat3x4f, b: gmat2x3f) = gmul{gmat3x4f, gmat2x3f, gmat2x4f}(a, b);
export fn{Rs} mul(a: gmat3x4f, b: gmat3x3f) = gmul(a, b);
export fn{Rs} mul(a: gmat3x4f, b: gmat4x3f) = gmul{gmat3x4f, gmat4x3f, gmat4x4f}(a, b);

export fn{Rs} mul(a: gmat4x2f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat4x2f) = gmul(b, a);
export fn{Rs} mul(a: gmat4x2f, b: gvec4f) = gmul{gmat4x2f, gvec4f, gvec2f}(a, b);
export fn{Rs} mul(a: gvec2f, b: gmat4x2f) = gmul{gvec2f, gmat4x2f, gvec4f}(a, b);
export fn{Rs} mul(a: gmat4x2f, b: gmat2x4f) = gmul{gmat4x2f, gmat2x4f, gmat2x2f}(a, b);
export fn{Rs} mul(a: gmat4x2f, b: gmat3x4f) = gmul{gmat4x2f, gmat3x4f, gmat3x2f}(a, b);
export fn{Rs} mul(a: gmat4x2f, b: gmat4x4f) = gmul(a, b);

export fn{Rs} mul(a: gmat4x3f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat4x3f) = gmul(b, a);
export fn{Rs} mul(a: gmat4x3f, b: gvec4f) = gmul{gmat4x3f, gvec4f, gvec3f}(a, b);
export fn{Rs} mul(a: gvec3f, b: gmat4x3f) = gmul{gvec3f, gmat4x3f, gvec4f}(a, b);
export fn{Rs} mul(a: gmat4x3f, b: gmat2x4f) = gmul{gmat4x3f, gmat2x4f, gmat2x3f}(a, b);
export fn{Rs} mul(a: gmat4x3f, b: gmat3x4f) = gmul{gmat4x3f, gmat3x4f, gmat3x3f}(a, b);
export fn{Rs} mul(a: gmat4x3f, b: gmat4x4f) = gmul(a, b);

export fn{Rs} mul(a: gmat4x4f, b: gf32) = gmul(a, b);
export fn{Rs} mul(a: gf32, b: gmat4x4f) = gmul(b, a);
export fn{Rs} mul(a: gmat4x4f, b: gvec4f) = gmul{gmat4x4f, gvec4f, gvec4f}(a, b);
export fn{Rs} mul(a: gvec4f, b: gmat4x4f) = gmul(a, b);
export fn{Rs} mul(a: gmat4x4f, b: gmat2x4f) = gmul{gmat4x4f, gmat2x4f, gmat2x4f}(a, b);
export fn{Rs} mul(a: gmat4x4f, b: gmat3x4f) = gmul{gmat4x4f, gmat3x4f, gmat3x4f}(a, b);
export fn{Rs} mul(a: gmat4x4f, b: gmat4x4f) = gmul(a, b);

fn{Rs} gdiv{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {A}(varName, statements, buffers);
}
fn{Rs} gdivRev{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' / ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {B}(varName, statements, buffers);
}
export fn{Rs} div(a: gu32, b: gu32) = gdiv(a, b);
export fn{Rs} div{T}(a: gu32, b: T) = div(a, b.gu32);
export fn{Rs} div{T}(a: T, b: gu32) = div(a.gu32, b);

export fn{Rs} div(a: gi32, b: gi32) = gdiv(a, b);
export fn{Rs} div{T}(a: gi32, b: T) = div(a, b.gi32);
export fn{Rs} div{T}(a: T, b: gi32) = div(a.gi32, b);

export fn{Rs} div(a: gf32, b: gf32) = gdiv(a, b);
export fn{Rs} div{T}(a: gf32, b: T) = div(a, b.gf32);
export fn{Rs} div{T}(a: T, b: gf32) = div(a.gf32, b);

export fn{Rs} div(a: gvec2u, b: gvec2u) = gdiv(a, b);
export fn{Rs} div(a: gvec2u, b: gu32) = gdiv(a, b);
export fn{Rs} div(a: gu32, b: gvec2u) = gdivRev(a, b);

export fn{Rs} div(a: gvec2i, b: gvec2i) = gdiv(a, b);
export fn{Rs} div(a: gvec2i, b: gi32) = gdiv(a, b);
export fn{Rs} div(a: gi32, b: gvec2i) = gdivRev(a, b);

export fn{Rs} div(a: gvec2f, b: gvec2f) = gdiv(a, b);
export fn{Rs} div(a: gvec2f, b: gf32) = gdiv(a, b);
export fn{Rs} div(a: gf32, b: gvec2f) = gdivRev(a, b);

export fn{Rs} div(a: gvec3u, b: gvec3u) = gdiv(a, b);
export fn{Rs} div(a: gvec3u, b: gu32) = gdiv(a, b);
export fn{Rs} div(a: gu32, b: gvec3u) = gdivRev(a, b);

export fn{Rs} div(a: gvec3i, b: gvec3i) = gdiv(a, b);
export fn{Rs} div(a: gvec3i, b: gi32) = gdiv(a, b);
export fn{Rs} div(a: gi32, b: gvec3i) = gdivRev(a, b);

export fn{Rs} div(a: gvec3f, b: gvec3f) = gdiv(a, b);
export fn{Rs} div(a: gvec3f, b: gf32) = gdiv(a, b);
export fn{Rs} div(a: gf32, b: gvec3f) = gdivRev(a, b);

export fn{Rs} div(a: gvec4u, b: gvec4u) = gdiv(a, b);
export fn{Rs} div(a: gvec4u, b: gu32) = gdiv(a, b);
export fn{Rs} div(a: gu32, b: gvec4u) = gdivRev(a, b);

export fn{Rs} div(a: gvec4i, b: gvec4i) = gdiv(a, b);
export fn{Rs} div(a: gvec4i, b: gi32) = gdiv(a, b);
export fn{Rs} div(a: gi32, b: gvec4i) = gdivRev(a, b);

export fn{Rs} div(a: gvec4f, b: gvec4f) = gdiv(a, b);
export fn{Rs} div(a: gvec4f, b: gf32) = gdiv(a, b);
export fn{Rs} div(a: gf32, b: gvec4f) = gdivRev(a, b);

fn{Rs} gmod{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {A}(varName, statements, buffers);
}
fn{Rs} gmodRev{A, B}(a: A, b: B) {
  let varName = '('.concat(a.varName).concat(' % ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {B}(varName, statements, buffers);
}
export fn{Rs} mod(a: gu32, b: gu32) = gmod(a, b);
export fn{Rs} mod{T}(a: gu32, b: T) = mod(a, b.gu32);
export fn{Rs} mod{T}(a: T, b: gu32) = mod(a.gu32, b);

export fn{Rs} mod(a: gi32, b: gi32) = gmod(a, b);
export fn{Rs} mod{T}(a: gi32, b: T) = mod(a, b.gi32);
export fn{Rs} mod{T}(a: T, b: gi32) = mod(a.gi32, b);

export fn{Rs} mod(a: gf32, b: gf32) = gmod(a, b);
export fn{Rs} mod{T}(a: gf32, b: T) = mod(a, b.gf32);
export fn{Rs} mod{T}(a: T, b: gf32) = mod(a.gf32, b);

export fn{Rs} mod(a: gvec2u, b: gvec2u) = gmod(a, b);
export fn{Rs} mod(a: gvec2u, b: gu32) = gmod(a, b);
export fn{Rs} mod(a: gu32, b: gvec2u) = gmodRev(a, b);

export fn{Rs} mod(a: gvec2i, b: gvec2i) = gmod(a, b);
export fn{Rs} mod(a: gvec2i, b: gi32) = gmod(a, b);
export fn{Rs} mod(a: gi32, b: gvec2i) = gmodRev(a, b);

export fn{Rs} mod(a: gvec2f, b: gvec2f) = gmod(a, b);
export fn{Rs} mod(a: gvec2f, b: gf32) = gmod(a, b);
export fn{Rs} mod(a: gf32, b: gvec2f) = gmodRev(a, b);

export fn{Rs} mod(a: gvec3u, b: gvec3u) = gmod(a, b);
export fn{Rs} mod(a: gvec3u, b: gu32) = gmod(a, b);
export fn{Rs} mod(a: gu32, b: gvec3u) = gmodRev(a, b);

export fn{Rs} mod(a: gvec3i, b: gvec3i) = gmod(a, b);
export fn{Rs} mod(a: gvec3i, b: gi32) = gmod(a, b);
export fn{Rs} mod(a: gi32, b: gvec3i) = gmodRev(a, b);

export fn{Rs} mod(a: gvec3f, b: gvec3f) = gmod(a, b);
export fn{Rs} mod(a: gvec3f, b: gf32) = gmod(a, b);
export fn{Rs} mod(a: gf32, b: gvec3f) = gmodRev(a, b);

export fn{Rs} mod(a: gvec4u, b: gvec4u) = gmod(a, b);
export fn{Rs} mod(a: gvec4u, b: gu32) = gmod(a, b);
export fn{Rs} mod(a: gu32, b: gvec4u) = gmodRev(a, b);

export fn{Rs} mod(a: gvec4i, b: gvec4i) = gmod(a, b);
export fn{Rs} mod(a: gvec4i, b: gi32) = gmod(a, b);
export fn{Rs} mod(a: gi32, b: gvec4i) = gmodRev(a, b);

export fn{Rs} mod(a: gvec4f, b: gvec4f) = gmod(a, b);
export fn{Rs} mod(a: gvec4f, b: gf32) = gmod(a, b);
export fn{Rs} mod(a: gf32, b: gvec4f) = gmodRev(a, b);

// GPU Comparison methods

fn{Rs} geq{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' == ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} eq(a: gu32, b: gu32) = geq{gu32, gbool}(a, b);
export fn{Rs} eq{T}(a: gu32, b: T) = geq{gu32, gbool}(a, b.gu32);
export fn{Rs} eq{T}(a: T, b: gu32) = geq{gu32, gbool}(a.gu32, b);
export fn{Rs} eq(a: gi32, b: gi32) = geq{gi32, gbool}(a, b);
export fn{Rs} eq{T}(a: gi32, b: T) = geq{gi32, gbool}(a, b.gi32);
export fn{Rs} eq{T}(a: T, b: gi32) = geq{gi32, gbool}(a.gi32, b);
export fn{Rs} eq(a: gf32, b: gf32) = geq{gf32, gbool}(a, b);
export fn{Rs} eq{T}(a: gf32, b: T) = geq{gf32, gbool}(a, b.gf32);
export fn{Rs} eq{T}(a: T, b: gf32) = geq{gf32, gbool}(a.gf32, b);
export fn{Rs} eq(a: gbool, b: gbool) = geq{gbool, gbool}(a, b);
export fn{Rs} eq{T}(a: gbool, b: T) = geq{gbool, gbool}(a, b.gbool);
export fn{Rs} eq{T}(a: T, b: gbool) = geq{gbool, gbool}(a.gbool, b);
export fn{Rs} eq(a: gvec2u, b: gvec2u) = geq{gvec2u, gvec2b}(a, b);
export fn{Rs} eq(a: gvec2i, b: gvec2i) = geq{gvec2i, gvec2b}(a, b);
export fn{Rs} eq(a: gvec2f, b: gvec2f) = geq{gvec2f, gvec2b}(a, b);
export fn{Rs} eq(a: gvec2b, b: gvec2b) = geq{gvec2b, gvec2b}(a, b);
export fn{Rs} eq(a: gvec3u, b: gvec3u) = geq{gvec3u, gvec3b}(a, b);
export fn{Rs} eq(a: gvec3i, b: gvec3i) = geq{gvec3i, gvec3b}(a, b);
export fn{Rs} eq(a: gvec3f, b: gvec3f) = geq{gvec3f, gvec3b}(a, b);
export fn{Rs} eq(a: gvec3b, b: gvec3b) = geq{gvec3b, gvec3b}(a, b);
export fn{Rs} eq(a: gvec4u, b: gvec4u) = geq{gvec4u, gvec4b}(a, b);
export fn{Rs} eq(a: gvec4i, b: gvec4i) = geq{gvec4i, gvec4b}(a, b);
export fn{Rs} eq(a: gvec4f, b: gvec4f) = geq{gvec4f, gvec4b}(a, b);
export fn{Rs} eq(a: gvec4b, b: gvec4b) = geq{gvec4b, gvec4b}(a, b);

fn{Rs} gneq{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' != ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} neq(a: gu32, b: gu32) = gneq{gu32, gbool}(a, b);
export fn{Rs} neq{T}(a: gu32, b: T) = gneq{gu32, gbool}(a, b.gu32);
export fn{Rs} neq{T}(a: T, b: gu32) = gneq{gu32, gbool}(a.gu32, b);
export fn{Rs} neq(a: gi32, b: gi32) = gneq{gi32, gbool}(a, b);
export fn{Rs} neq{T}(a: gi32, b: T) = gneq{gi32, gbool}(a, b.gi32);
export fn{Rs} neq{T}(a: T, b: gi32) = gneq{gi32, gbool}(a.gi32, b);
export fn{Rs} neq(a: gf32, b: gf32) = gneq{gf32, gbool}(a, b);
export fn{Rs} neq{T}(a: gf32, b: T) = gneq{gf32, gbool}(a, b.gf32);
export fn{Rs} neq{T}(a: T, b: gf32) = gneq{gf32, gbool}(a.gf32, b);
export fn{Rs} neq(a: gbool, b: gbool) = gneq{gbool, gbool}(a, b);
export fn{Rs} neq{T}(a: gbool, b: T) = gneq{gbool, gbool}(a, b.gbool);
export fn{Rs} neq{T}(a: T, b: gbool) = gneq{gbool, gbool}(a.gbool, b);
export fn{Rs} neq(a: gvec2u, b: gvec2u) = gneq{gvec2u, gvec2b}(a, b);
export fn{Rs} neq(a: gvec2i, b: gvec2i) = gneq{gvec2i, gvec2b}(a, b);
export fn{Rs} neq(a: gvec2f, b: gvec2f) = gneq{gvec2f, gvec2b}(a, b);
export fn{Rs} neq(a: gvec2b, b: gvec2b) = gneq{gvec2b, gvec2b}(a, b);
export fn{Rs} neq(a: gvec3u, b: gvec3u) = gneq{gvec3u, gvec3b}(a, b);
export fn{Rs} neq(a: gvec3i, b: gvec3i) = gneq{gvec3i, gvec3b}(a, b);
export fn{Rs} neq(a: gvec3f, b: gvec3f) = gneq{gvec3f, gvec3b}(a, b);
export fn{Rs} neq(a: gvec3b, b: gvec3b) = gneq{gvec3b, gvec3b}(a, b);
export fn{Rs} neq(a: gvec4u, b: gvec4u) = gneq{gvec4u, gvec4b}(a, b);
export fn{Rs} neq(a: gvec4i, b: gvec4i) = gneq{gvec4i, gvec4b}(a, b);
export fn{Rs} neq(a: gvec4f, b: gvec4f) = gneq{gvec4f, gvec4b}(a, b);
export fn{Rs} neq(a: gvec4b, b: gvec4b) = gneq{gvec4b, gvec4b}(a, b);

fn{Rs} glt{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' < ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} lt(a: gu32, b: gu32) = glt{gu32, gbool}(a, b);
export fn{Rs} lt{T}(a: gu32, b: T) = glt{gu32, gbool}(a, b.gu32);
export fn{Rs} lt{T}(a: T, b: gu32) = glt{gu32, gbool}(a.gu32, b);
export fn{Rs} lt(a: gi32, b: gi32) = glt{gi32, gbool}(a, b);
export fn{Rs} lt{T}(a: gi32, b: T) = glt{gi32, gbool}(a, b.gi32);
export fn{Rs} lt{T}(a: T, b: gi32) = glt{gi32, gbool}(a.gi32, b);
export fn{Rs} lt(a: gf32, b: gf32) = glt{gf32, gbool}(a, b);
export fn{Rs} lt{T}(a: gf32, b: T) = glt{gf32, gbool}(a, b.gf32);
export fn{Rs} lt{T}(a: T, b: gf32) = glt{gf32, gbool}(a.gf32, b);
export fn{Rs} lt(a: gvec2u, b: gvec2u) = glt{gvec2u, gvec2b}(a, b);
export fn{Rs} lt(a: gvec2i, b: gvec2i) = glt{gvec2i, gvec2b}(a, b);
export fn{Rs} lt(a: gvec2f, b: gvec2f) = glt{gvec2f, gvec2b}(a, b);
export fn{Rs} lt(a: gvec3u, b: gvec3u) = glt{gvec3u, gvec3b}(a, b);
export fn{Rs} lt(a: gvec3i, b: gvec3i) = glt{gvec3i, gvec3b}(a, b);
export fn{Rs} lt(a: gvec3f, b: gvec3f) = glt{gvec3f, gvec3b}(a, b);
export fn{Rs} lt(a: gvec4u, b: gvec4u) = glt{gvec4u, gvec4b}(a, b);
export fn{Rs} lt(a: gvec4i, b: gvec4i) = glt{gvec4i, gvec4b}(a, b);
export fn{Rs} lt(a: gvec4f, b: gvec4f) = glt{gvec4f, gvec4b}(a, b);

fn{Rs} glte{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' <= ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} lte(a: gu32, b: gu32) = glte{gu32, gbool}(a, b);
export fn{Rs} lte{T}(a: gu32, b: T) = glte{gu32, gbool}(a, b.gu32);
export fn{Rs} lte{T}(a: T, b: gu32) = glte{gu32, gbool}(a.gu32, b);
export fn{Rs} lte(a: gi32, b: gi32) = glte{gi32, gbool}(a, b);
export fn{Rs} lte{T}(a: gi32, b: T) = glte{gi32, gbool}(a, b.gi32);
export fn{Rs} lte{T}(a: T, b: gi32) = glte{gi32, gbool}(a.gi32, b);
export fn{Rs} lte(a: gf32, b: gf32) = glte{gf32, gbool}(a, b);
export fn{Rs} lte{T}(a: gf32, b: T) = glte{gf32, gbool}(a, b.gf32);
export fn{Rs} lte{T}(a: T, b: gf32) = glte{gf32, gbool}(a.gf32, b);
export fn{Rs} lte(a: gvec2u, b: gvec2u) = glte{gvec2u, gvec2b}(a, b);
export fn{Rs} lte(a: gvec2i, b: gvec2i) = glte{gvec2i, gvec2b}(a, b);
export fn{Rs} lte(a: gvec2f, b: gvec2f) = glte{gvec2f, gvec2b}(a, b);
export fn{Rs} lte(a: gvec3u, b: gvec3u) = glte{gvec3u, gvec3b}(a, b);
export fn{Rs} lte(a: gvec3i, b: gvec3i) = glte{gvec3i, gvec3b}(a, b);
export fn{Rs} lte(a: gvec3f, b: gvec3f) = glte{gvec3f, gvec3b}(a, b);
export fn{Rs} lte(a: gvec4u, b: gvec4u) = glte{gvec4u, gvec4b}(a, b);
export fn{Rs} lte(a: gvec4i, b: gvec4i) = glte{gvec4i, gvec4b}(a, b);
export fn{Rs} lte(a: gvec4f, b: gvec4f) = glte{gvec4f, gvec4b}(a, b);

fn{Rs} ggt{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' < ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} gt(a: gu32, b: gu32) = ggt{gu32, gbool}(a, b);
export fn{Rs} gt{T}(a: gu32, b: T) = ggt{gu32, gbool}(a, b.gu32);
export fn{Rs} gt{T}(a: T, b: gu32) = ggt{gu32, gbool}(a.gu32, b);
export fn{Rs} gt(a: gi32, b: gi32) = ggt{gi32, gbool}(a, b);
export fn{Rs} gt{T}(a: gi32, b: T) = ggt{gi32, gbool}(a, b.gi32);
export fn{Rs} gt{T}(a: T, b: gi32) = ggt{gi32, gbool}(a.gi32, b);
export fn{Rs} gt(a: gf32, b: gf32) = ggt{gf32, gbool}(a, b);
export fn{Rs} gt{T}(a: gf32, b: T) = ggt{gf32, gbool}(a, b.gf32);
export fn{Rs} gt{T}(a: T, b: gf32) = ggt{gf32, gbool}(a.gf32, b);
export fn{Rs} gt(a: gvec2u, b: gvec2u) = ggt{gvec2u, gvec2b}(a, b);
export fn{Rs} gt(a: gvec2i, b: gvec2i) = ggt{gvec2i, gvec2b}(a, b);
export fn{Rs} gt(a: gvec2f, b: gvec2f) = ggt{gvec2f, gvec2b}(a, b);
export fn{Rs} gt(a: gvec3u, b: gvec3u) = ggt{gvec3u, gvec3b}(a, b);
export fn{Rs} gt(a: gvec3i, b: gvec3i) = ggt{gvec3i, gvec3b}(a, b);
export fn{Rs} gt(a: gvec3f, b: gvec3f) = ggt{gvec3f, gvec3b}(a, b);
export fn{Rs} gt(a: gvec4u, b: gvec4u) = ggt{gvec4u, gvec4b}(a, b);
export fn{Rs} gt(a: gvec4i, b: gvec4i) = ggt{gvec4i, gvec4b}(a, b);
export fn{Rs} gt(a: gvec4f, b: gvec4f) = ggt{gvec4f, gvec4b}(a, b);

fn{Rs} ggte{I, O}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' <= ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {O}(varName, statements, buffers);
}
export fn{Rs} gte(a: gu32, b: gu32) = ggte{gu32, gbool}(a, b);
export fn{Rs} gte{T}(a: gu32, b: T) = ggte{gu32, gbool}(a, b.gu32);
export fn{Rs} gte{T}(a: T, b: gu32) = ggte{gu32, gbool}(a.gu32, b);
export fn{Rs} gte(a: gi32, b: gi32) = ggte{gi32, gbool}(a, b);
export fn{Rs} gte{T}(a: gi32, b: T) = ggte{gi32, gbool}(a, b.gi32);
export fn{Rs} gte{T}(a: T, b: gi32) = ggte{gi32, gbool}(a.gi32, b);
export fn{Rs} gte(a: gf32, b: gf32) = ggte{gf32, gbool}(a, b);
export fn{Rs} gte{T}(a: gf32, b: T) = ggte{gf32, gbool}(a, b.gf32);
export fn{Rs} gte{T}(a: T, b: gf32) = ggte{gf32, gbool}(a.gf32, b);
export fn{Rs} gte(a: gvec2u, b: gvec2u) = ggte{gvec2u, gvec2b}(a, b);
export fn{Rs} gte(a: gvec2i, b: gvec2i) = ggte{gvec2i, gvec2b}(a, b);
export fn{Rs} gte(a: gvec2f, b: gvec2f) = ggte{gvec2f, gvec2b}(a, b);
export fn{Rs} gte(a: gvec3u, b: gvec3u) = ggte{gvec3u, gvec3b}(a, b);
export fn{Rs} gte(a: gvec3i, b: gvec3i) = ggte{gvec3i, gvec3b}(a, b);
export fn{Rs} gte(a: gvec3f, b: gvec3f) = ggte{gvec3f, gvec3b}(a, b);
export fn{Rs} gte(a: gvec4u, b: gvec4u) = ggte{gvec4u, gvec4b}(a, b);
export fn{Rs} gte(a: gvec4i, b: gvec4i) = ggte{gvec4i, gvec4b}(a, b);
export fn{Rs} gte(a: gvec4f, b: gvec4f) = ggte{gvec4f, gvec4b}(a, b);

fn{Rs} if{T}(c: gbool, t: T, f: T) {
  let varName = "if_".concat(uuid().string.replace('-', '_'));
  let tBody = t.statements.Array.map(fn (kv: (string, string)) {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () = "", fn () {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let fBody = f.statements.Array.map(fn (kv: (string, string)) {
    return if(kv.0.eq("@builtin(global_invocation_id) id: vec3u"), fn () = "", fn () {
      return "  ".concat(kv.1).concat(";\n");
    });
  }).join("");
  let statement = "var "
    .concat(varName)
    .concat(": ")
    .concat(t.typeName)
    .concat("; if ")
    .concat(c.varName)
    .concat(" { ")
    .concat(tBody)
    .concat('; ')
    .concat(varName)
    .concat(' = ')
    .concat(t.varName)
    .concat("; } else { ")
    .concat(fBody)
    .concat('; ')
    .concat(varName)
    .concat(' = ')
    .concat(f.varName)
    .concat('; }');
  let statements = c.statements.concat(Dict(varName, statement));
  let buffers = c.buffers.union(t.buffers).union(f.buffers);
  return {T}(varName, statements, buffers);
}
fn{Rs} if{T}(c: gbool, t: () -> T, f: () -> T) = if(c, t(), f());
fn{Rs} if{T}(c: gbool, t: T, f: T) {
  let varName = "select("
    .concat(f.varName)
    .concat(', ')
    .concat(t.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = f.statements.concat(t.statements).concat(c.statements);
  let buffers = f.buffers.union(t.buffers).union(c.buffers);
  return {T}(varName, statements, buffers);
}

// GPU Boolean and Bitwise methods

fn{Rs} gnot{I}(a: I) {
  let varName = '(!'.concat(a.varName).concat(')');
  let statements = a.statements.clone();
  let buffers = a.buffers.clone();
  return {I}(varName, statements, buffers);
}
export fn{Rs} not(a: gu32) = gnot(a);
export fn{Rs} not(a: gi32) = gnot(a);
export fn{Rs} not(a: gbool) = gnot(a);
export fn{Rs} not(a: gvec2u) = gnot(a);
export fn{Rs} not(a: gvec2i) = gnot(a);
export fn{Rs} not(a: gvec2b) = gnot(a);
export fn{Rs} not(a: gvec3u) = gnot(a);
export fn{Rs} not(a: gvec3i) = gnot(a);
export fn{Rs} not(a: gvec3b) = gnot(a);
export fn{Rs} not(a: gvec4u) = gnot(a);
export fn{Rs} not(a: gvec4i) = gnot(a);
export fn{Rs} not(a: gvec4b) = gnot(a);

fn{Rs} gor{I}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' | ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn{Rs} or(a: gu32, b: gu32) = gor(a, b);
export fn{Rs} or{T}(a: gu32, b: T) = gor(a, b.gu32);
export fn{Rs} or{T}(a: T, b: gu32) = gor(a.gu32, b);
export fn{Rs} or(a: gi32, b: gi32) = gor(a, b);
export fn{Rs} or{T}(a: gi32, b: T) = gor(a, b.gi32);
export fn{Rs} or{T}(a: T, b: gi32) = gor(a.gi32, b);
export fn{Rs} or(a: gbool, b: gbool) = gor(a, b);
export fn{Rs} or{T}(a: gbool, b: T) = gor(a, b.gbool);
export fn{Rs} or{T}(a: T, b: gbool) = gor(a.gbool, b);
export fn{Rs} or(a: gvec2u, b: gvec2u) = gor(a, b);
export fn{Rs} or(a: gvec2i, b: gvec2i) = gor(a, b);
export fn{Rs} or(a: gvec2b, b: gvec2b) = gor(a, b);
export fn{Rs} or(a: gvec3u, b: gvec3u) = gor(a, b);
export fn{Rs} or(a: gvec3i, b: gvec3i) = gor(a, b);
export fn{Rs} or(a: gvec3b, b: gvec3b) = gor(a, b);
export fn{Rs} or(a: gvec4u, b: gvec4u) = gor(a, b);
export fn{Rs} or(a: gvec4i, b: gvec4i) = gor(a, b);
export fn{Rs} or(a: gvec4b, b: gvec4b) = gor(a, b);

fn{Rs} gand{I}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' & ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn{Rs} and(a: gu32, b: gu32) = gand(a, b);
export fn{Rs} and{T}(a: gu32, b: T) = gand(a, b.gu32);
export fn{Rs} and{T}(a: T, b: gu32) = gand(a.gu32, b);
export fn{Rs} and(a: gi32, b: gi32) = gand(a, b);
export fn{Rs} and{T}(a: gi32, b: T) = gand(a, b.gi32);
export fn{Rs} and{T}(a: T, b: gi32) = gand(a.gi32, b);
export fn{Rs} and(a: gbool, b: gbool) = gand(a, b);
export fn{Rs} and{T}(a: gbool, b: T) = gand(a, b.gbool);
export fn{Rs} and{T}(a: T, b: gbool) = gand(a.gbool, b);
export fn{Rs} and(a: gvec2u, b: gvec2u) = gand(a, b);
export fn{Rs} and(a: gvec2i, b: gvec2i) = gand(a, b);
export fn{Rs} and(a: gvec2b, b: gvec2b) = gand(a, b);
export fn{Rs} and(a: gvec3u, b: gvec3u) = gand(a, b);
export fn{Rs} and(a: gvec3i, b: gvec3i) = gand(a, b);
export fn{Rs} and(a: gvec3b, b: gvec3b) = gand(a, b);
export fn{Rs} and(a: gvec4u, b: gvec4u) = gand(a, b);
export fn{Rs} and(a: gvec4i, b: gvec4i) = gand(a, b);
export fn{Rs} and(a: gvec4b, b: gvec4b) = gand(a, b);

// There's no xor for bools in wgsl. Do I patch that over or leave it as an exercise to the reader?
fn{Rs} gxor{I}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' ^ ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn{Rs} xor(a: gu32, b: gu32) = gxor(a, b);
export fn{Rs} xor{T}(a: gu32, b: T) = gxor(a, b.gu32);
export fn{Rs} xor{T}(a: T, b: gu32) = gxor(a.gu32, b);
export fn{Rs} xor(a: gi32, b: gi32) = gxor(a, b);
export fn{Rs} xor{T}(a: gi32, b: T) = gxor(a, b.gi32);
export fn{Rs} xor{T}(a: T, b: gi32) = gxor(a.gi32, b);
export fn{Rs} xor(a: gvec2u, b: gvec2u) = gxor(a, b);
export fn{Rs} xor(a: gvec2i, b: gvec2i) = gxor(a, b);
export fn{Rs} xor(a: gvec3u, b: gvec3u) = gxor(a, b);
export fn{Rs} xor(a: gvec3i, b: gvec3i) = gxor(a, b);
export fn{Rs} xor(a: gvec4u, b: gvec4u) = gxor(a, b);
export fn{Rs} xor(a: gvec4i, b: gvec4i) = gxor(a, b);

fn{Rs} gshl{I}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' << ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn{Rs} shl(a: gu32, b: gu32) = gshl(a, b);
export fn{Rs} shl{T}(a: gu32, b: T) = gshl(a, b.gu32);
export fn{Rs} shl{T}(a: T, b: gu32) = gshl(a.gu32, b);
export fn{Rs} shl(a: gi32, b: gi32) = gshl(a, b);
export fn{Rs} shl{T}(a: gi32, b: T) = gshl(a, b.gi32);
export fn{Rs} shl{T}(a: T, b: gi32) = gshl(a.gi32, b);
export fn{Rs} shl(a: gvec2u, b: gvec2u) = gshl(a, b);
export fn{Rs} shl(a: gvec2i, b: gvec2i) = gshl(a, b);
export fn{Rs} shl(a: gvec3u, b: gvec3u) = gshl(a, b);
export fn{Rs} shl(a: gvec3i, b: gvec3i) = gshl(a, b);
export fn{Rs} shl(a: gvec4u, b: gvec4u) = gshl(a, b);
export fn{Rs} shl(a: gvec4i, b: gvec4i) = gshl(a, b);

fn{Rs} gshr{I}(a: I, b: I) {
  let varName = '('.concat(a.varName).concat(' >> ').concat(b.varName).concat(')');
  let statements = a.statements.concat(b.statements);
  let buffers = a.buffers.union(b.buffers);
  return {I}(varName, statements, buffers);
}
export fn{Rs} shr(a: gu32, b: gu32) = gshr(a, b);
export fn{Rs} shr{T}(a: gu32, b: T) = gshr(a, b.gu32);
export fn{Rs} shr{T}(a: T, b: gu32) = gshr(a.gu32, b);
export fn{Rs} shr(a: gi32, b: gi32) = gshr(a, b);
export fn{Rs} shr{T}(a: gi32, b: T) = gshr(a, b.gi32);
export fn{Rs} shr{T}(a: T, b: gi32) = gshr(a.gi32, b);
export fn{Rs} shr(a: gvec2u, b: gvec2u) = gshr(a, b);
export fn{Rs} shr(a: gvec2i, b: gvec2i) = gshr(a, b);
export fn{Rs} shr(a: gvec3u, b: gvec3u) = gshr(a, b);
export fn{Rs} shr(a: gvec3i, b: gvec3i) = gshr(a, b);
export fn{Rs} shr(a: gvec4u, b: gvec4u) = gshr(a, b);
export fn{Rs} shr(a: gvec4i, b: gvec4i) = gshr(a, b);

// Bitcasting methods (TODO: Is there a better naming scheme possible?)

fn{Rs} gbitcast{I, O}(v: I) {
  let varName = 'bitcast<'.concat({O.typeName}()).concat('>(').concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return {O}(varName, statements, buffers);
}
export fn{Rs} asU32(v: gu32) = v;
export fn{Rs} asU32(v: gi32) = gbitcast{gi32, gu32}(v);
export fn{Rs} asU32(v: gf32) = gbitcast{gf32, gu32}(v);
export fn{Rs} asI32(v: gu32) = gbitcast{gu32, gi32}(v);
export fn{Rs} asI32(v: gi32) = v;
export fn{Rs} asI32(v: gf32) = gbitcast{gf32, gi32}(v);
export fn{Rs} asF32(v: gu32) = gbitcast{gu32, gf32}(v);
export fn{Rs} asF32(v: gi32) = gbitcast{gi32, gf32}(v);
export fn{Rs} asF32(v: gf32) = v;
export fn{Rs} asVec2u(v: gvec2u) = v;
export fn{Rs} asVec2u(v: gvec2i) = gbitcast{gvec2i, gvec2u}(v);
export fn{Rs} asVec2u(v: gvec2f) = gbitcast{gvec2f, gvec2u}(v);
export fn{Rs} asVec2i(v: gvec2u) = gbitcast{gvec2u, gvec2i}(v);
export fn{Rs} asVec2i(v: gvec2i) = v;
export fn{Rs} asVec2i(v: gvec2f) = gbitcast{gvec2f, gvec2i}(v);
export fn{Rs} asVec2f(v: gvec2u) = gbitcast{gvec2u, gvec2f}(v);
export fn{Rs} asVec2f(v: gvec2i) = gbitcast{gvec2i, gvec2f}(v);
export fn{Rs} asVec2f(v: gvec2f) = v;
export fn{Rs} asVec3u(v: gvec3u) = v;
export fn{Rs} asVec3u(v: gvec3i) = gbitcast{gvec3i, gvec3u}(v);
export fn{Rs} asVec3u(v: gvec3f) = gbitcast{gvec3f, gvec3u}(v);
export fn{Rs} asVec3i(v: gvec3u) = gbitcast{gvec3u, gvec3i}(v);
export fn{Rs} asVec3i(v: gvec3i) = v;
export fn{Rs} asVec3i(v: gvec3f) = gbitcast{gvec3f, gvec3i}(v);
export fn{Rs} asVec3f(v: gvec3u) = gbitcast{gvec3u, gvec3f}(v);
export fn{Rs} asVec3f(v: gvec3i) = gbitcast{gvec3i, gvec3f}(v);
export fn{Rs} asVec3f(v: gvec3f) = v;
export fn{Rs} asVec4u(v: gvec4u) = v;
export fn{Rs} asVec4u(v: gvec4i) = gbitcast{gvec4i, gvec4u}(v);
export fn{Rs} asVec4u(v: gvec4f) = gbitcast{gvec4f, gvec4u}(v);
export fn{Rs} asVec4i(v: gvec4u) = gbitcast{gvec4u, gvec4i}(v);
export fn{Rs} asVec4i(v: gvec4i) = v;
export fn{Rs} asVec4i(v: gvec4f) = gbitcast{gvec4f, gvec4i}(v);
export fn{Rs} asVec4f(v: gvec4u) = gbitcast{gvec4u, gvec4f}(v);
export fn{Rs} asVec4f(v: gvec4i) = gbitcast{gvec4i, gvec4f}(v);
export fn{Rs} asVec4f(v: gvec4f) = v;

// GPU Vector functions

fn{Rs} gevery{I}(v: I) {
  let varName = 'all('.concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return gbool(varName, statements, buffers);
}
export fn{Rs} every(v: gvec2b) = gevery(v);
export fn{Rs} every(v: gvec3b) = gevery(v);
export fn{Rs} every(v: gvec4b) = gevery(v);

fn{Rs} gsome{I}(v: I) {
  let varName = 'any('.concat(v.varName).concat(')');
  let statements = v.statements.clone;
  let buffers = v.buffers.clone;
  return gbool(varName, statements, buffers);
}
export fn{Rs} some(v: gvec2b) = gsome(v);
export fn{Rs} some(v: gvec3b) = gsome(v);
export fn{Rs} some(v: gvec4b) = gsome(v);

fn{Rs} piecewiseIf{C, T}(c: C, t: T, f: T) {
  let varName = "select("
    .concat(f.varName)
    .concat(', ')
    .concat(t.varName)
    .concat(', ')
    .concat(c.varName)
    .concat(')');
  let statements = f.statements.concat(t.statements).concat(c.statements);
  let buffers = f.buffers.union(t.buffers).union(c.buffers);
  return {T}(varName, statements, buffers);
}
export fn{Rs} if(c: gvec2b, t: gvec2u, f: gvec2u) = piecewiseIf{gvec2b, gvec2u}(c, t, f);
export fn{Rs} if(c: gvec2b, t: gvec2i, f: gvec2i) = piecewiseIf{gvec2b, gvec2i}(c, t, f);
export fn{Rs} if(c: gvec2b, t: gvec2f, f: gvec2f) = piecewiseIf{gvec2b, gvec2f}(c, t, f);
export fn{Rs} if(c: gvec2b, t: gvec2b, f: gvec2b) = piecewiseIf{gvec2b, gvec2b}(c, t, f);
export fn{Rs} if(c: gvec3b, t: gvec3u, f: gvec3u) = piecewiseIf{gvec3b, gvec3u}(c, t, f);
export fn{Rs} if(c: gvec3b, t: gvec3i, f: gvec3i) = piecewiseIf{gvec3b, gvec3i}(c, t, f);
export fn{Rs} if(c: gvec3b, t: gvec3f, f: gvec3f) = piecewiseIf{gvec3b, gvec3f}(c, t, f);
export fn{Rs} if(c: gvec3b, t: gvec3b, f: gvec3b) = piecewiseIf{gvec3b, gvec3b}(c, t, f);
export fn{Rs} if(c: gvec4b, t: gvec4u, f: gvec4u) = piecewiseIf{gvec4b, gvec4u}(c, t, f);
export fn{Rs} if(c: gvec4b, t: gvec4i, f: gvec4i) = piecewiseIf{gvec4b, gvec4i}(c, t, f);
export fn{Rs} if(c: gvec4b, t: gvec4f, f: gvec4f) = piecewiseIf{gvec4b, gvec4f}(c, t, f);
export fn{Rs} if(c: gvec4b, t: gvec4b, f: gvec4b) = piecewiseIf{gvec4b, gvec4b}(c, t, f);

// GBuffer methods

// TODO: Support more than i32 for GBuffer
export fn{Rs} map(gb: GBuffer, f: (gi32) -> gi32) {
  let idx = gFor(gb.len);
  let val = gb[idx];
  let out = GBuffer(gb.len.mul(4));
  let compute = out[idx].store(f(val));
  compute.build.run;
  return out;
}
export fn{Rs} map(gb: GBuffer, f: (gi32, gu32) -> gi32) {
  let idx = gFor(gb.len);
  let val = gb[idx];
  let out = GBuffer(gb.len.mul(4));
  let compute = out[idx].store(f(val, idx));
  compute.build.run;
  return out;
}

/// Process exit-related bindings
export fn{Rs} ExitCode "std::process::ExitCode::from" :: Own{u8} -> ExitCode;
export fn{Js} ExitCode "Number" :: u8 -> ExitCode;
export fn ExitCode(e: u16) = ExitCode(e.u8);
export fn ExitCode(e: u32) = ExitCode(e.u8);
export fn ExitCode(e: u64) = ExitCode(e.u8);
export fn ExitCode(e: i8) = ExitCode(e.u8);
export fn ExitCode(e: i16) = ExitCode(e.u8);
export fn ExitCode(e: i32) = ExitCode(e.u8);
export fn ExitCode(e: i64) = ExitCode(e.u8);

/// Stdout/stderr-related bindings
// TODO: Rework this to just print anything that can be converted to `string` via interfaces
export fn{Rs} print{T}(v: T) = {"println!" :: ("{}", string)}(v.string);
export fn{Js} print{T}(v: T) = {"console.log" :: T}(v);
export fn{Js} print "((s) => console.log(s.val))" :: string;
export fn{Js} print (b: bool) = b.string.print;
export fn{Js} print (i: i8) = i.string.print;
export fn{Js} print (u: u8) = u.string.print;
export fn{Js} print (i: i16) = i.string.print;
export fn{Js} print (u: u16) = u.string.print;
export fn{Js} print (i: i32) = i.string.print;
export fn{Js} print (u: u32) = u.string.print;
export fn{Js} print (i: i64) = i.string.print;
export fn{Js} print (u: u64) = u.string.print;
export fn{Js} print (f: f32) = f.string.print;
export fn{Js} print (f: f64) = f.string.print;
export fn{Js} print (i: i64[]) = "[".concat(i.map(string).join(", ")).concat("]").print;
export fn{Js} print (u: u64[]) = "[".concat(u.map(string).join(", ")).concat("]").print;
export fn{Js} print{S} (i: Buffer{i64, S}) = "[".concat(i.map(string).join(", ")).concat("]").print;
export fn{Js} print{S} (u: Buffer{u64, S}) = "[".concat(u.map(string).join(", ")).concat("]").print;
export fn{Js} print (e: Error) = "Error: ".concat(e.string).print;
export fn{Rs} print (d: Duration) = {"println!" :: ("{}.{:0>9}", u64, u32)}(
  {Method{"as_secs"} :: Duration -> u64}(d),
  {Method{"subsec_nanos"} :: Duration -> u32}(d));
export fn{Rs} print(v: void) = {"println!" :: "void"}();
export fn{Js} print(v: void) = {"console.log" :: "void"}();
export fn{Rs} print(s: string) = {"println!" :: ("{}", string)}(s);
export fn{Rs} print{T, N}(a: T[N]) = "[".concat(a.map(string).join(", ")).concat("]").print;
export fn{Rs} print{T}(a: T[]) = "[".concat(a.map(string).join(", ")).concat("]").print;
export fn print{T}(v: T?) = if(v.exists,
  fn = v.getOrExit.print,
  fn = print("void"));
export fn print{T}(v: T!) = if({T}(v).exists,
  fn = v.getOrExit.print,
  fn = v.Error.getOrExit.print);
export fn{Js} print{T}(v: void!) = if({T}(v).exists,
  fn = "void".print,
  fn = v.Error.getOrExit.print);
export fn{Rs} eprint{T}(v: T) = {"eprintln!" :: ("{}", string)}(v.string);
export fn{Js} eprint{T}(v: T) = {"console.error" :: string}(v.string);
export fn{Rs} eprint(v: void) = {"eprintln!" :: "void"}();
export fn{Js} eprint(v: void) = {"console.error" :: "void"}();
export fn{Rs} eprint(s: string) = {"eprintln!" :: ("{}", string)}(s);
export fn{Js} eprint "((s) => console.error(s.val))" :: string;
export fn{Js} eprint (b: bool) = b.string.print;
export fn{Js} eprint (i: i8) = i.string.print;
export fn{Js} eprint (u: u8) = u.string.print;
export fn{Js} eprint (i: i16) = i.string.print;
export fn{Js} eprint (u: u16) = u.string.print;
export fn{Js} eprint (i: i32) = i.string.print;
export fn{Js} eprint (u: u32) = u.string.print;
export fn{Js} eprint (i: i64) = i.string.print;
export fn{Js} eprint (u: u64) = u.string.print;
export fn{Js} eprint (f: f32) = f.string.print;
export fn{Js} eprint (f: f64) = f.string.print;
export fn{Js} eprint (i: i64[]) = "[".concat(i.map(string).join(", ")).concat("]").print;
export fn{Js} eprint (u: u64[]) = "[".concat(u.map(string).join(", ")).concat("]").print;
export fn{Rs} eprint{T}(a: T[]) = "[".concat(a.map(string).join(", ")).concat("]").eprint;
export fn{Rs} eprint{T}(v: T?) = if(v.exists,
  fn = v.getOrExit.eprint,
  fn = eprint("void"));
export fn{Rs} eprint{T}(v: T!) = if({T}(v).exists,
  fn = v.getOrExit.eprint,
  fn = v.Error.getOrExit.eprint);

/// Built-in operator definitions
export infix add as + precedence 3;
export infix sub as - precedence 3;
export prefix neg as - precedence 6;
export infix mul as * precedence 4;
export infix div as / precedence 4;
export infix mod as % precedence 4;
// export infix template as % precedence 4;
export infix pow as ** precedence 5;
export infix and as & precedence 4;
export infix and as && precedence 4;
export infix or as | precedence 3;
export infix or as || precedence 3;
export infix xor as ^ precedence 3;
export prefix not as ! precedence 5;
export infix nand as !& precedence 4;
export infix nor as !| precedence 3;
export infix xnor as !^ precedence 3;
export infix eq as == precedence 1;
export infix neq as != precedence 1;
export infix lt as < precedence 1;
export infix lte as <= precedence 1;
export infix gt as > precedence 1;
export infix gte as >= precedence 1;
export prefix len as # precedence 1; // TODO: Is this useful?
export infix shl as << precedence 2;
export infix shr as >> precedence 2;
export infix wrl as <<< precedence 2;
export infix wrr as >>> precedence 2;
export infix store as = precedence 0;
