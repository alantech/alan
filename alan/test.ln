fn aNumber(num: i64) {
  return 'I got a number! '.concat(num.string);
}


export fn{Test} main {
  let test = Testing();

  test.describe("Unorganized Tests") // TODO: Find a better grouping for these
    .it("passing ints to functions")
      .assert(eq, aNumber(5), 'I got a number! 5')
    .it("underscores in numbers")
      .assert(eq, 1_000_000 * 2, 2000000)
    .it("other integer syntaxes")
      .assert(eq, 0b10, 2)
      .assert(eq, 0o10, 8)
      .assert(eq, 0x10, 16)
      .assert(eq, 0xF, 15)
    .it("scientific notation")
      .assert(eq, 15.0, 1.5e1)
      .assert(eq, -5.0, -5e0)
      .assert(eq, 1e3, 1000.0)
      .assert(eq, 1e-3, 0.001);

  test.describe("Basic math tests i8")
    .it("add")
      .assert(eq, add(i8(1), i8(2)), i8(3))
    .it("sub")
      .assert(eq, sub(i8(2), i8(1)), i8(1))
    .it("mul")
      .assert(eq, mul(i8(2), i8(1)), i8(2))
    .it("div")
      .assert(eq, div(i8(6), i8(2)), i8(3))
    .it("mod")
      .assert(eq, mod(i8(6), i8(4)), i8(2))
    .it("pow")
      .assert(eq, pow(i8(6), i8(2)), i8(36))
    .it("min")
      .assert(eq, min(i8(3), i8(5)), i8(3))
    .it("max")
      .assert(eq, max(i8(3), i8(5)), i8(5))
    .it("neg")
      .assert(eq, neg(i8(3)), i8(-3))
    .it("abs")
      .assert(eq, abs(i8(-3)), i8(3))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i8.clz, 8.i8)
      .assert(eq, 1.i8.clz, 7.i8)
      .assert(eq, 2.i8.clz, 6.i8)
      .assert(eq, (-128).i8.clz, 0.i8));

  test.describe("Basic math tests i16")
    .it("add")
      .assert(eq, add(i16(1), i16(2)), i16(3))
    .it("sub")
      .assert(eq, sub(i16(2), i16(1)), i16(1))
    .it("mul")
      .assert(eq, mul(i16(2), i16(1)), i16(2))
    .it("div")
      .assert(eq, div(i16(6), i16(2)), i16(3))
    .it("mod")
      .assert(eq, mod(i16(6), i16(4)), i16(2))
    .it("pow")
      .assert(eq, pow(i16(6), i16(2)), i16(36))
    .it("min")
      .assert(eq, min(i16(3), i16(5)), i16(3))
    .it("max")
      .assert(eq, max(i16(3), i16(5)), i16(5))
    .it("neg")
      .assert(eq, neg(i16(3)), i16(-3))
    .it("abs")
      .assert(eq, abs(i16(-3)), i16(3))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i16.clz, 16.i16)
      .assert(eq, 1.i16.clz, 15.i16)
      .assert(eq, 2.i16.clz, 14.i16)
      .assert(eq, (-32768).i16.clz, 0.i16));

  test.describe("Basic math tests i32")
    .it("add")
      .assert(eq, 1.i32 + 2.i32, 3.i32)
    .it("sub")
      .assert(eq, 2.i32 - i32(1), 1.i32())
    .it("mul")
      .assert(eq, 2.i32 * 1.i32, 2.i32)
    .it("div")
      .assert(eq, 6.i32 / 2.i32, 3.i32)
    .it("mod")
      .assert(eq, mod(6.i32, 4.i32), 2.i32)
    .it("pow")
      .assert(eq, pow(6.i32, 2.i32), 36.i32)
    .it("min")
      .assert(eq, min(3.i32, 5.i32), 3.i32)
    .it("max")
      .assert(eq, max(3.i32, 5.i32), 5.i32)
    .it("neg")
      .assert(eq, neg(3.i32), i32(-3))
    .it("abs")
      .assert(eq, abs(-3.i32), 3.i32)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i32.clz, 32.i32)
      .assert(eq, 1.i32.clz, 31.i32)
      .assert(eq, 2.i32.clz, 30.i32)
      .assert(eq, (-2_147_483_648).i32.clz, 0.i32));

  test.describe("Basic math tests i64")
    .it("add")
      .assert(eq, 1 + 2, 3)
    .it("sub")
      .assert(eq, 2 - 1, 1)
    .it("mul")
      .assert(eq, 2 * 1, 2)
    .it("div")
      .assert(eq, 6 / 2, 3)
    .it("mod")
      .assert(eq, 6 % 4, 2)
    .it("pow")
      .assert(eq, 6 ** 2, 36)
    .it("min")
      .assert(eq, min(3, 5), 3)
    .it("max")
      .assert(eq, max(3, 5), 5)
    .it("neg")
      .assert(eq, neg(3), -3)
    .it("abs")
      .assert(eq, abs(-3), 3)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.clz, 64.i64)
      .assert(eq, 1.clz, 63.i64)
      .assert(eq, 2.i64.clz, 62.i64)
      .assert(eq, -9_223_372_036_854_775_808.clz, 0));

  test.describe("Basic math tests u8")
    .it("add")
      .assert(eq, add(u8(1), u8(2)), u8(3))
    .it("sub")
      .assert(eq, sub(u8(2), u8(1)), u8(1))
    .it("mul")
      .assert(eq, mul(u8(2), u8(1)), u8(2))
    .it("div")
      .assert(eq, div(u8(6), u8(2)), u8(3))
    .it("mod")
      .assert(eq, mod(u8(6), u8(4)), u8(2))
    .it("pow")
      .assert(eq, pow(u8(6), u8(2)), u8(36))
    .it("min")
      .assert(eq, min(u8(3), u8(5)), u8(3))
    .it("max")
      .assert(eq, max(u8(3), u8(5)), u8(5))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u8.clz, 8.u8)
      .assert(eq, 1.u8.clz, 7.u8)
      .assert(eq, 2.u8.clz, 6.u8)
      .assert(eq, 255.u8.clz, 0.u8));

  test.describe("Basic math tests u16")
    .it("add")
      .assert(eq, add(u16(1), u16(2)), u16(3))
    .it("sub")
      .assert(eq, sub(u16(2), u16(1)), u16(1))
    .it("mul")
      .assert(eq, mul(u16(2), u16(1)), u16(2))
    .it("div")
      .assert(eq, div(u16(6), u16(2)), u16(3))
    .it("mod")
      .assert(eq, mod(u16(6), u16(4)), u16(2))
    .it("pow")
      .assert(eq, pow(u16(6), u16(2)), u16(36))
    .it("min")
      .assert(eq, min(u16(3), u16(5)), u16(3))
    .it("max")
      .assert(eq, max(u16(3), u16(5)), u16(5))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u16.clz, 16.u16)
      .assert(eq, 1.u16.clz, 15.u16)
      .assert(eq, 2.u16.clz, 14.u16)
      .assert(eq, 65535.u16.clz, 0.u16));

  test.describe("Basic math tests u32")
    .it("add")
      .assert(eq, 1.u32 + 2.u32, 3.u32)
    .it("sub")
      .assert(eq, 2.u32 - u32(1), 1.u32())
    .it("mul")
      .assert(eq, 2.u32 * 1.u32, 2.u32)
    .it("div")
      .assert(eq, 6.u32 / 2.u32, 3.u32)
    .it("mod")
      .assert(eq, mod(6.u32, 4.u32), 2.u32)
    .it("pow")
      .assert(eq, pow(6.u32, 2.u32), 36.u32)
    .it("min")
      .assert(eq, min(3.u32, 5.u32), 3.u32)
    .it("max")
      .assert(eq, max(3.u32, 5.u32), 5.u32)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u32.clz, 32.u32)
      .assert(eq, 1.u32.clz, 31.u32)
      .assert(eq, 2.u32.clz, 30.u32)
      .assert(eq, 2_147_483_648.u32.clz, 0.u32));

  test.describe("Basic math tests u64")
    .it("add")
      .assert(eq, 1.u64 + 2.u64, 3.u64)
    .it("sub")
      .assert(eq, 2.u64 - u64(1), 1.u64())
    .it("mul")
      .assert(eq, 2.u64 * 1.u64, 2.u64)
    .it("div")
      .assert(eq, 6.u64 / 2.u64, 3.u64)
    .it("mod")
      .assert(eq, 6.u64 % 4.u64, 2.u64)
    .it("pow")
      .assert(eq, 6.u64 ** 2.u64, 36.u64)
    .it("min")
      .assert(eq, min(3.u64, 5.u64), 3.u64)
    .it("max")
      .assert(eq, max(3.u64, 5.u64), 5.u64)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u64.clz, 64.u64)
      .assert(eq, 1.u64.clz, 63.u64)
      .assert(eq, 2.u64.clz, 62.u64));
      // .assert(eq, 9_223_372_036_854_775_808.u64.clz, 0.u64)); TODO: Fix u64 representation

  test.describe("Basic math tests f32")
    .it("add")
      .assert(eq, 1.f32 + 2.f32, 3.f32)
    .it("sub")
      .assert(eq, 2.f32 - f32(1), 1.f32())
    .it("mul")
      .assert(eq, 2.f32 * 1.f32, 2.f32)
    .it("div")
      .assert(eq, 6.f32 / 2.f32, 3.f32)
    .it("sqrt")
      .assert(eq, sqrt(36.f32), 6.f32)
    .it("pow")
      .assert(eq, pow(6.f32, 2.f32), 36.f32)
    .it("min")
      .assert(eq, min(3.f32, 5.f32), 3.f32)
    .it("max")
      .assert(eq, max(3.f32, 5.f32), 5.f32)
    .it("neg")
      .assert(eq, neg(3.f32), -3.f32)
    .it("abs")
      .assert(eq, -3.f32.abs, 3.f32)
    .it("floor")
      .assert(eq, 2.5.f32.floor, 2.f32)
    .it("ceil")
      .assert(eq, 2.5.f32.ceil, 3.f32);

  test.describe("Basic math tests f64")
    .it("add")
      .assert(eq, 1.0 + 2.0, 3.0)
    .it("sub")
      .assert(eq, 2.0 - 1.0, 1.0)
    .it("mul")
      .assert(eq, 2.0 * 1.0, 2.0)
    .it("div")
      .assert(eq, 6.0 / 2.0, 3.0)
    .it("sqrt")
      .assert(eq, sqrt(36.0), 6.0)
    .it("pow")
      .assert(eq, 6.0 ** 2.0, 36.0)
    .it("min")
      .assert(eq, min(3.0, 5.0), 3.0)
    .it("max")
      .assert(eq, max(3.0, 5.0), 5.0)
    .it("neg")
      .assert(eq, - 3.0, -3.0) // These are different, I swear!
    .it("abs")
      .assert(eq, -3.0.abs, 3.0)
    .it("floor")
      .assert(eq, 2.5.floor, 2.0)
    .it("ceil")
      .assert(eq, 2.5.ceil, 3.0);

  test.describe("Basic math tests")
    .it("grouping")
      .assert(eq, 2 / (3), 0)
      .assert(eq, 3 / (1 + 2), 1)
    .it("string min")
      .assert(eq, min(3.string, 5.string), "3")
    .it("string max")
      .assert(eq, max(3.string, 5.string), "5");

    test.report;
}