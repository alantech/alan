fn aNumber(num: i64) {
  return 'I got a number! '.concat(num.string);
}


export fn{Test} main {
  let test = Testing();

  test.describe("Unorganized Tests") // TODO: Find a better grouping for these
    .it("passing ints to functions")
      .assert(eq, aNumber(5), 'I got a number! 5')
    .it("underscores in numbers")
      .assert(eq, 1_000_000 * 2, 2000000)
    .it("other integer syntaxes")
      .assert(eq, 0b10, 2)
      .assert(eq, 0o10, 8)
      .assert(eq, 0x10, 16)
      .assert(eq, 0xF, 15)
    .it("scientific notation")
      .assert(eq, 15.0, 1.5e1)
      .assert(eq, -5.0, -5e0)
      .assert(eq, 1e3, 1000.0)
      .assert(eq, 1e-3, 0.001);

  test.describe("Basic math tests i8")
    .it("add")
      .assert(eq, add(i8(1), i8(2)), i8(3))
    .it("sub")
      .assert(eq, sub(i8(2), i8(1)), i8(1))
    .it("mul")
      .assert(eq, mul(i8(2), i8(1)), i8(2))
    .it("div")
      .assert(eq, div(i8(6), i8(2)), i8(3))
    .it("mod")
      .assert(eq, mod(i8(6), i8(4)), i8(2))
    .it("pow")
      .assert(eq, pow(i8(6), i8(2)), i8(36))
    .it("min")
      .assert(eq, min(i8(3), i8(5)), i8(3))
    .it("max")
      .assert(eq, max(i8(3), i8(5)), i8(5))
    .it("neg")
      .assert(eq, neg(i8(3)), i8(-3))
    .it("abs")
      .assert(eq, abs(i8(-3)), i8(3))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i8.clz, 8.i8)
      .assert(eq, 1.i8.clz, 7.i8)
      .assert(eq, 2.i8.clz, 6.i8)
      .assert(eq, (-128).i8.clz, 0.i8));

  test.describe("Basic math tests i16")
    .it("add")
      .assert(eq, add(i16(1), i16(2)), i16(3))
    .it("sub")
      .assert(eq, sub(i16(2), i16(1)), i16(1))
    .it("mul")
      .assert(eq, mul(i16(2), i16(1)), i16(2))
    .it("div")
      .assert(eq, div(i16(6), i16(2)), i16(3))
    .it("mod")
      .assert(eq, mod(i16(6), i16(4)), i16(2))
    .it("pow")
      .assert(eq, pow(i16(6), i16(2)), i16(36))
    .it("min")
      .assert(eq, min(i16(3), i16(5)), i16(3))
    .it("max")
      .assert(eq, max(i16(3), i16(5)), i16(5))
    .it("neg")
      .assert(eq, neg(i16(3)), i16(-3))
    .it("abs")
      .assert(eq, abs(i16(-3)), i16(3))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i16.clz, 16.i16)
      .assert(eq, 1.i16.clz, 15.i16)
      .assert(eq, 2.i16.clz, 14.i16)
      .assert(eq, (-32768).i16.clz, 0.i16));

  test.describe("Basic math tests i32")
    .it("add")
      .assert(eq, 1.i32 + 2.i32, 3.i32)
    .it("sub")
      .assert(eq, 2.i32 - i32(1), 1.i32())
    .it("mul")
      .assert(eq, 2.i32 * 1.i32, 2.i32)
    .it("div")
      .assert(eq, 6.i32 / 2.i32, 3.i32)
    .it("mod")
      .assert(eq, mod(6.i32, 4.i32), 2.i32)
    .it("pow")
      .assert(eq, pow(6.i32, 2.i32), 36.i32)
    .it("min")
      .assert(eq, min(3.i32, 5.i32), 3.i32)
    .it("max")
      .assert(eq, max(3.i32, 5.i32), 5.i32)
    .it("neg")
      .assert(eq, neg(3.i32), i32(-3))
    .it("abs")
      .assert(eq, abs(-3.i32), 3.i32)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.i32.clz, 32.i32)
      .assert(eq, 1.i32.clz, 31.i32)
      .assert(eq, 2.i32.clz, 30.i32)
      .assert(eq, (-2_147_483_648).i32.clz, 0.i32));

  test.describe("Basic math tests i64")
    .it("add")
      .assert(eq, 1 + 2, 3)
    .it("sub")
      .assert(eq, 2 - 1, 1)
    .it("mul")
      .assert(eq, 2 * 1, 2)
    .it("div")
      .assert(eq, 6 / 2, 3)
    .it("mod")
      .assert(eq, 6 % 4, 2)
    .it("pow")
      .assert(eq, 6 ** 2, 36)
    .it("min")
      .assert(eq, min(3, 5), 3)
    .it("max")
      .assert(eq, max(3, 5), 5)
    .it("neg")
      .assert(eq, neg(3), -3)
    .it("abs")
      .assert(eq, abs(-3), 3)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.clz, 64.i64)
      .assert(eq, 1.clz, 63.i64)
      .assert(eq, 2.i64.clz, 62.i64)
      .assert(eq, -9_223_372_036_854_775_808.clz, 0));

  test.describe("Basic math tests u8")
    .it("add")
      .assert(eq, add(u8(1), u8(2)), u8(3))
    .it("sub")
      .assert(eq, sub(u8(2), u8(1)), u8(1))
    .it("mul")
      .assert(eq, mul(u8(2), u8(1)), u8(2))
    .it("div")
      .assert(eq, div(u8(6), u8(2)), u8(3))
    .it("mod")
      .assert(eq, mod(u8(6), u8(4)), u8(2))
    .it("pow")
      .assert(eq, pow(u8(6), u8(2)), u8(36))
    .it("min")
      .assert(eq, min(u8(3), u8(5)), u8(3))
    .it("max")
      .assert(eq, max(u8(3), u8(5)), u8(5))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u8.clz, 8.u8)
      .assert(eq, 1.u8.clz, 7.u8)
      .assert(eq, 2.u8.clz, 6.u8)
      .assert(eq, 255.u8.clz, 0.u8));

  test.describe("Basic math tests u16")
    .it("add")
      .assert(eq, add(u16(1), u16(2)), u16(3))
    .it("sub")
      .assert(eq, sub(u16(2), u16(1)), u16(1))
    .it("mul")
      .assert(eq, mul(u16(2), u16(1)), u16(2))
    .it("div")
      .assert(eq, div(u16(6), u16(2)), u16(3))
    .it("mod")
      .assert(eq, mod(u16(6), u16(4)), u16(2))
    .it("pow")
      .assert(eq, pow(u16(6), u16(2)), u16(36))
    .it("min")
      .assert(eq, min(u16(3), u16(5)), u16(3))
    .it("max")
      .assert(eq, max(u16(3), u16(5)), u16(5))
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u16.clz, 16.u16)
      .assert(eq, 1.u16.clz, 15.u16)
      .assert(eq, 2.u16.clz, 14.u16)
      .assert(eq, 65535.u16.clz, 0.u16));

  test.describe("Basic math tests u32")
    .it("add")
      .assert(eq, 1.u32 + 2.u32, 3.u32)
    .it("sub")
      .assert(eq, 2.u32 - u32(1), 1.u32())
    .it("mul")
      .assert(eq, 2.u32 * 1.u32, 2.u32)
    .it("div")
      .assert(eq, 6.u32 / 2.u32, 3.u32)
    .it("mod")
      .assert(eq, mod(6.u32, 4.u32), 2.u32)
    .it("pow")
      .assert(eq, pow(6.u32, 2.u32), 36.u32)
    .it("min")
      .assert(eq, min(3.u32, 5.u32), 3.u32)
    .it("max")
      .assert(eq, max(3.u32, 5.u32), 5.u32)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u32.clz, 32.u32)
      .assert(eq, 1.u32.clz, 31.u32)
      .assert(eq, 2.u32.clz, 30.u32)
      .assert(eq, 2_147_483_648.u32.clz, 0.u32));

  test.describe("Basic math tests u64")
    .it("add")
      .assert(eq, 1.u64 + 2.u64, 3.u64)
    .it("sub")
      .assert(eq, 2.u64 - u64(1), 1.u64())
    .it("mul")
      .assert(eq, 2.u64 * 1.u64, 2.u64)
    .it("div")
      .assert(eq, 6.u64 / 2.u64, 3.u64)
    .it("mod")
      .assert(eq, 6.u64 % 4.u64, 2.u64)
    .it("pow")
      .assert(eq, 6.u64 ** 2.u64, 36.u64)
    .it("min")
      .assert(eq, min(3.u64, 5.u64), 3.u64)
    .it("max")
      .assert(eq, max(3.u64, 5.u64), 5.u64)
    .it("clz", fn (test: Mut{Testing}) = test
      .assert(eq, 0.u64.clz, 64.u64)
      .assert(eq, 1.u64.clz, 63.u64)
      .assert(eq, 2.u64.clz, 62.u64));
      // .assert(eq, 9_223_372_036_854_775_808.u64.clz, 0.u64)); TODO: Fix u64 representation

  test.describe("Basic math tests f32")
    .it("add")
      .assert(eq, 1.f32 + 2.f32, 3.f32)
    .it("sub")
      .assert(eq, 2.f32 - f32(1), 1.f32())
    .it("mul")
      .assert(eq, 2.f32 * 1.f32, 2.f32)
    .it("div")
      .assert(eq, 6.f32 / 2.f32, 3.f32)
    .it("sqrt")
      .assert(eq, sqrt(36.f32), 6.f32)
    .it("pow")
      .assert(eq, pow(6.f32, 2.f32), 36.f32)
    .it("min")
      .assert(eq, min(3.f32, 5.f32), 3.f32)
    .it("max")
      .assert(eq, max(3.f32, 5.f32), 5.f32)
    .it("neg")
      .assert(eq, neg(3.f32), -3.f32)
    .it("abs")
      .assert(eq, -3.f32.abs, 3.f32)
    .it("floor")
      .assert(eq, 2.5.f32.floor, 2.f32)
    .it("ceil")
      .assert(eq, 2.5.f32.ceil, 3.f32);

  test.describe("Basic math tests f64")
    .it("add")
      .assert(eq, 1.0 + 2.0, 3.0)
    .it("sub")
      .assert(eq, 2.0 - 1.0, 1.0)
    .it("mul")
      .assert(eq, 2.0 * 1.0, 2.0)
    .it("div")
      .assert(eq, 6.0 / 2.0, 3.0)
    .it("sqrt")
      .assert(eq, sqrt(36.0), 6.0)
    .it("pow")
      .assert(eq, 6.0 ** 2.0, 36.0)
    .it("min")
      .assert(eq, min(3.0, 5.0), 3.0)
    .it("max")
      .assert(eq, max(3.0, 5.0), 5.0)
    .it("neg")
      .assert(eq, - 3.0, -3.0) // These are different, I swear!
    .it("abs")
      .assert(eq, -3.0.abs, 3.0)
    .it("floor")
      .assert(eq, 2.5.floor, 2.0)
    .it("ceil")
      .assert(eq, 2.5.ceil, 3.0);

  test.describe("Basic math tests")
    .it("grouping")
      .assert(eq, 2 / (3), 0)
      .assert(eq, 3 / (1 + 2), 1)
    .it("string min")
      .assert(eq, min(3.string, 5.string), "3")
    .it("string max")
      .assert(eq, max(3.string, 5.string), "5");

  test.describe("Bitwise math test")
    .it("i8")
      .assert(eq, 1.i8 & 2.i8, 0.i8)
      .assert(eq, 1.i8 | 3.i8, 3.i8)
      .assert(eq, 5.i8 ^ 3.i8, 6.i8)
      .assert(eq, !(0.i8), -1.i8)
      .assert(eq, 1.i8 !& 2.i8, -1.i8)
      .assert(eq, 1.i8 !| 2.i8, -4.i8)
      .assert(eq, 5.i8 !^ 3.i8, -7.i8)
    .it("i16")
      .assert(eq, 1.i16 & 2.i16, 0.i16)
      .assert(eq, 1.i16 | 3.i16, 3.i16)
      .assert(eq, 5.i16 ^ 3.i16, 6.i16)
      .assert(eq, !(0.i16), -1.i16)
      .assert(eq, 1.i16 !& 2.i16, -1.i16)
      .assert(eq, 1.i16 !| 2.i16, -4.i16)
      .assert(eq, 5.i16 !^ 3.i16, -7.i16)
    .it("i32")
      .assert(eq, 1.i32 & 2.i32, 0.i32)
      .assert(eq, 1.i32 | 3.i32, 3.i32)
      .assert(eq, 5.i32 ^ 3.i32, 6.i32)
      .assert(eq, !(0.i32), -1.i32)
      .assert(eq, 1.i32 !& 2.i32, -1.i32)
      .assert(eq, 1.i32 !| 2.i32, -4.i32)
      .assert(eq, 5.i32 !^ 3.i32, -7.i32)
    .it("i64")
      .assert(eq, 1 & 2, 0)
      .assert(eq, 1 | 3, 3)
      .assert(eq, 5 ^ 3, 6)
      .assert(eq, !0, -1)
      .assert(eq, 1 !& 2, -1)
      .assert(eq, 1 !| 2, -4)
      .assert(eq, 5 !^ 3, -7)
    .it("u8")
      .assert(eq, 1.u8 & 2.u8, 0.u8)
      .assert(eq, 1.u8 | 3.u8, 3.u8)
      .assert(eq, 5.u8 ^ 3.u8, 6.u8)
      .assert(eq, !(0.u8), 255.u8)
      .assert(eq, 1.u8 !& 2.u8, 255.u8)
      .assert(eq, 1.u8 !| 2.u8, 252.u8)
      .assert(eq, 5.u8 !^ 3.u8, 249.u8)
    .it("u16")
      .assert(eq, 1.u16 & 2.u16, 0.u16)
      .assert(eq, 1.u16 | 3.u16, 3.u16)
      .assert(eq, 5.u16 ^ 3.u16, 6.u16)
      .assert(eq, !(0.u16), 65535.u16)
      .assert(eq, 1.u16 !& 2.u16, 65535.u16)
      .assert(eq, 1.u16 !| 2.u16, 65532.u16)
      .assert(eq, 5.u16 !^ 3.u16, 65529.u16)
    .it("u32")
      .assert(eq, 1.u32 & 2.u32, 0.u32)
      .assert(eq, 1.u32 | 3.u32, 3.u32)
      .assert(eq, 5.u32 ^ 3.u32, 6.u32)
      .assert(eq, !(0.u32), 4_294_967_295.u32)
      .assert(eq, 1.u32 !& 2.u32, 4_294_967_295.u32)
      .assert(eq, 1.u32 !| 2.u32, 4_294_967_292.u32)
      .assert(eq, 5.u32 !^ 3.u32, 4_294_967_289.u32);
    // TODO: Fix u64 numeric constants to get u64 bitwise tests in here

  test.describe("Boolean logic").it("")
    .assert(eq, true, true)
    .assert(eq, false, false)
    .assert(eq, bool(1), true)
    .assert(eq, bool(0), false)
    .assert(eq, bool(15), true)
    .assert(eq, bool(-1), true)
    .assert(eq, bool(0.0), false)
    .assert(eq, bool(1.2), true)
    .assert(eq, bool(''), false)
    .assert(eq, bool('hi'), false)
    .assert(eq, true & true, true)
    .assert(eq, and(true, false), false)
    .assert(eq, false & true, false)
    .assert(eq, false.and(false), false)
    .assert(eq, true | true, true)
    .assert(eq, or(true, false), true)
    .assert(eq, false | true, true)
    .assert(eq, false.or(false), false)
    .assert(eq, true ^ true, false)
    .assert(eq, xor(true, false), true)
    .assert(eq, false ^ true, true)
    .assert(eq, false.xor(false), false)
    .assert(eq, !true, false)
    .assert(eq, not(false), true)
    .assert(eq, true !& true, false)
    .assert(eq, nand(true, false), true)
    .assert(eq, false !& true, true)
    .assert(eq, false.nand(false), true)
    .assert(eq, true !| true, false)
    .assert(eq, nor(true, false), false)
    .assert(eq, false !| true, false)
    .assert(eq, false.nor(false), true)
    .assert(eq, true !^ true, true)
    .assert(eq, xnor(true, false), false)
    .assert(eq, false !^ true, false)
    .assert(eq, false.xnor(false), true);

  test.describe("String Manipulation")
    .it("ops")
      .assert(eq, concat("Hello, ", 'World!'), "Hello, World!")
      .assert(eq, repeat('hi ', 5), 'hi hi hi hi hi ')
      .assert(eq, index('foobar', 'ba')!!, 3)
      .assert(eq, len('foobar'), 6)
      .assert(eq, #'foobar', 6)
      .assert(eq, trim('   hi   '), 'hi')
      .assert(eq, split('Hello, World!', ', ')[0]!!, 'Hello')
      .assert(eq, 'Hello, World!'.split(', ')[1]!!, 'World!')
    .it("const vs computed equality", fn (test: Mut{Testing}) {
      const foo = 'foo';
      test.assert(eq, foo.trim, foo);
    })
    .it("chars access", fn (test: Mut{Testing}) {
      const foo = 'foo';
      // This shouldn't be needed. TODO: Figure out why methods are not loading in all situations
      let huh = Fallible{string}('huh');
      test
        .assert(eq, #foo, 3)
        .assert(eq, foo[0].string.exists, true)
        .assert(eq, foo[0]!!, 'f')
        .assert(eq, foo[1]!!, 'o')
        .assert(eq, foo[2]!!, 'o')
        .assert(eq, foo[3].Error.exists, true);
    });

  test.describe("Comparators")
    .it("equality")
      .assert(eq, i8(0) == i8(0), true)
      .assert(eq, i8(1).eq(i8(0)), false)
      .assert(eq, i16(0) == i16(0), true)
      .assert(eq, i16(1).eq(i16(0)), false)
      .assert(eq, i32(0) == i32(0), true)
      .assert(eq, i32(1).eq(i32(0)), false)
      .assert(eq, 0 == 0, true)
      .assert(eq, 1.eq(0), false)
      .assert(eq, 0.u8 == 0.u8, true)
      .assert(eq, 1.u8.eq(0.u8), false)
      .assert(eq, 0.u16 == 0.u16, true)
      .assert(eq, 1.u16.eq(0.u16), false)
      .assert(eq, 0.u32 == 0.u32, true)
      .assert(eq, 1.u32.eq(0.u32), false)
      .assert(eq, 0.u64 == 0.u64, true)
      .assert(eq, 1.u64.eq(0.u64), false)
      .assert(eq, f32(0.0) == f32(0.0), true)
      .assert(eq, f32(1.0).eq(f32(0.0)), false)
      .assert(eq, 0.0 == 0.0, true)
      .assert(eq, 1.2.eq(0.0), false)
      .assert(eq, true == true, true)
      .assert(eq, true.eq(false), false)
      .assert(eq, 'hello' == 'hello', true)
      .assert(eq, 'hello'.eq('world'), false)
    .it("not equal")
      .assert(eq, i8(0) != i8(0), false)
      .assert(eq, i8(1).neq(i8(0)), true)
      .assert(eq, i16(0) != i16(0), false)
      .assert(eq, i16(1).neq(i16(0)), true)
      .assert(eq, i32(0) != i32(0), false)
      .assert(eq, i32(1).neq(i32(0)), true)
      .assert(eq, 0 != 0, false)
      .assert(eq, 1.neq(0), true)
      .assert(eq, 0.u8 != 0.u8, false)
      .assert(eq, 1.u8.neq(0.u8), true)
      .assert(eq, 0.u16 != 0.u16, false)
      .assert(eq, 1.u16.neq(0.u16), true)
      .assert(eq, 0.u32 != 0.u32, false)
      .assert(eq, 1.u32.neq(0.u32), true)
      .assert(eq, 0.u64 != 0.u64, false)
      .assert(eq, 1.u64.neq(0.u64), true)
      .assert(eq, f32(0.0) != f32(0.0), false)
      .assert(eq, f32(1.0).neq(f32(0.0)), true)
      .assert(eq, 0.0 != 0.0, false)
      .assert(eq, 1.2.neq(0.0), true)
      .assert(eq, true != true, false)
      .assert(eq, true.neq(false), true)
      .assert(eq, 'hello' != 'hello', false)
      .assert(eq, 'hello'.neq('world'), true)
    .it("less than")
      .assert(eq, i8(0) < i8(1), true)
      .assert(eq, i8(1).lt(i8(0)), false)
      .assert(eq, i16(0) < i16(1), true)
      .assert(eq, i16(1).lt(i16(0)), false)
      .assert(eq, i32(0) < i32(1), true)
      .assert(eq, i32(1).lt(i32(0)), false)
      .assert(eq, 0 < 1, true)
      .assert(eq, 1.lt(0), false)
      .assert(eq, 0.u8 < 1.u8, true)
      .assert(eq, 1.u8.lt(0.u8), false)
      .assert(eq, 0.u16 < 1.u16, true)
      .assert(eq, 1.u16.lt(0.u16), false)
      .assert(eq, 0.u32 < 1.u32, true)
      .assert(eq, 1.u32.lt(0.u32), false)
      .assert(eq, 0.u64 < 1.u64, true)
      .assert(eq, 1.u64.lt(0.u64), false)
      .assert(eq, f32(0.0) < f32(1.0), true)
      .assert(eq, f32(1.0).lt(f32(0.0)), false)
      .assert(eq, 0.0 < 1.0, true)
      .assert(eq, 1.2.lt(0.0), false)
      .assert(eq, 'hello' < 'hello', false)
      .assert(eq, 'hello'.lt('world'), true)
    .it("less than or equal to")
      .assert(eq, i8(0) <= i8(1), true)
      .assert(eq, i8(1).lte(i8(0)), false)
      .assert(eq, i16(0) <= i16(1), true)
      .assert(eq, i16(1).lte(i16(0)), false)
      .assert(eq, i32(0) <= i32(1), true)
      .assert(eq, i32(1).lte(i32(0)), false)
      .assert(eq, 0 <= 1, true)
      .assert(eq, 1.lte(0), false)
      .assert(eq, 0.u8 <= 1.u8, true)
      .assert(eq, 1.u8.lte(0.u8), false)
      .assert(eq, 0.u16 <= 1.u16, true)
      .assert(eq, 1.u16.lte(0.u16), false)
      .assert(eq, 0.u32 <= 1.u32, true)
      .assert(eq, 1.u32.lte(0.u32), false)
      .assert(eq, 0.u64 <= 1.u64, true)
      .assert(eq, 1.u64.lte(0.u64), false)
      .assert(eq, f32(0.0) <= f32(1.0), true)
      .assert(eq, f32(1.0).lte(f32(0.0)), false)
      .assert(eq, 0.0 <= 1.0, true)
      .assert(eq, 1.2.lte(0.0), false)
      .assert(eq, 'hello' <= 'hello', true)
      .assert(eq, 'hello'.lte('world'), true)
    .it("greater than")
      .assert(eq, i8(0) > i8(1), false)
      .assert(eq, i8(1).gt(i8(0)), true)
      .assert(eq, i16(0) > i16(1), false)
      .assert(eq, i16(1).gt(i16(0)), true)
      .assert(eq, i32(0) > i32(1), false)
      .assert(eq, i32(1).gt(i32(0)), true)
      .assert(eq, 0 > 1, false)
      .assert(eq, 1.gt(0), true)
      .assert(eq, 0.u8 > 1.u8, false)
      .assert(eq, 1.u8.gt(0.u8), true)
      .assert(eq, 0.u16 > 1.u16, false)
      .assert(eq, 1.u16.gt(0.u16), true)
      .assert(eq, 0.u32 > 1.u32, false)
      .assert(eq, 1.u32.gt(0.u32), true)
      .assert(eq, 0.u64 > 1.u64, false)
      .assert(eq, 1.u64.gt(0.u64), true)
      .assert(eq, f32(0.0) > f32(1.0), false)
      .assert(eq, f32(1.0).gt(f32(0.0)), true)
      .assert(eq, 0.0 > 1.0, false)
      .assert(eq, 1.2.gt(0.0), true)
      .assert(eq, 'hello' > 'hello', false)
      .assert(eq, 'hello'.gt('world'), false)
    .it("greater than or equal to")
      .assert(eq, i8(0) >= i8(1), false)
      .assert(eq, i8(1).gte(i8(0)), true)
      .assert(eq, i16(0) >= i16(1), false)
      .assert(eq, i16(1).gte(i16(0)), true)
      .assert(eq, i32(0) >= i32(1), false)
      .assert(eq, i32(1).gte(i32(0)), true)
      .assert(eq, 0 >= 1, false)
      .assert(eq, 1.gte(0), true)
      .assert(eq, 0.u8 >= 1.u8, false)
      .assert(eq, 1.u8.gte(0.u8), true)
      .assert(eq, 0.u16 >= 1.u16, false)
      .assert(eq, 1.u16.gte(0.u16), true)
      .assert(eq, 0.u32 >= 1.u32, false)
      .assert(eq, 1.u32.gte(0.u32), true)
      .assert(eq, 0.u64 >= 1.u64, false)
      .assert(eq, 1.u64.gte(0.u64), true)
      .assert(eq, f32(0.0) >= f32(1.0), false)
      .assert(eq, f32(1.0).gte(f32(0.0)), true)
      .assert(eq, 0.0 >= 1.0, false)
      .assert(eq, 1.2.gte(0.0), true)
      .assert(eq, 'hello' >= 'hello', true)
      .assert(eq, 'hello'.gte('world'), false);

  test.describe("Bitshifting").it("")
    .assert(eq, 1.i8 >> 1.i8, 0.i8)
    .assert(eq, 1.i8 << 1.i8, 2.i8)
    .assert(eq, 100.i8 >>> 2.i8, 25.i8)
    .assert(eq, 100.i8 <<< 2.i8, -111.i8)
    .assert(eq, shr(1.i16, 1.i16), 0.i16)
    .assert(eq, shl(1.i16, 1.i16), 2.i16)
    .assert(eq, wrr(100.i16, 2.i16), 25.i16)
    .assert(eq, wrl(100.i16, 2.i16), 400.i16)
    .assert(eq, 1.i32.shr(1.i32), 0.i32)
    .assert(eq, 1.i32.shl(1.i32), 2.i32)
    .assert(eq, 100.i32.wrr(2.i32), 25.i32)
    .assert(eq, 100.i32.wrl(2.i32), 400.i32)
    .assert(eq, 1 >> 1, 0)
    .assert(eq, 1 << 1, 2)
    .assert(eq, 100 >>> 2, 25)
    .assert(eq, 100 <<< 2, 400)
    .assert(eq, 1.u8 >> 1.u8, 0.u8)
    .assert(eq, 1.u8 << 1.u8, 2.u8)
    .assert(eq, 100.u8 >>> 2.u8, 25.u8)
    .assert(eq, 100.u8 <<< 2.u8, 145.u8)
    .assert(eq, shr(1.u16, 1.u16), 0.u16)
    .assert(eq, shl(1.u16, 1.u16), 2.u16)
    .assert(eq, wrr(100.u16, 2.u16), 25.u16)
    .assert(eq, wrl(100.u16, 2.u16), 400.u16)
    .assert(eq, 1.u32.shr(1.u32), 0.u32)
    .assert(eq, 1.u32.shl(1.u32), 2.u32)
    .assert(eq, 100.u32.wrr(2.u32), 25.u32)
    .assert(eq, 100.u32.wrl(2.u32), 400.u32)
    .assert(eq, 1.u64 >> 1.u64, 0.u64)
    .assert(eq, 1.u64 << 1.u64, 2.u64)
    .assert(eq, 100.u64 >>> 2.u64, 25.u64)
    .assert(eq, 100.u64 <<< 2.u64, 400.u64);

  test.describe("Arrays")
    .it("accessor and length", fn (test: Mut{Testing}) {
      const arr = '1,2,3'.split(',');
      test
        .assert(eq, arr.len, 3)
        .assert(eq, arr[0]!!, '1')
        .assert(eq, arr[1]!!, '2')
        .assert(eq, arr[2]!!, '3');
    })
    .it("literal syntax", fn (test: Mut{Testing}) {
      const arr1 = Array{i64}(1, 2, 3);
      test
        .assert(eq, arr1[0]!!, 1)
        .assert(eq, arr1[1]!!, 2)
        .assert(eq, arr1[2]!!, 3);
      const arr2 = [4, 5, 6];
      test
        .assert(eq, arr2[0]!!, 4)
        .assert(eq, arr2[1]!!, 5)
        .assert(eq, arr2[2]!!, 6);
    })
    .it("mutable push and pop", fn (test: Mut{Testing}) {
      let arr = Array{i64}();
      arr.push(1);
      arr.push(2);
      arr.push(3);
      test
        .assert(eq, arr[0]!!, 1)
        .assert(eq, arr[1]!!, 2)
        .assert(eq, arr[2]!!, 3)
        .assert(eq, arr.pop!!, 3)
        .assert(eq, arr.pop!!, 2)
        .assert(eq, arr.pop!!, 1)
        .assert(eq, arr.pop.exists, false);
    })
    .it("has", fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test
        .assert(eq, arr.has(3), true)
        .assert(eq, arr.has(4), false)
        .assert(eq, arr.has(fn (t: i64) = t % 2 == 0), true)
        .assert(eq, arr.has(fn (t: i64) = t % 2 == 1), true);
    })
    .it('map', fn (test: Mut{Testing}) {
      const count =  [1, 2, 3, 4, 5]; // Ah, ah ahh!
      const byTwos = count.map(fn (n: i64) = n * 2);
      test
        .assert(eq, count.map(string).join(', '), '1, 2, 3, 4, 5')
        .assert(eq, byTwos.map(string).join(', '), '2, 4, 6, 8, 10');
    })
    .it('repeat', fn (test: Mut{Testing}) {
      const arr = [1, 2, 3].repeat(3);
      test.assert(eq, arr.map(string).join(', '), '1, 2, 3, 1, 2, 3, 1, 2, 3');
    })
    .it('find', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test.assert(eq, arr.find(fn (x: i64) = x % 2 == 1) ?? 0, 1);
    })
    .it('every', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test.assert(eq, arr.every(fn (x: i64) = x % 2 == 1), false);
    })
    .it('some', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test.assert(eq, arr.some(fn (x: i64) = x % 2 == 1), true);
    })
    .it('index', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test.assert(eq, arr.index(fn (x: i64) = x % 2 == 1)!!, 0);
    })
    .it('concat', fn (test: Mut{Testing}) {
      const arr1 = [1, 1, 2, 3, 5, 8];
      const arr2 = [4, 5, 6];
      test.assert(eq, arr1.concat(arr2).map(string).join(', '), '1, 1, 2, 3, 5, 8, 4, 5, 6');
    })
    .it('reduce', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test
        .assert(eq, arr.reduce(add)!!, 20)
        .assert(eq, arr.reduce(min)!!, 1)
        .assert(eq, arr.reduce(max)!!, 8);
    })
    .it('filter', fn (test: Mut{Testing}) {
      const arr = [1, 1, 2, 3, 5, 8];
      test.assert(eq, arr.filter(fn odd(i: i64) = i % 2 == 1).map(string).join(', '), '1, 1, 3, 5');
    })
    .it('store and delete', fn (test: Mut{Testing}) {
      let arr = [1, 2, 5];
      arr.store(2, 3);
      arr[3] = 4;
      test.assert(eq, arr.map(string).join(', '), '1, 2, 3, 4, 5');
      test.assert(eq, arr.delete(4)!!, 5);
      test.assert(eq, arr.map(string).join(', '), '1, 2, 3, 4');
    });

  test.describe("Buffers")
    .it("join", fn (test: Mut{Testing}) {
      const b = {string[2]}("Hello", "World!");
      test.assert(eq, b.join(", "), "Hello, World!");
    })
    .it("map", fn (test: Mut{Testing}) {
      const b = Buffer{i64, 3}(1, 2, 3);
      test
        .assert(eq, b.map(string).join(", "), '1, 2, 3')
        .assert(eq, b.len, 3)
        .assert(eq, b.map(fn double(x: i64) = x * 2).map(string).join(', '), '2, 4, 6')
        .assert(eq, b.map(add).map(string).join(', '), '1, 3, 5');
    })
    .it("reduce", fn (test: Mut{Testing}) {
      const b = {i64[5]}(1, 2, 3, 4, 5);
      test
        .assert(eq, b.reduce(add)!!, 15) // TODO: We can probably get rid of the Fallible here
        .assert(eq, b.map(string).reduce("0", concat), "012345");
    })
    .it("has", fn (test: Mut{Testing}) {
      const b = {i64[6]}(1, 1, 2, 3, 5, 8);
      test
        .assert(eq, b.has(3), true)
        .assert(eq, b.has(4), false)
        .assert(eq, b.has(fn (i: i64) = i % 2 == 0), true)
        .assert(eq, b.has(fn (i: i64) = i % 2 == 1), true);
    })
    .it("find", fn (test: Mut{Testing}) {
      const b = {i64[6]}(1, 1, 2, 3, 5, 8);
      test.assert(eq, b.find(fn (i: i64) = i % 2 == 1) ?? 0, 1);
    })
    .it("every", fn (test: Mut{Testing}) {
      const b = {i64[6]}(1, 1, 2, 3, 5, 8);
      test.assert(eq, b.every(fn (i: i64) = i % 2 == 1), false);
    })
    .it("concat", fn (test: Mut{Testing}) {
      const b = {i64[6]}(1, 1, 2, 3, 5, 8);
      const c = {i64[3]}(4, 5, 6);
      test.assert(eq, b.concat(c).map(string).join(', '), '1, 1, 2, 3, 5, 8, 4, 5, 6');
    })
    .it("repeat", fn (test: Mut{Testing}) {
      const b = {i64[3]}(1, 2, 3).repeat(3);
      test.assert(eq, b.map(string).join(', '), '1, 2, 3, 1, 2, 3, 1, 2, 3');
    })
    .it('store', fn (test: Mut{Testing}) {
      let b = {i64[3]}(1, 2, 5);
      test
        .assert(eq, b.map(string).join(', '), '1, 2, 5')
        .assert(eq, b.store(2, 3)!!, 5)
        .assert(eq, b.map(string).join(', '), '1, 2, 3');
      b[2] = 4;
      test.assert(eq, b.map(string).join(', '), '1, 2, 4');
    });

  test.report;
}