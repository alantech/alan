/**
 * @std/http - Built-in client and server for http
 */

// The InternalRequest type for http requests
type InternalRequest {
  method: string,
  url: string,
  headers: Array<KeyVal<string, string>>,
  body: string,
  connId: int64,
}

// The InternalResponse type for http responses
type InternalResponse {
  status: int64,
  headers: Array<KeyVal<string, string>>,
  body: string,
  connId: int64,
}

// The exposed Request type
export type Request {
  method: string,
  url: string,
  headers: HashMap<string, string>,
  body: string,
}

// The exposed Response type
export type Response {
  status: int64,
  headers: HashMap<string, string>,
  body: string,
  connId: int64,
}

/**
 * HTTP Client
 */

export fn fetch(req: Request): Result<Response> {
  const i = new InternalRequest {
    method: req.method,
    url: req.url,
    headers: req.headers.keyVal,
    body: req.body,
    connId: 0, // Unused by the client
  };
  const ro = httpreq(i);
  if ro.isOk() {
    const o = ro.getR();
    return ok(new Response {
      status: o.status,
      headers: toHashMap(o.headers),
      body: o.body,
      connId: o.connId,
    });
  } else {
    return ro;
  }
}

export fn get(url: string): Result<string> {
  const res = fetch(new Request {
    method: 'GET',
    url: url,
    headers: newHashMap('Content-Length', '0'),
    body: '',
  });
  if res.isOk() {
    const r = res.getR();
    if r.status < 300 {
      return ok(r.body);
    } else {
      return err('Response was not ok');
    }
  } else {
    return res;
  }
}
export fn post(url: string, body: string): Result<string> {
  const res = fetch(new Request {
    method: 'POST',
    url: url,
    headers: newHashMap('Content-Length', body.length().toString()),
    body: body,
  });
  if res.isOk() {
    const r = res.getR();
    if r.status < 300 {
      return ok(r.body);
    } else {
      return err('Response was not ok');
    }
  } else {
    return res;
  }
}
export fn put(url: string, body: string): Result<string> {
  const res = fetch(new Request {
    method: 'PUT',
    url: url,
    headers: newHashMap('Content-Length', body.length().toString()),
    body: body,
  });
  if res.isOk() {
    const r = res.getR();
    if r.status < 300 {
      return ok(r.body);
    } else {
      return err('Response was not ok');
    }
  } else {
    return res;
  }
}
export fn del(url: string): Result<string> {
  const res = fetch(new Request {
    method: 'DELETE',
    url: url,
    headers: newHashMap('Content-Length', '0'),
    body: '',
  });
  if res.isOk() {
    const r = res.getR();
    if r.status < 300 {
      return ok(r.body);
    } else {
      return err('Response was not ok');
    }
  } else {
    return res;
  }
}

/**
 * HTTP Server
 */

// The roll-up Connection type with both
export type Connection {
  req: Request,
  res: Response,
}

// The connection event
export event connection: Connection

// The special connection event with a signature like `event __conn: InternalConnection`
// This wrapper function takes the internal connection object, converts it to the user-friendly
// connection object, and then emits it on a new event for user code to pick up
on __conn fn (conn: InternalRequest) {
  emit connection new Connection {
    req: new Request {
      method: conn.method,
      url: conn.url,
      headers: toHashMap(conn.headers),
      body: conn.body,
    },
    res: new Response {
      status: 200, // If not set by the user, assume they meant it to be good
      headers: newHashMap('Content-Length', '0'), // If not set by the user, assume no data
      body: '', // If not set by the user, assume no data
      connId: conn.connId,
    },
  };
}

// The body function sets the body for a Response, sets the Content-Length header, and retuns the
// Response for chaining needs
export fn body(res: Response, body: string) {
  res.body = body;
  const len = body.length();
  set(res.headers, 'Content-Length', len.toString());
  return res;
}

// The status function sets the status of the response
export fn status(res: Response, status: int64) {
  res.status = status;
  return res;
}

// The send function converts the response object into an internal response object and passed that
// back to the HTTP server. A Result type with either an 'ok' string or an error is returned
export fn send(res: Response): Result<string> {
  const ires = new InternalResponse {
    status: res.status,
    headers: res.headers.keyVal,
    body: res.body,
    connId: res.connId,
  };
  return httpsend(ires);
}