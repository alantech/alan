from @std/app import start, print, eprint, exit
from @std/cmd import exec

/**
 * @std/deps - The entrypoint to install dependencies for an alan program 
 * and define permissions over libraries
 */

type Dependency {
  url: string,
  block: Array<string>,
  fullBlock: Array<string>,
}

type Package {
  std: Array<string>,
  dependencies: Array<Dependency>,
  block: Array<string>,
  fullBlock: Array<string>,
}

type PackageDependency {
  pkg: Package,
  dep: Dependency,
}

// The `install` event
export event install: Package

fn package(): Package {
  const emptyArrStr = new Array<string> [];
  const emptyArrDep = new Array<Dependency> [];
  const pkg = new Package {
    std: emptyArrStr,
    dependencies: emptyArrDep,
    block: emptyArrStr,
    fullBlock: emptyArrStr,
  };
  return pkg;
}

export fn using(pkg: Package, std: Array<string>): Package {
  pkg.std = pkg.std + std;
  return pkg;
}

export fn dependency(pkg: Package, url: string): PackageDependency {
  const emptyArrStr = new Array<string> [];
  const dep = new Dependency {
    url: url,
    block: emptyArrStr,
    fullBlock: emptyArrStr,
  };
  return new PackageDependency {
    pkg: pkg,
    dep: dep,
  };
}

export fn add(pkgd: PackageDependency): Package {
  pkgd.pkg.dependencies.push(pkgd.dep);
  return pkgd.pkg;
}
  
export fn block(pkg: Package, block: string): Package {
  pkg.block.push(block);
  return pkg;
}

export fn block(pkg: Package, block: Array<string>): Package {
  pkg.block = pkg.block + block;
  return pkg;
}

export fn block(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.block.push(block);
  return pkgd;
}

export fn block(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.block = pkgd.dep.block + block;
  return pkgd;
}

export fn fullBlock(pkg: Package, block: string): Package {
  pkg.fullBlock.push(block);
  return pkg;
}

export fn fullBlock(pkg: Package, block: Array<string>): Package {
  pkg.fullBlock = pkg.fullBlock + block;
  return pkg;
}

export fn fullBlock(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.fullBlock.push(fullBlock);
  return pkgd;
}

export fn fullBlock(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.fullBlock = pkgd.dep.fullBlock + block;
  return pkgd;
}

// The `commit` function takes the packge as argument.
// It install all dependencies added and apply necessary blocks.
export fn commit(pkg: Package) {
  // Remove std dep from blacklist
  const blacklist = getBlacklist(pkg.std);
  // Create mocks for blacklisted std libs
  blockStd(blacklist);
  // Download and install each dep
  download(pkg.dependencies);
  // Apply blocks defined for each dependency
  // Block/Enable (based on what we finally decide) depenencies at application level, meaning that mocks will exists at /dependencies/modules/
  emit exit 0;
}

fn getBlacklist(std: Array<string>): Array<string> {
  const stdList = [
    '@std/app', '@std/avmdaemon', '@std/cmd', '@std/datastore', '@std/deps', '@std/http', 
    '@std/httpcommon', '@std/httpserver', '@std/json', '@std/root', '@std/seq', '@std/tcp',
    '@std/tcpserver', '@std/trig',
  ];
  return stdList.filter(fn (a: string) = !(pkg.std.find(fn (b: string) = eq(a,b)).isOk()));
}

fn blockStd(blacklist: Array<string>) {
  const modules = 'modules/';
  exec('mkdir ' + modules);
  const std = 'std/';
  exec('mkdir ' + modules + std);
  blacklist.map(fn (lib: string) {
    const libSplit = lib.split('');
    libSplit.delete(1);
    const lib = libSplit.join('');
    const mock = exec('mkdir ' + modules + lib);
    if mock.exitCode != 0 {
      eprint(mock.stderr);
    }
  });
}

fn download(dependencies: Array<Dependency>) {
  dependencies.map(fn (dep: Dependency) {
    // TODO implement proper error handling
    const remote = dep.url;
    const parts = remote.split('/');
    const repo = parts[length(parts) - 1] || '';
    const group = parts[parts.length() - 2] || '';
    const dest = 'dependencies/' + group + '/' + repo;
    const rm = exec('rm -rf ./' + dest);
    const git = exec('git clone ' + remote + ' ./' + dest);
    print(git.stderr);
    const rm2 = exec('rm -rf ./' + dest + '/.git');
    const maybeRecurse = exec('cd ' + dest + ' && alan install');
  });
}

// Emit the `install` event on app `start`
on start {
  // TODO: optimize to parse the existing dependencies tree, if any, to build up a list of dependencies
  // that are already installed so calls by the user to install them again (assuming the version is identical)
  // are skipped, calls to upgrade or install new dependencies are performed, and then the remaining list
  // of dependencies at the end are removed.
  
  
  // TODO: restore after testing
  // exec('rm -rf dependencies');
  // exec('mkdir dependencies');
  // emit install package();
  package().using(['@std/app']).commit();
}
