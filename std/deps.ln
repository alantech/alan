from @std/app import start, print, exit, eprint
from @std/cmd import exec

/**
 * @std/deps - The entrypoint to install dependencies for an alan program 
 * and define permissions over libraries
 */

type Dependency {
  url: string,
  block: Array<string>,
  fullBlock: Array<string>,
  group: string,
  name: string,
  rev: string,
  remote: string,
}

type RawPackage {
  std: Array<string>,
  dependencies: Array<Dependency>,
  block: Array<string>,
  fullBlock: Array<string>,
}

// Exporting type as alias since could not export the type and used it in this file at the same time
export type Package = RawPackage

type PackageDependency {
  pkg: RawPackage,
  dep: Dependency,
}

// The `install` event
export event install: RawPackage

fn package(): RawPackage {
  let emptyStd = new Array<string> [];
  let emptyBlock = new Array<string> [];
  let emptyFullBlock = new Array<string> [];
  let emptyDep = new Array<Dependency> [];
  let pkg = new RawPackage {
    std: emptyStd,
    dependencies: emptyDep,
    block: emptyBlock,
    fullBlock: emptyFullBlock,
  };
  return pkg;
}

export fn using(pkg: RawPackage, std: Array<string>): RawPackage {
  // Since alan is blocking the re-asignation of pkg.std we create a new object as a work around
  return new RawPackage {
    std: pkg.std + std,
    dependencies: pkg.dependencies,
    block: pkg.block,
    fullBlock: pkg.fullBlock,
  };
}

export fn dependency(pkg: RawPackage, url: string): PackageDependency {
  const emptyBlock = new Array<string> [];
  const emptyFullBlock = new Array<string> [];
  // The dependency url have to follow the git URLs standard https://git-scm.com/docs/git-clone#_git_urls
  // The revisions (branches, tags or SHAs) will be delimited using a # (as npm or other package managers)
  const parts = url.split('#');
  const remote = parts[0] || '';
  const rev = parts[1] || '';
  const remoteParts = remote.split('/');
  const gitRepo = remoteParts[remoteParts.length() - 1] || '';
  const repo = gitRepo.split('.')[0] || '';
  const possibleSSH = remoteParts[remoteParts.length() - 2] || '';
  const possibleSSHParts = possibleSSH.split(':');
  const group = possibleSSHParts[possibleSSHParts.length() - 1] || '';
  const dep = new Dependency {
    url: url,
    block: emptyBlock,
    fullBlock: emptyFullBlock,
    group: group,
    name: repo,
    rev: rev,
    remote: remote,
  };
  return new PackageDependency {
    pkg: pkg,
    dep: dep,
  };
}

export fn add(pkgd: PackageDependency): RawPackage {
  pkgd.pkg.dependencies.push(pkgd.dep);
  return pkgd.pkg;
}
  
export fn block(pkg: RawPackage, block: string): RawPackage {
  pkg.block.push(block);
  return pkg;
}

export fn block(pkg: RawPackage, block: Array<string>): RawPackage {
  pkg.block = pkg.block + block;
  return pkg;
}

export fn block(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.block.push(block);
  return pkgd;
}

export fn block(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.block = pkgd.dep.block + block;
  return pkgd;
}

export fn fullBlock(pkg: RawPackage, block: string): RawPackage {
  pkg.fullBlock.push(block);
  return pkg;
}

export fn fullBlock(pkg: RawPackage, block: Array<string>): RawPackage {
  pkg.fullBlock = pkg.fullBlock + block;
  return pkg;
}

export fn fullBlock(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.fullBlock.push(block);
  return pkgd;
}

export fn fullBlock(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.fullBlock = pkgd.dep.fullBlock + block;
  return pkgd;
}

// The `commit` function takes the packge as argument.
// It install all dependencies added and apply necessary blocks.
export fn commit(pkg: RawPackage) {
  // Remove std dep from blacklist
  const blacklist = getBlacklist(pkg.std);
  // Create mocks for blacklisted std libs
  blockStd(blacklist);
  // Download and install each dep
  downloadDependencies(pkg.dependencies);
  // Apply blocks defined for each dependency
  applyDependencyBlocks(pkg.dependencies);
  // Block lib for all dependencies once.
  blockForAllDependencies(pkg.block, false);
  // Block lib for all dependencies once. If any dependency is mocking it already remove that behaviour.
  blockForAllDependencies(pkg.fullBlock, true);
  emit exit 0;
}

fn getBlacklist(std: Array<string>): Array<string> {
  // TODO: add @std/deps  to this list and handle it on bdd tests
  const stdList = [
    '@std/app', '@std/avmdaemon', '@std/cmd', '@std/datastore', '@std/http', 
    '@std/httpcommon', '@std/httpserver', '@std/json', '@std/seq', '@std/tcp',
    '@std/tcpserver', '@std/trig',
  ];
  return stdList.filter(fn (a: string) = !(pkg.std.find(fn (b: string) = eq(a,b)).isOk()));
}

fn blockStd(blacklist: Array<string>) {
  const dependencies = 'dependencies';
  if !directoryExists(dependencies) {
    makeDirectory(dependencies);
  }
  const modulesPath = [dependencies, 'modules'].join('/');
  if !directoryExists(modulesPath) {
    makeDirectory(modulesPath);
  }
  const stdPath = [modulesPath, 'std'].join('/');
  if !directoryExists(stdPath) {
    makeDirectory(stdPath);
  }
  blacklist.map(fn (lib: string) {
    const cleanedLib = cleanLib(lib);
    makeDirectory(modulesPath + '/' + cleanedLib);
    addMockFile(modulesPath + '/' + cleanedLib + '/index.ln');
  });
}

fn downloadDependencies(dependencies: Array<Dependency>) {
  dependencies.map(fn (dep: Dependency) {
    // TODO implement proper error handling
    const remote = dep.remote;
    const repo = dep.name;
    const group = dep.group;
    const rev = dep.rev;
    const dest = 'dependencies/' + group + '/' + repo;
    const rm = exec('rm -rf ./' + dest);
    const cloneCmd = 'git clone ' + remote + ' ./' + dest;
    const gitClone = exec(cloneCmd + (rev != '' ? (&& ) : ''));
    if gitClone.exitCode != 0 {
      eprint(gitClone.stderr);
    }
    // Print clone result
    print(gitClone.stderr);
    if rev != '' {
      const gitReset = exec('cd ' + dest + ' && git reset --hard ' + rev);
      if gitReset.exitCode != 0 {
        const gitReset = exec('cd ' + dest + ' && git reset --hard origin/' + rev);
        if gitReset.exitCode != 0 {
          eprint(gitReset.stderr);
        }
      }
    }
    const rm2 = exec('rm -rf ./' + dest + '/.git');
    const maybeRecurse = exec('cd ' + dest + ' && alan install');
  });
}

fn applyDependencyBlocks(dependencies: Array<Dependency>) {
  dependencies.map(fn (dep: Dependency) {
    applyDependencyBlock(dep.name, dep.group, dep.block, false);
    applyDependencyBlock(dep.name, dep.group, dep.fullBlock, true);
  });
}

fn applyDependencyBlock(name: string, group: string, blocks: Array<string>, isFullBlock: bool) {
  const dependenciesDir = 'dependencies';
  const modulesDir = 'modules';
  if blocks.length() == 0 {
    return;
  }
  const innerDependenciesModulesPath = [dependenciesDir, group, name, modulesDir].join('/');
  if !directoryExists(innerDependenciesModulesPath) {
    makeDirectory(innerDependenciesModulesPath);
  }
  blocks.map(fn (lib: string) {
    const cleanedLib = cleanLib(lib);
    const libSplit = cleanedLib.split('/');
    const innerGroup = libSplit[0].getOr('');
    const innerName = libSplit[1].getOr('');
    const innerGroupPath = [dependenciesDir, group, name, modulesDir, innerGroup].join('/');
    if !directoryExists(innerGroupPath) {
      makeDirectory(innerGroupPath);
    }
    const innerNamePath = [dependenciesDir, group, name, modulesDir, innerGroup, innerName].join('/');
    if !directoryExists(innerNamePath) {
      makeDirectory(innerNamePath);
      addMockFile(innerNamePath + '/index.ln');
    } else {
      if isFullBlock {
        let mockFile = innerNamePath + '/index.ln';
        if !removeFile(mockFile) {
          mockFile = innerNamePath + '/' + name + '.ln';
          removeFile(mockFile);
        }
        addMockFile(mockFile);
      }
    }
  });
}

fn directoryExists(path: string): bool {
  return exec('stat ' + path).stderr.length() == 0;
}

fn makeDirectory(path: string) {
  exec('mkdir ' + path);
}

fn removeFile(path: string): bool {
  return exec('rm ' + path).stderr.length() == 0;
}

fn listDirectories(path: string): Array<string> {
  return exec('ls ' + path).stdout.split("\n");
}

fn addMockFile(path: string) {
  exec('echo "export const mock = true;" > ' + path);
}

fn cleanLib(lib: string): string {
  if lib.matches('@') && lib.index('@') == 0 {
    const libSplit = lib.split('@');
    return libSplit[1].getOr('');
  } else {
    return lib;
  }
}

fn blockForAllDependencies(blocks: Array<string>, isFullBlock: bool) {
  const dependenciesDir = 'dependencies';
  const modulesDir = 'modules';
  if blocks.length() == 0 {
    return;
  }
  if !directoryExists(dependenciesDir) {
    makeDirectory(dependenciesDir);
  }
  const depenenciesModulesPath = [dependenciesDir, modulesDir].join('/');
  if !directoryExists(depenenciesModulesPath) {
    makeDirectory(depenenciesModulesPath);
  }
  blocks.map(fn (lib: string) {
    const cleanedLib = cleanLib(lib);
    const libSplit = cleanedLib.split('/');
    const innerGroup = libSplit[0].getOr('');
    const innerName = libSplit[1].getOr('');
    const innerGroupPath = [depenenciesModulesPath, innerGroup].join('/');
    if !directoryExists(innerGroupPath) {
      makeDirectory(innerGroupPath);
    }
    const innerNamePath = [innerGroupPath, innerName].join('/');
    if !directoryExists(innerNamePath) {
      makeDirectory(innerNamePath);
      const mockFile = innerNamePath + '/index.ln';
      addMockFile(mockFile);
    } else {
      if isFullBlock {
        const deps = listDirectories(dependenciesDir);
        deps.map(fn (group: string) {
          if group != 'modules' && group != '' {
            const lsGroup = listDirectories([dependenciesDir, group].join('/'));
            lsGroup.map(fn (name: string) {
              if name != '' {
                const path = [dependenciesDir, group, name, modulesDir, innerGroup, innerName].join('/');
                if directoryExists(path) {
                  let mockFile = path + '/index.ln';
                  if !removeFile(mockFile) {
                    mockFile = path + '/' + innerName + '.ln';
                    removeFile(mockFile);
                  }
                  addMockFile(mockFile);
                }
              }
            });
          }
        });
      }
    }
  });
}

// Emit the `install` event on app `start`
on start {
  // TODO: optimize to parse the existing dependencies tree, if any, to build up a list of dependencies
  // that are already installed so calls by the user to install them again (assuming the version is identical)
  // are skipped, calls to upgrade or install new dependencies are performed, and then the remaining list
  // of dependencies at the end are removed.
  exec('rm -rf dependencies');
  exec('mkdir dependencies');
  emit install package();
}
