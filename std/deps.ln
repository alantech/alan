from @std/app import start, print, eprint, exit
from @std/cmd import exec

/**
 * @std/deps - The entrypoint to install dependencies for an alan program 
 * and define permissions over libraries
 */

type Dependency {
  url: string,
  block: Array<string>,
  fullBlock: Array<string>,
  group: string,
  name: string,
}

type Package {
  std: Array<string>,
  dependencies: Array<Dependency>,
  block: Array<string>,
  fullBlock: Array<string>,
}

type PackageDependency {
  pkg: Package,
  dep: Dependency,
}

// The `install` event
export event install: Package

fn package(): Package {
  const emptyArrStr = new Array<string> [];
  const emptyArrDep = new Array<Dependency> [];
  const pkg = new Package {
    std: emptyArrStr,
    dependencies: emptyArrDep,
    block: emptyArrStr,
    fullBlock: emptyArrStr,
  };
  return pkg;
}

export fn using(pkg: Package, std: Array<string>): Package {
  pkg.std = pkg.std + std;
  return pkg;
}

export fn dependency(pkg: Package, url: string): PackageDependency {
  const emptyArrStr = new Array<string> [];
  const parts = url.split('/');
  const repo = parts[length(parts) - 1] || '';
  const group = parts[parts.length() - 2] || '';
  const dep = new Dependency {
    url: url,
    block: emptyArrStr,
    fullBlock: emptyArrStr,
    group: group,
    name: repo,
  };
  return new PackageDependency {
    pkg: pkg,
    dep: dep,
  };
}

export fn add(pkgd: PackageDependency): Package {
  pkgd.pkg.dependencies.push(pkgd.dep);
  return pkgd.pkg;
}
  
export fn block(pkg: Package, block: string): Package {
  pkg.block.push(block);
  return pkg;
}

export fn block(pkg: Package, block: Array<string>): Package {
  pkg.block = pkg.block + block;
  return pkg;
}

export fn block(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.block.push(block);
  return pkgd;
}

export fn block(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.block = pkgd.dep.block + block;
  return pkgd;
}

export fn fullBlock(pkg: Package, block: string): Package {
  pkg.fullBlock.push(block);
  return pkg;
}

export fn fullBlock(pkg: Package, block: Array<string>): Package {
  pkg.fullBlock = pkg.fullBlock + block;
  return pkg;
}

export fn fullBlock(pkgd: PackageDependency, block: string): PackageDependency {
  pkgd.dep.fullBlock.push(fullBlock);
  return pkgd;
}

export fn fullBlock(pkgd: PackageDependency, block: Array<string>): PackageDependency {
  pkgd.dep.fullBlock = pkgd.dep.fullBlock + block;
  return pkgd;
}

// The `commit` function takes the packge as argument.
// It install all dependencies added and apply necessary blocks.
export fn commit(pkg: Package) {
  // Remove std dep from blacklist
  const blacklist = getBlacklist(pkg.std);
  // Create mocks for blacklisted std libs
  blockStd(blacklist);
  // Download and install each dep
  downloadDependencies(pkg.dependencies);
  // Apply blocks defined for each dependency
  applyDependencyBlocks(pkg.dependencies);
  // Block/Enable (based on what we finally decide) depenencies at application level, meaning that mocks will exists at /dependencies/modules/
  emit exit 0;
}

fn getBlacklist(std: Array<string>): Array<string> {
  const stdList = [
    '@std/app', '@std/avmdaemon', '@std/cmd', '@std/datastore', '@std/deps', '@std/http', 
    '@std/httpcommon', '@std/httpserver', '@std/json', '@std/root', '@std/seq', '@std/tcp',
    '@std/tcpserver', '@std/trig',
  ];
  return stdList.filter(fn (a: string) = !(pkg.std.find(fn (b: string) = eq(a,b)).isOk()));
}

fn blockStd(blacklist: Array<string>) {
  const dependencies = 'dependencies/';
  exec('mkdir ' + dependencies);
  const modules = 'modules/';
  exec('mkdir ' + dependencies + modules);
  const std = 'std/';
  exec('mkdir ' + dependencies + modules + std);
  blacklist.map(fn (lib: string) {
    const libSplit = lib.split('');
    libSplit.delete(1);
    const lib = libSplit.join('');
    exec('mkdir ' + dependencies + modules + lib);
  });
}

fn downloadDependencies(dependencies: Array<Dependency>) {
  dependencies.map(fn (dep: Dependency) {
    // TODO implement proper error handling
    const remote = dep.url;
    const repo = dep.name;
    const group = dep.group;
    const dest = 'dependencies/' + group + '/' + repo;
    const rm = exec('rm -rf ./' + dest);
    const git = exec('git clone ' + remote + ' ./' + dest);
    print(git.stderr);
    const rm2 = exec('rm -rf ./' + dest + '/.git');
    const maybeRecurse = exec('cd ' + dest + ' && alan install');
  });
}

fn applyDependencyBlocks(dependencies: Array<Dependency>) {
  dependencies.map(fn (dep: Dependency) {
    applyDependencyBlock(dep.name, dep.group, dep.block);
    // applyDependencyFullBlock(dep.name, dep.group, dep.fullBlock);
  });
}

fn applyDependencyBlock(name: string, group: string, blocks: Array<string>) {
  const dependenciesDir = 'dependencies';
  const modulesDir = 'modules';
  if blocks.length() > 0 {
    const innerDependenciesModulesPath = [dependenciesDir, group, name, modulesDir].join('/');
    if !dirExist(innerDependenciesModulesPath) {
      mkDir(innerDependenciesModulesPath);
    }
    blocks.map(fn (lib: string) {
      const cleanedLib = cleanLib(lib);
      const libSplit = cleanedLib.split('/');
      const innerGroup = libSplit[0].getOr('');
      const innerName = libSplit[1].getOr('');
      const innerGroupPath = [dependenciesDir, group, name, modulesDir, innerGroup].join('/');
      if !dirExist(innerGroupPath) {
        mkDir(innerGroupPath);
      }
      const innerNamePath = [dependenciesDir, group, name, modulesDir, innerGroup, innerName].join('/');
      if !dirExist(innerNamePath) {
        mkDir(innerNamePath);
      }
    });
  }
}

fn dirExist(path: string): bool {
  return exec('stat ' + path).exitCode == 0;
}

fn mkDir(path: string) {
  exec('mkdir ' + path);
}

fn cleanLib(lib: string): string {
  if lib.matches('@') && lib.index('@') == 0 {
    const libSplit = lib.split('');
    libSplit.delete(1);
    return libSplit.join(''); 
  } else {
    return lib;
  }
}

// Emit the `install` event on app `start`
on start {
  // TODO: optimize to parse the existing dependencies tree, if any, to build up a list of dependencies
  // that are already installed so calls by the user to install them again (assuming the version is identical)
  // are skipped, calls to upgrade or install new dependencies are performed, and then the remaining list
  // of dependencies at the end are removed.
  
  
  // TODO: restore after testing
  exec('rm -rf dependencies');
  exec('mkdir dependencies');
  // emit install package();
  package().using(['@std/app']).dependency('https://github.com/alantech/hellodep').block('@std/cmd').add().commit();
}
