/**
 * The root scope. These definitions are automatically available from every module.
 * These are almost entirely wrappers around runtime opcodes to provide a friendlier
 * name and using function dispatch based on input arguments to pick the correct opcode.
 */

// TODO: See about making an export block scope so we don't have to write `export` so much

// Export all of the built-in types
export void
export int8
export int16
export int32
export int64
export float32
export float64
export bool
export string
export function // TODO: Make the function type more explicit than this
export Array
export Error
export Maybe
export Result
export Either

// Type aliasing of int64 and float64 to just int and float, as these are the default types
export type int = int64
export type float = float64

// Default Interfaces
export interface any {}
export interface anythingElse = any // Same as `any` but doesn't match with it
export interface Stringifiable {
  toString(Stringifiable): string,
}
export interface Orderable {
  lt(Orderable, Orderable): bool,
  lte(Orderable, Orderable): bool,
  gt(Orderable, Orderable): bool,
  gte(Orderable, Orderable): bool,
}
export interface canFloat64 {
  toFloat64(canFloat64): float64
}
export interface canInt64 {
  toInt64(canInt64): int64
}

// Type conversion functions
export fn toFloat64(n: int8) = i8f64(n);
export fn toFloat64(n: int16) = i16f64(n);
export fn toFloat64(n: int32) = i32f64(n);
export fn toFloat64(n: int64) = i64f64(n);
export fn toFloat64(n: float32) = f32f64(n);
export fn toFloat64(n: float64) = n;
export fn toFloat64(n: string) = strf64(n);
export fn toFloat64(n: bool) = boolf64(n);

export fn toFloat32(n: int8) = i8f32(n);
export fn toFloat32(n: int16) = i16f32(n);
export fn toFloat32(n: int32) = i32f32(n);
export fn toFloat32(n: int64) = i64f32(n);
export fn toFloat32(n: float32) = n;
export fn toFloat32(n: float64) = f64f32(n);
export fn toFloat32(n: string) = strf32(n);
export fn toFloat32(n: bool) = boolf32(n);

export fn toInt64(n: int8) = i8i64(n);
export fn toInt64(n: int16) = i16i64(n);
export fn toInt64(n: int32) = i32i64(n);
export fn toInt64(n: int64) = n;
export fn toInt64(n: float32) = f32i64(n);
export fn toInt64(n: float64) = f64i64(n);
export fn toInt64(n: string) = stri64(n);
export fn toInt64(n: bool) = booli64(n);

export fn toInt32(n: int8) = i8i32(n);
export fn toInt32(n: int16) = i16i32(n);
export fn toInt32(n: int32) = n;
export fn toInt32(n: int64) = i64i32(n);
export fn toInt32(n: float32) = f32i32(n);
export fn toInt32(n: float64) = f64i32(n);
export fn toInt32(n: string) = stri32(n);
export fn toInt32(n: bool) = booli32(n);

export fn toInt16(n: int8) = i8i16(n);
export fn toInt16(n: int16) = n;
export fn toInt16(n: int32) = i32i16(n);
export fn toInt16(n: int64) = i64i16(n);
export fn toInt16(n: float32) = f32i16(n);
export fn toInt16(n: float64) = f64i16(n);
export fn toInt16(n: string) = stri16(n);
export fn toInt16(n: bool) = booli16(n);

export fn toInt8(n: int8) = n;
export fn toInt8(n: int16) = i16i8(n);
export fn toInt8(n: int32) = i32i8(n);
export fn toInt8(n: int64) = i64i8(n);
export fn toInt8(n: float32) = f32i8(n);
export fn toInt8(n: float64) = f64i8(n);
export fn toInt8(n: string) = stri8(n);
export fn toInt8(n: bool) = booli8(n);

export fn toBool(n: int8) = i8bool(n);
export fn toBool(n: int16) = i16bool(n);
export fn toBool(n: int32) = i32bool(n);
export fn toBool(n: int64) = i64bool(n);
export fn toBool(n: float32) = f32bool(n);
export fn toBool(n: float64) = f64bool(n);
export fn toBool(n: string) = strbool(n);
export fn toBool(n: bool) = n;

export fn toString(n: int8) = i8str(n);
export fn toString(n: int16) = i16str(n);
export fn toString(n: int32) = i32str(n);
export fn toString(n: int64) = i64str(n);
export fn toString(n: float32) = f32str(n);
export fn toString(n: float64) = f64str(n);
export fn toString(n: string) = n;
export fn toString(n: bool) = boolstr(n);

// Type alias conversion functions
export fn toFloat(n: canFloat64): float = toFloat64(n);
export fn toInt(n: canInt64): int = toInt64(n);

// Error, Maybe, Result, and Either types and functions
export error // opcode with signature `fn error(string): Error`
export fn ref(a: any) = refv(a);
export fn ref(a: void) = reff(a);
export fn ref(a: int8) = reff(a);
export fn ref(a: int16) = reff(a);
export fn ref(a: int32) = reff(a);
export fn ref(a: int64) = reff(a);
export fn ref(a: float32) = reff(a);
export fn ref(a: float64) = reff(a);
export fn ref(a: bool) = reff(a);
export noerr // opcode with signature `fn noerr(): Error`
export fn toString(err: Error) = errorstr(err);

export fn some(val: any) = someM(val, 0);
export fn some(val: int8) = someM(val, 8);
export fn some(val: int16) = someM(val, 8);
export fn some(val: int32) = someM(val, 8);
export fn some(val: int64) = someM(val, 8);
export fn some(val: float32) = someM(val, 8);
export fn some(val: float64) = someM(val, 8);
export fn some(val: bool) = someM(val, 8);
export fn none() = noneM();
export isSome // opcode with signature `fn isSome(Maybe<any>): bool`
export isNone // opcode with signature `fn isNone(Maybe<any>): bool`
export fn getOr(maybe: Maybe<any>, default: any) = getOrM(maybe, default);
export fn toString(maybe: Maybe<Stringifiable>): string {
  if maybe.isSome() {
    return maybe.getMaybe().toString();
  } else {
    return 'none';
  }
}
export fn getOrExit(maybe: Maybe<any>): any {
  if maybe.isNone() {
    exitop(1.toInt8());
  } else {
    return maybe.getMaybe();
  }
}

export fn ok(val: any) = okR(val, 0);
export fn ok(val: int8) = okR(val, 8);
export fn ok(val: int16) = okR(val, 8);
export fn ok(val: int32) = okR(val, 8);
export fn ok(val: int64) = okR(val, 8);
export fn ok(val: float32) = okR(val, 8);
export fn ok(val: float64) = okR(val, 8);
export fn ok(val: bool) = okR(val, 8);
export err // opcode with signature `fn err(string): Result<any>`
export isOk // opcode with signature `fn isOk(Result<any>): bool`
export isErr // opcode with signature `fn isErr(Result<any>: bool`
export fn getOr(result: Result<any>, default: any) = getOrR(result, default);
export fn getOr(result: Result<any>, default: string) = getOrRS(result, default);
export getErr // opcode with signature `fn getErr(Result<any>, Error): Error`
export fn toString(n: Result<Stringifiable>): string {
  if n.isOk() {
    return n.getR().toString();
  } else {
    return n.getErr(noerr()).toString();
  }
}
export fn getOrExit(result: Result<any>): any {
  if result.isErr() {
    stderrp(result.getErr(noerr()).toString());
    exitop(1.toInt8());
  } else {
    return result.getR();
  }
}

export fn main(val: any) = mainE(val, 0);
export fn main(val: int8) = mainE(val, 8);
export fn main(val: int16) = mainE(val, 8);
export fn main(val: int32) = mainE(val, 8);
export fn main(val: int64) = mainE(val, 8);
export fn main(val: float32) = mainE(val, 8);
export fn main(val: float64) = mainE(val, 8);
export fn main(val: bool) = mainE(val, 8);
export fn alt(val: any) = altE(val, 0);
export fn alt(val: int8) = altE(val, 8);
export fn alt(val: int16) = altE(val, 8);
export fn alt(val: int32) = altE(val, 8);
export fn alt(val: int64) = altE(val, 8);
export fn alt(val: float32) = altE(val, 8);
export fn alt(val: float64) = altE(val, 8);
export fn alt(val: bool) = altE(val, 8);
export isMain // opcode with signature `fn isMain(Either<any, anythingElse>): bool`
export isAlt // opcode with signature `fn isAlt(Either<any, anythingElse): bool`
export fn getMainOr(either: Either<any, anythingElse>, default: any) = mainOr(either, default);
export fn getAltOr(either: Either<any, anythingElse>, default: anythingElse) = altOr(either, default);
export fn toString(either: Either<Stringifiable, Stringifiable>): string {
  if either.isMain() {
    return either.getMain().toString();
  } else {
    return either.getAlt().toString();
  }
}
export fn getMainOrExit(either: Either<any, anythingElse>): any {
  if either.isAlt() {
    exitop(1.toInt8());
  } else {
    return either.getMain();
  }
}
export fn getAltOrExit(either: Either<any, anythingElse>): any {
  if either.isMain() {
    exitop(1.toInt8());
  } else {
    return either.getAlt();
  }
}

// Arithmetic functions
export fn add(a: int8, b: int8) = addi8(ok(a), ok(b));
export fn add(a: Result<int8>, b: int8) = addi8(a, ok(b));
export fn add(a: int8, b: Result<int8>) = addi8(ok(a), b);
export fn add(a: Result<int8>, b: Result<int8>) = addi8(a, b);
export fn add(a: int16, b: int16) = addi16(ok(a), ok(b));
export fn add(a: Result<int16>, b: int16) = addi16(a, ok(b));
export fn add(a: int16, b: Result<int16>) = addi16(ok(a), b);
export fn add(a: Result<int16>, b: Result<int16>) = addi16(a, b);
export fn add(a: int32, b: int32) = addi32(ok(a), ok(b));
export fn add(a: Result<int32>, b: int32) = addi32(a, ok(b));
export fn add(a: int32, b: Result<int32>) = addi32(ok(a), b);
export fn add(a: Result<int32>, b: Result<int32>) = addi32(a, b);
export fn add(a: int64, b: int64) = addi64(ok(a), ok(b));
export fn add(a: Result<int64>, b: int64) = addi64(a, ok(b));
export fn add(a: int64, b: Result<int64>) = addi64(ok(a), b);
export fn add(a: Result<int64>, b: Result<int64>) = addi64(a, b);
export fn add(a: float32, b: float32) = addf32(ok(a), ok(b));
export fn add(a: Result<float32>, b: float32) = addf32(a, ok(b));
export fn add(a: float32, b: Result<float32>) = addf32(ok(a), b);
export fn add(a: Result<float32>, b: Result<float32>) = addf32(a, b);
export fn add(a: float64, b: float64) = addf64(ok(a), ok(b));
export fn add(a: Result<float64>, b: float64) = addf64(a, ok(b));
export fn add(a: float64, b: Result<float64>) = addf64(ok(a), b);
export fn add(a: Result<float64>, b: Result<float64>) = addf64(a, b);

export fn sub(a: int8, b: int8) = subi8(ok(a), ok(b));
export fn sub(a: Result<int8>, b: int8) = subi8(a, ok(b));
export fn sub(a: int8, b: Result<int8>) = subi8(ok(a), b);
export fn sub(a: Result<int8>, b: Result<int8>) = subi8(a, b);
export fn sub(a: int16, b: int16) = subi16(ok(a), ok(b));
export fn sub(a: Result<int16>, b: int16) = subi16(a, ok(b));
export fn sub(a: int16, b: Result<int16>) = subi16(ok(a), b);
export fn sub(a: Result<int16>, b: Result<int16>) = subi16(a, b);
export fn sub(a: int32, b: int32) = subi32(ok(a), ok(b));
export fn sub(a: Result<int32>, b: int32) = subi32(a, ok(b));
export fn sub(a: int32, b: Result<int32>) = subi32(ok(a), b);
export fn sub(a: Result<int32>, b: Result<int32>) = subi32(a, b);
export fn sub(a: int64, b: int64) = subi64(ok(a), ok(b));
export fn sub(a: Result<int64>, b: int64) = subi64(a, ok(b));
export fn sub(a: int64, b: Result<int64>) = subi64(ok(a), b);
export fn sub(a: Result<int64>, b: Result<int64>) = subi64(a, b);
export fn sub(a: float32, b: float32) = subf32(ok(a), ok(b));
export fn sub(a: Result<float32>, b: float32) = subf32(a, ok(b));
export fn sub(a: float32, b: Result<float32>) = subf32(ok(a), b);
export fn sub(a: Result<float32>, b: Result<float32>) = subf32(a, b);
export fn sub(a: float64, b: float64) = subf64(ok(a), ok(b));
export fn sub(a: Result<float64>, b: float64) = subf64(a, ok(b));
export fn sub(a: float64, b: Result<float64>) = subf64(ok(a), b);
export fn sub(a: Result<float64>, b: Result<float64>) = subf64(a, b);

export fn negate(n: int8) = negi8(n);
export fn negate(n: Result<int8>) {
  if n.isErr() {
    return n;
  }
  return ok(negi8(n.getR()));
}
export fn negate(n: int16) = negi16(n);
export fn negate(n: Result<int16>) {
  if n.isErr() {
    return n;
  }
  return ok(negi16(n.getR()));
}
export fn negate(n: int32) = negi32(n);
export fn negate(n: Result<int32>) {
  if n.isErr() {
    return n;
  }
  return ok(negi32(n.getR()));
}
export fn negate(n: int64) = negi64(n);
export fn negate(n: Result<int64>) {
  if n.isErr() {
    return n;
  }
  return ok(negi64(n.getR()));
}
export fn negate(n: float32) = negf32(n);
export fn negate(n: Result<float32>) {
  if n.isErr() {
    return n;
  }
  return ok(negf32(n.getR()));
}
export fn negate(n: float64) = negf64(n);
export fn negate(n: Result<float64>) {
  if n.isErr() {
    return n;
  }
  return ok(negf64(n.getR()));
}

export fn abs(n: int8) = absi8(n);
export fn abs(n: Result<int8>) {
  if n.isErr() {
    return n;
  }
  return ok(absi8(n.getR()));
}
export fn abs(n: int16) = absi16(n);
export fn abs(n: Result<int16>) {
  if n.isErr() {
    return n;
  }
  return ok(absi16(n.getR()));
}
export fn abs(n: int32) = absi32(n);
export fn abs(n: Result<int32>) {
  if n.isErr() {
    return n;
  }
  return ok(absi32(n.getR()));
}
export fn abs(n: int64) = absi64(n);
export fn abs(n: Result<int64>) {
  if n.isErr() {
    return n;
  }
  return ok(absi64(n.getR()));
}
export fn abs(n: float32) = absf32(n);
export fn abs(n: Result<float32>) {
  if n.isErr() {
    return n;
  }
  return ok(absf32(n.getR()));
}
export fn abs(n: float64) = absf64(n);
export fn abs(n: Result<float64>) {
  if n.isErr() {
    return n;
  }
  return ok(absf64(n.getR()));
}

export fn mul(a: int8, b: int8) = muli8(ok(a), ok(b));
export fn mul(a: Result<int8>, b: int8) = muli8(a, ok(b));
export fn mul(a: int8, b: Result<int8>) = muli8(ok(a), b);
export fn mul(a: Result<int8>, b: Result<int8>) = muli8(a, b);
export fn mul(a: int16, b: int16) = muli16(ok(a), ok(b));
export fn mul(a: Result<int16>, b: int16) = muli16(a, ok(b));
export fn mul(a: int16, b: Result<int16>) = muli16(ok(a), b);
export fn mul(a: Result<int16>, b: Result<int16>) = muli16(a, b);
export fn mul(a: int32, b: int32) = muli32(ok(a), ok(b));
export fn mul(a: Result<int32>, b: int32) = muli32(a, ok(b));
export fn mul(a: int32, b: Result<int32>) = muli32(ok(a), b);
export fn mul(a: Result<int32>, b: Result<int32>) = muli32(a, b);
export fn mul(a: int64, b: int64) = muli64(ok(a), ok(b));
export fn mul(a: Result<int64>, b: int64) = muli64(a, ok(b));
export fn mul(a: int64, b: Result<int64>) = muli64(ok(a), b);
export fn mul(a: Result<int64>, b: Result<int64>) = muli64(a, b);
export fn mul(a: float32, b: float32) = mulf32(ok(a), ok(b));
export fn mul(a: Result<float32>, b: float32) = mulf32(a, ok(b));
export fn mul(a: float32, b: Result<float32>) = mulf32(ok(a), b);
export fn mul(a: Result<float32>, b: Result<float32>) = mulf32(a, b);
export fn mul(a: float64, b: float64) = mulf64(ok(a), ok(b));
export fn mul(a: Result<float64>, b: float64) = mulf64(a, ok(b));
export fn mul(a: float64, b: Result<float64>) = mulf64(ok(a), b);
export fn mul(a: Result<float64>, b: Result<float64>) = mulf64(a, b);

export fn div(a: int8, b: int8) = divi8(ok(a), ok(b));
export fn div(a: Result<int8>, b: int8) = divi8(a, ok(b));
export fn div(a: int8, b: Result<int8>) = divi8(ok(a), b);
export fn div(a: Result<int8>, b: Result<int8>) = divi8(a, b);
export fn div(a: int16, b: int16) = divi16(ok(a), ok(b));
export fn div(a: Result<int16>, b: int16) = divi16(a, ok(b));
export fn div(a: int16, b: Result<int16>) = divi16(ok(a), b);
export fn div(a: Result<int16>, b: Result<int16>) = divi16(a, b);
export fn div(a: int32, b: int32) = divi32(ok(a), ok(b));
export fn div(a: Result<int32>, b: int32) = divi32(a, ok(b));
export fn div(a: int32, b: Result<int32>) = divi32(ok(a), b);
export fn div(a: Result<int32>, b: Result<int32>) = divi32(a, b);
export fn div(a: int64, b: int64) = divi64(ok(a), ok(b));
export fn div(a: Result<int64>, b: int64) = divi64(a, ok(b));
export fn div(a: int64, b: Result<int64>) = divi64(ok(a), b);
export fn div(a: Result<int64>, b: Result<int64>) = divi64(a, b);
export fn div(a: float32, b: float32) = divf32(ok(a), ok(b));
export fn div(a: Result<float32>, b: float32) = divf32(a, ok(b));
export fn div(a: float32, b: Result<float32>) = divf32(ok(a), b);
export fn div(a: Result<float32>, b: Result<float32>) = divf32(a, b);
export fn div(a: float64, b: float64) = divf64(ok(a), ok(b));
export fn div(a: Result<float64>, b: float64) = divf64(a, ok(b));
export fn div(a: float64, b: Result<float64>) = divf64(ok(a), b);
export fn div(a: Result<float64>, b: Result<float64>) = divf64(a, b);

export fn mod(a: int8, b: int8) = modi8(a, b);
export fn mod(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(modi8(a.getR(), b));
}
export fn mod(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(modi8(a, b.getR()));
}
export fn mod(a: Result<int8>, b: Result<int8>) {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(modi8(a.getR(), b.getR()));
}
export fn mod(a: int16, b: int16) = modi16(a, b);
export fn mod(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(modi16(a.getR(), b));
}
export fn mod(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(modi16(a, b.getR()));
}
export fn mod(a: Result<int16>, b: Result<int16>) {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(modi16(a.getR(), b.getR()));
}
export fn mod(a: int32, b: int32) = modi32(a, b);
export fn mod(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(modi32(a.getR(), b));
}
export fn mod(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(modi32(a, b.getR()));
}
export fn mod(a: Result<int32>, b: Result<int32>) {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(modi32(a.getR(), b.getR()));
}
export fn mod(a: int64, b: int64) = modi64(a, b);
export fn mod(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(modi64(a.getR(), b));
}
export fn mod(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(modi64(a, b.getR()));
}
export fn mod(a: Result<int64>, b: Result<int64>) {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(modi64(a.getR(), b.getR()));
}

export fn pow(a: int8, b: int8) = powi8(ok(a), ok(b));
export fn pow(a: Result<int8>, b: int8) = powi8(a, ok(b));
export fn pow(a: int8, b: Result<int8>) = powi8(ok(a), b);
export fn pow(a: Result<int8>, b: Result<int8>) = powi8(a, b);
export fn pow(a: int16, b: int16) = powi16(ok(a), ok(b));
export fn pow(a: Result<int16>, b: int16) = powi16(a, ok(b));
export fn pow(a: int16, b: Result<int16>) = powi16(ok(a), b);
export fn pow(a: Result<int16>, b: Result<int16>) = powi16(a, b);
export fn pow(a: int32, b: int32) = powi32(ok(a), ok(b));
export fn pow(a: Result<int32>, b: int32) = powi32(a, ok(b));
export fn pow(a: int32, b: Result<int32>) = powi32(ok(a), b);
export fn pow(a: Result<int32>, b: Result<int32>) = powi32(a, b);
export fn pow(a: int64, b: int64) = powi64(ok(a), ok(b));
export fn pow(a: Result<int64>, b: int64) = powi64(a, ok(b));
export fn pow(a: int64, b: Result<int64>) = powi64(ok(a), b);
export fn pow(a: Result<int64>, b: Result<int64>) = powi64(a, b);
export fn pow(a: float32, b: float32) = powf32(ok(a), ok(b));
export fn pow(a: Result<float32>, b: float32) = powf32(a, ok(b));
export fn pow(a: float32, b: Result<float32>) = powf32(ok(a), b);
export fn pow(a: Result<float32>, b: Result<float32>) = powf32(a, b);
export fn pow(a: float64, b: float64) = powf64(ok(a), ok(b));
export fn pow(a: Result<float64>, b: float64) = powf64(a, ok(b));
export fn pow(a: float64, b: Result<float64>) = powf64(ok(a), b);
export fn pow(a: Result<float64>, b: Result<float64>) = powf64(a, b);

export fn sqrt(n: float32) = sqrtf32(n);
export fn sqrt(n: Result<float32>) {
  if n.isErr() {
    return n;
  }
  return sqrtf32(n.getR());
}
export fn sqrt(n: float64) = sqrtf64(n);
export fn sqrt(n: Result<float64>) {
  if n.isErr() {
    return n;
  }
  return sqrtf64(n.getR());
}

export fn sadd(a: int8, b: int8) = saddi8(a, b);
export fn sadd(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(saddi8(a.getOrExit(), b));
}
export fn sadd(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(saddi8(a, b.getOrExit()));
}
export fn sadd(a: Result<int8>, b: Result<int8>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddi8(a.getOrExit(), b.getOrExit()));
}
export fn sadd(a: int16, b: int16) = saddi16(a, b);
export fn sadd(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(saddi16(a.getOrExit(), b));
}
export fn sadd(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(saddi16(a, b.getOrExit()));
}
export fn sadd(a: Result<int16>, b: Result<int16>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddi16(a.getOrExit(), b.getOrExit()));
}
export fn sadd(a: int32, b: int32) = saddi32(a, b);
export fn sadd(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(saddi32(a.getOrExit(), b));
}
export fn sadd(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(saddi32(a, b.getOrExit()));
}
export fn sadd(a: Result<int32>, b: Result<int32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddi32(a.getOrExit(), b.getOrExit()));
}
export fn sadd(a: int64, b: int64) = saddi64(a, b);
export fn sadd(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(saddi64(a.getOrExit(), b));
}
export fn sadd(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(saddi64(a, b.getOrExit()));
}
export fn sadd(a: Result<int64>, b: Result<int64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddi64(a.getOrExit(), b.getOrExit()));
}
export fn sadd(a: float32, b: float32) = saddf32(a, b);
export fn sadd(a: Result<float32>, b: float32) {
  if a.isErr() {
    return a;
  }
  return ok(saddf32(a.getOrExit(), b));
}
export fn sadd(a: float32, b: Result<float32>) {
  if b.isErr() {
    return b;
  }
  return ok(saddf32(a, b.getOrExit()));
}
export fn sadd(a: Result<float32>, b: Result<float32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddf32(a.getOrExit(), b.getOrExit()));
}
export fn sadd(a: float64, b: float64) = saddf64(a, b);
export fn sadd(a: Result<float64>, b: float64) {
  if a.isErr() {
    return a;
  }
  return ok(saddf64(a.getOrExit(), b));
}
export fn sadd(a: float64, b: Result<float64>) {
  if b.isErr() {
    return b;
  }
  return ok(saddf64(a, b.getOrExit()));
}
export fn sadd(a: Result<float64>, b: Result<float64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(saddf64(a.getOrExit(), b.getOrExit()));
}

export fn ssub(a: int8, b: int8) = ssubi8(a, b);
export fn ssub(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(ssubi8(a.getOrExit(), b));
}
export fn ssub(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubi8(a, b.getOrExit()));
}
export fn ssub(a: Result<int8>, b: Result<int8>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubi8(a.getOrExit(), b.getOrExit()));
}
export fn ssub(a: int16, b: int16) = ssubi16(a, b);
export fn ssub(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(ssubi16(a.getOrExit(), b));
}
export fn ssub(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubi16(a, b.getOrExit()));
}
export fn ssub(a: Result<int16>, b: Result<int16>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubi16(a.getOrExit(), b.getOrExit()));
}
export fn ssub(a: int32, b: int32) = ssubi32(a, b);
export fn ssub(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(ssubi32(a.getOrExit(), b));
}
export fn ssub(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubi32(a, b.getOrExit()));
}
export fn ssub(a: Result<int32>, b: Result<int32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubi32(a.getOrExit(), b.getOrExit()));
}
export fn ssub(a: int64, b: int64) = ssubi64(a, b);
export fn ssub(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(ssubi64(a.getOrExit(), b));
}
export fn ssub(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubi64(a, b.getOrExit()));
}
export fn ssub(a: Result<int64>, b: Result<int64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubi64(a.getOrExit(), b.getOrExit()));
}
export fn ssub(a: float32, b: float32) = ssubf32(a, b);
export fn ssub(a: Result<float32>, b: float32) {
  if a.isErr() {
    return a;
  }
  return ok(ssubf32(a.getOrExit(), b));
}
export fn ssub(a: float32, b: Result<float32>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubf32(a, b.getOrExit()));
}
export fn ssub(a: Result<float32>, b: Result<float32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubf32(a.getOrExit(), b.getOrExit()));
}
export fn ssub(a: float64, b: float64) = ssubf64(a, b);
export fn ssub(a: Result<float64>, b: float64) {
  if a.isErr() {
    return a;
  }
  return ok(ssubf64(a.getOrExit(), b));
}
export fn ssub(a: float64, b: Result<float64>) {
  if b.isErr() {
    return b;
  }
  return ok(ssubf64(a, b.getOrExit()));
}
export fn ssub(a: Result<float64>, b: Result<float64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(ssubf64(a.getOrExit(), b.getOrExit()));
}

export fn smul(a: int8, b: int8) = smuli8(a, b);
export fn smul(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(smuli8(a.getOrExit(), b));
}
export fn smul(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(smuli8(a, b.getOrExit()));
}
export fn smul(a: Result<int8>, b: Result<int8>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smuli8(a.getOrExit(), b.getOrExit()));
}
export fn smul(a: int16, b: int16) = smuli16(a, b);
export fn smul(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(smuli16(a.getOrExit(), b));
}
export fn smul(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(smuli16(a, b.getOrExit()));
}
export fn smul(a: Result<int16>, b: Result<int16>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smuli16(a.getOrExit(), b.getOrExit()));
}
export fn smul(a: int32, b: int32) = smuli32(a, b);
export fn smul(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(smuli32(a.getOrExit(), b));
}
export fn smul(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(smuli32(a, b.getOrExit()));
}
export fn smul(a: Result<int32>, b: Result<int32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smuli32(a.getOrExit(), b.getOrExit()));
}
export fn smul(a: int64, b: int64) = smuli64(a, b);
export fn smul(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(smuli64(a.getOrExit(), b));
}
export fn smul(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(smuli64(a, b.getOrExit()));
}
export fn smul(a: Result<int64>, b: Result<int64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smuli64(a.getOrExit(), b.getOrExit()));
}
export fn smul(a: float32, b: float32) = smulf32(a, b);
export fn smul(a: Result<float32>, b: float32) {
  if a.isErr() {
    return a;
  }
  return ok(smulf32(a.getOrExit(), b));
}
export fn smul(a: float32, b: Result<float32>) {
  if b.isErr() {
    return b;
  }
  return ok(smulf32(a, b.getOrExit()));
}
export fn smul(a: Result<float32>, b: Result<float32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smulf32(a.getOrExit(), b.getOrExit()));
}
export fn smul(a: float64, b: float64) = smulf64(a, b);
export fn smul(a: Result<float64>, b: float64) {
  if a.isErr() {
    return a;
  }
  return ok(smulf64(a.getOrExit(), b));
}
export fn smul(a: float64, b: Result<float64>) {
  if b.isErr() {
    return b;
  }
  return ok(smulf64(a, b.getOrExit()));
}
export fn smul(a: Result<float64>, b: Result<float64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(smulf64(a.getOrExit(), b.getOrExit()));
}

export fn sdiv(a: int8, b: int8) = sdivi8(a, b);
export fn sdiv(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(sdivi8(a.getOrExit(), b));
}
export fn sdiv(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivi8(a, b.getOrExit()));
}
export fn sdiv(a: Result<int8>, b: Result<int8>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivi8(a.getOrExit(), b.getOrExit()));
}
export fn sdiv(a: int16, b: int16) = sdivi16(a, b);
export fn sdiv(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(sdivi16(a.getOrExit(), b));
}
export fn sdiv(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivi16(a, b.getOrExit()));
}
export fn sdiv(a: Result<int16>, b: Result<int16>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivi16(a.getOrExit(), b.getOrExit()));
}
export fn sdiv(a: int32, b: int32) = sdivi32(a, b);
export fn sdiv(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(sdivi32(a.getOrExit(), b));
}
export fn sdiv(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivi32(a, b.getOrExit()));
}
export fn sdiv(a: Result<int32>, b: Result<int32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivi32(a.getOrExit(), b.getOrExit()));
}
export fn sdiv(a: int64, b: int64) = sdivi64(a, b);
export fn sdiv(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(sdivi64(a.getOrExit(), b));
}
export fn sdiv(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivi64(a, b.getOrExit()));
}
export fn sdiv(a: Result<int64>, b: Result<int64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivi64(a.getOrExit(), b.getOrExit()));
}
export fn sdiv(a: float32, b: float32) = sdivf32(a, b);
export fn sdiv(a: Result<float32>, b: float32) {
  if a.isErr() {
    return a;
  }
  return ok(sdivf32(a.getOrExit(), b));
}
export fn sdiv(a: float32, b: Result<float32>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivf32(a, b.getOrExit()));
}
export fn sdiv(a: Result<float32>, b: Result<float32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivf32(a.getOrExit(), b.getOrExit()));
}
export fn sdiv(a: float64, b: float64) = sdivf64(a, b);
export fn sdiv(a: Result<float64>, b: float64) {
  if a.isErr() {
    return a;
  }
  return ok(sdivf64(a.getOrExit(), b));
}
export fn sdiv(a: float64, b: Result<float64>) {
  if b.isErr() {
    return b;
  }
  return ok(sdivf64(a, b.getOrExit()));
}
export fn sdiv(a: Result<float64>, b: Result<float64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(sdivf64(a.getOrExit(), b.getOrExit()));
}

export fn spow(a: int8, b: int8) = spowi8(a, b);
export fn spow(a: Result<int8>, b: int8) {
  if a.isErr() {
    return a;
  }
  return ok(spowi8(a.getOrExit(), b));
}
export fn spow(a: int8, b: Result<int8>) {
  if b.isErr() {
    return b;
  }
  return ok(spowi8(a, b.getOrExit()));
}
export fn spow(a: Result<int8>, b: Result<int8>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowi8(a.getOrExit(), b.getOrExit()));
}
export fn spow(a: int16, b: int16) = spowi16(a, b);
export fn spow(a: Result<int16>, b: int16) {
  if a.isErr() {
    return a;
  }
  return ok(spowi16(a.getOrExit(), b));
}
export fn spow(a: int16, b: Result<int16>) {
  if b.isErr() {
    return b;
  }
  return ok(spowi16(a, b.getOrExit()));
}
export fn spow(a: Result<int16>, b: Result<int16>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowi16(a.getOrExit(), b.getOrExit()));
}
export fn spow(a: int32, b: int32) = spowi32(a, b);
export fn spow(a: Result<int32>, b: int32) {
  if a.isErr() {
    return a;
  }
  return ok(spowi32(a.getOrExit(), b));
}
export fn spow(a: int32, b: Result<int32>) {
  if b.isErr() {
    return b;
  }
  return ok(spowi32(a, b.getOrExit()));
}
export fn spow(a: Result<int32>, b: Result<int32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowi32(a.getOrExit(), b.getOrExit()));
}
export fn spow(a: int64, b: int64) = spowi64(a, b);
export fn spow(a: Result<int64>, b: int64) {
  if a.isErr() {
    return a;
  }
  return ok(spowi64(a.getOrExit(), b));
}
export fn spow(a: int64, b: Result<int64>) {
  if b.isErr() {
    return b;
  }
  return ok(spowi64(a, b.getOrExit()));
}
export fn spow(a: Result<int64>, b: Result<int64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowi64(a.getOrExit(), b.getOrExit()));
}
export fn spow(a: float32, b: float32) = spowf32(a, b);
export fn spow(a: Result<float32>, b: float32) {
  if a.isErr() {
    return a;
  }
  return ok(spowf32(a.getOrExit(), b));
}
export fn spow(a: float32, b: Result<float32>) {
  if b.isErr() {
    return b;
  }
  return ok(spowf32(a, b.getOrExit()));
}
export fn spow(a: Result<float32>, b: Result<float32>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowf32(a.getOrExit(), b.getOrExit()));
}
export fn spow(a: float64, b: float64) = spowf64(a, b);
export fn spow(a: Result<float64>, b: float64) {
  if a.isErr() {
    return a;
  }
  return ok(spowf64(a.getOrExit(), b));
}
export fn spow(a: float64, b: Result<float64>) {
  if b.isErr() {
    return b;
  }
  return ok(spowf64(a, b.getOrExit()));
}
export fn spow(a: Result<float64>, b: Result<float64>) {
  if a.isErr().or(b.isErr()) {
    return a;
  }
  return ok(spowf64(a.getOrExit(), b.getOrExit()));
}

export fn min(x: Orderable, y: Orderable): Orderable {
  return cond(lte(x, y), [x, y]);
}
export fn max(x: Orderable, y: Orderable): Orderable {
  return cond(gte(x, y), [x, y]);
}

// Boolean and bitwise functions
export fn and(a: int8, b: int8) = andi8(a, b);
export fn and(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(and(a.getR(), b));
}
export fn and(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(and(a, b.getR()));
}
export fn and(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(and(a.getR(), b.getR()));
}
export fn and(a: int16, b: int16) = andi16(a, b);
export fn and(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(and(a.getR(), b));
}
export fn and(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(and(a, b.getR()));
}
export fn and(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(and(a.getR(), b.getR()));
}
export fn and(a: int32, b: int32) = andi32(a, b);
export fn and(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(and(a.getR(), b));
}
export fn and(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(and(a, b.getR()));
}
export fn and(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(and(a.getR(), b.getR()));
}
export fn and(a: int64, b: int64) = andi64(a, b);
export fn and(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(and(a.getR(), b));
}
export fn and(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(and(a, b.getR()));
}
export fn and(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(and(a.getR(), b.getR()));
}
export fn and(a: bool, b: bool) = andbool(a, b);
export fn and(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(and(a.getR(), b));
}
export fn and(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(and(a, b.getR()));
}
export fn and(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(and(a.getR(), b.getR()));
}

export fn or(a: int8, b: int8) = ori8(a, b);
export fn or(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(or(a.getR(), b));
}
export fn or(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(or(a, b.getR()));
}
export fn or(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(or(a.getR(), b.getR()));
}
export fn or(a: int16, b: int16) = ori16(a, b);
export fn or(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(or(a.getR(), b));
}
export fn or(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(or(a, b.getR()));
}
export fn or(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(or(a.getR(), b.getR()));
}
export fn or(a: int32, b: int32) = ori32(a, b);
export fn or(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(or(a.getR(), b));
}
export fn or(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(or(a, b.getR()));
}
export fn or(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(or(a.getR(), b.getR()));
}
export fn or(a: int64, b: int64) = ori64(a, b);
export fn or(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(or(a.getR(), b));
}
export fn or(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(or(a, b.getR()));
}
export fn or(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(or(a.getR(), b.getR()));
}
export fn or(a: bool, b: bool) = orbool(a, b);
export fn or(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(or(a.getR(), b));
}
export fn or(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(or(a, b.getR()));
}
export fn or(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(or(a.getR(), b.getR()));
}
// This aliasing is for operator definition purposes only
export fn boolor(a: bool, b: bool) = orbool(a, b);
export fn boolor(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(boolor(a.getR(), b));
}
export fn boolor(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(boolor(a, b.getR()));
}
export fn boolor(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(boolor(a.getR(), b.getR()));
}

export fn xor(a: int8, b: int8) = xori8(a, b);
export fn xor(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(xor(a.getR(), b));
}
export fn xor(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(xor(a, b.getR()));
}
export fn xor(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xor(a.getR(), b.getR()));
}
export fn xor(a: int16, b: int16) = xori16(a, b);
export fn xor(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(xor(a.getR(), b));
}
export fn xor(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(xor(a, b.getR()));
}
export fn xor(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xor(a.getR(), b.getR()));
}
export fn xor(a: int32, b: int32) = xori32(a, b);
export fn xor(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(xor(a.getR(), b));
}
export fn xor(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(xor(a, b.getR()));
}
export fn xor(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xor(a.getR(), b.getR()));
}
export fn xor(a: int64, b: int64) = xori64(a, b);
export fn xor(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(xor(a.getR(), b));
}
export fn xor(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(xor(a, b.getR()));
}
export fn xor(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xor(a.getR(), b.getR()));
}
export fn xor(a: bool, b: bool) = xorbool(a, b);
export fn xor(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(xor(a.getR(), b));
}
export fn xor(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(xor(a, b.getR()));
}
export fn xor(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xor(a.getR(), b.getR()));
}

export fn not(n: int8) = noti8(n);
export fn not(n: Result<int8>): Result<int8> {
  if n.isErr() {
    return n;
  }
  return ok(not(n.getR()));
}
export fn not(n: int16) = noti16(n);
export fn not(n: Result<int16>): Result<int16> {
  if n.isErr() {
    return n;
  }
  return ok(not(n.getR()));
}
export fn not(n: int32) = noti32(n);
export fn not(n: Result<int32>): Result<int32> {
  if n.isErr() {
    return n;
  }
  return ok(not(n.getR()));
}
export fn not(n: int64) = noti64(n);
export fn not(n: Result<int64>): Result<int64> {
  if n.isErr() {
    return n;
  }
  return ok(not(n.getR()));
}
export fn not(n: bool) = notbool(n);
export fn not(n: Result<bool>): Result<bool> {
  if n.isErr() {
    return n;
  }
  return ok(not(n.getR()));
}

export fn nand(a: int8, b: int8) = nandi8(a, b);
export fn nand(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(nand(a.getR(), b));
}
export fn nand(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(nand(a, b.getR()));
}
export fn nand(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nand(a.getR(), b.getR()));
}
export fn nand(a: int16, b: int16) = nandi16(a, b);
export fn nand(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(nand(a.getR(), b));
}
export fn nand(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(nand(a, b.getR()));
}
export fn nand(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nand(a.getR(), b.getR()));
}
export fn nand(a: int32, b: int32) = nandi32(a, b);
export fn nand(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(nand(a.getR(), b));
}
export fn nand(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(nand(a, b.getR()));
}
export fn nand(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nand(a.getR(), b.getR()));
}
export fn nand(a: int64, b: int64) = nandi64(a, b);
export fn nand(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(nand(a.getR(), b));
}
export fn nand(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(nand(a, b.getR()));
}
export fn nand(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nand(a.getR(), b.getR()));
}
export fn nand(a: bool, b: bool) = nandboo(a, b);
export fn nand(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(nand(a.getR(), b));
}
export fn nand(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(nand(a, b.getR()));
}
export fn nand(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nand(a.getR(), b.getR()));
}

export fn nor(a: int8, b: int8) = nori8(a, b);
export fn nor(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(nor(a.getR(), b));
}
export fn nor(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(nor(a, b.getR()));
}
export fn nor(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nor(a.getR(), b.getR()));
}
export fn nor(a: int16, b: int16) = nori16(a, b);
export fn nor(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(nor(a.getR(), b));
}
export fn nor(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(nor(a, b.getR()));
}
export fn nor(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nor(a.getR(), b.getR()));
}
export fn nor(a: int32, b: int32) = nori32(a, b);
export fn nor(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(nor(a.getR(), b));
}
export fn nor(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(nor(a, b.getR()));
}
export fn nor(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nor(a.getR(), b.getR()));
}
export fn nor(a: int64, b: int64) = nori64(a, b);
export fn nor(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(nor(a.getR(), b));
}
export fn nor(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(nor(a, b.getR()));
}
export fn nor(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nor(a.getR(), b.getR()));
}
export fn nor(a: bool, b: bool) = norbool(a, b);
export fn nor(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(nor(a.getR(), b));
}
export fn nor(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(nor(a, b.getR()));
}
export fn nor(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(nor(a.getR(), b.getR()));
}

export fn xnor(a: int8, b: int8) = xnori8(a, b);
export fn xnor(a: Result<int8>, b: int8): Result<int8> {
  if a.isErr() {
    return a;
  }
  return ok(xnor(a.getR(), b));
}
export fn xnor(a: int8, b: Result<int8>): Result<int8> {
  if b.isErr() {
    return b;
  }
  return ok(xnor(a, b.getR()));
}
export fn xnor(a: Result<int8>, b: Result<int8>): Result<int8> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xnor(a.getR(), b.getR()));
}
export fn xnor(a: int16, b: int16) = xnori16(a, b);
export fn xnor(a: Result<int16>, b: int16): Result<int16> {
  if a.isErr() {
    return a;
  }
  return ok(xnor(a.getR(), b));
}
export fn xnor(a: int16, b: Result<int16>): Result<int16> {
  if b.isErr() {
    return b;
  }
  return ok(xnor(a, b.getR()));
}
export fn xnor(a: Result<int16>, b: Result<int16>): Result<int16> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xnor(a.getR(), b.getR()));
}
export fn xnor(a: int32, b: int32) = xnori32(a, b);
export fn xnor(a: Result<int32>, b: int32): Result<int32> {
  if a.isErr() {
    return a;
  }
  return ok(xnor(a.getR(), b));
}
export fn xnor(a: int32, b: Result<int32>): Result<int32> {
  if b.isErr() {
    return b;
  }
  return ok(xnor(a, b.getR()));
}
export fn xnor(a: Result<int32>, b: Result<int32>): Result<int32> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xnor(a.getR(), b.getR()));
}
export fn xnor(a: int64, b: int64) = xnori64(a, b);
export fn xnor(a: Result<int64>, b: int64): Result<int64> {
  if a.isErr() {
    return a;
  }
  return ok(xnor(a.getR(), b));
}
export fn xnor(a: int64, b: Result<int64>): Result<int64> {
  if b.isErr() {
    return b;
  }
  return ok(xnor(a, b.getR()));
}
export fn xnor(a: Result<int64>, b: Result<int64>): Result<int64> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xnor(a.getR(), b.getR()));
}
export fn xnor(a: bool, b: bool) = xnorboo(a, b);
export fn xnor(a: Result<bool>, b: bool): Result<bool> {
  if a.isErr() {
    return a;
  }
  return ok(xnor(a.getR(), b));
}
export fn xnor(a: bool, b: Result<bool>): Result<bool> {
  if b.isErr() {
    return b;
  }
  return ok(xnor(a, b.getR()));
}
export fn xnor(a: Result<bool>, b: Result<bool>): Result<bool> {
  if a.isErr() {
    return a;
  }
  if b.isErr() {
    return b;
  }
  return ok(xnor(a.getR(), b.getR()));
}

// Equality and order functions
// TODO: Similarly, should equality/orderability functions accept Result-wrapped values?
export fn eq(a: int8, b: int8) = eqi8(a, b);
export fn eq(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: int16, b: int16) = eqi16(a, b);
export fn eq(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: int32, b: int32) = eqi32(a, b);
export fn eq(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: int64, b: int64) = eqi64(a, b);
export fn eq(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: float32, b: float32) = eqf32(a, b);
export fn eq(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: float64, b: float64) = eqf64(a, b);
export fn eq(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: string, b: string) = eqstr(a, b);
export fn eq(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}
export fn eq(a: bool, b: bool) = eqbool(a, b);
export fn eq(a: Result<bool>, b: bool): bool {
  if a.isErr() {
    return false;
  }
  return eq(a.getR(), b);
}
export fn eq(a: bool, b: Result<bool>): bool {
  if b.isErr() {
    return false;
  }
  return eq(a, b.getR());
}
export fn eq(a: Result<bool>, b: Result<bool>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return eq(a.getR(), b.getR());
}

export fn neq(a: int8, b: int8) = neqi8(a, b);
export fn neq(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: int16, b: int16) = neqi16(a, b);
export fn neq(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: int32, b: int32) = neqi32(a, b);
export fn neq(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: int64, b: int64) = neqi64(a, b);
export fn neq(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: float32, b: float32) = neqf32(a, b);
export fn neq(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: float64, b: float64) = neqf64(a, b);
export fn neq(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: string, b: string) = neqstr(a, b);
export fn neq(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}
export fn neq(a: bool, b: bool) = neqbool(a, b);
export fn neq(a: Result<bool>, b: bool): bool {
  if a.isErr() {
    return false;
  }
  return neq(a.getR(), b);
}
export fn neq(a: bool, b: Result<bool>): bool {
  if b.isErr() {
    return false;
  }
  return neq(a, b.getR());
}
export fn neq(a: Result<bool>, b: Result<bool>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return neq(a.getR(), b.getR());
}

export fn lt(a: int8, b: int8) = lti8(a, b);
export fn lt(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: int16, b: int16) = lti16(a, b);
export fn lt(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: int32, b: int32) = lti32(a, b);
export fn lt(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: int64, b: int64) = lti64(a, b);
export fn lt(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: float32, b: float32) = ltf32(a, b);
export fn lt(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: float64, b: float64) = ltf64(a, b);
export fn lt(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}
export fn lt(a: string, b: string) = ltstr(a, b);
export fn lt(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return lt(a.getR(), b);
}
export fn lt(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return lt(a, b.getR());
}
export fn lt(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lt(a.getR(), b.getR());
}

export fn lte(a: int8, b: int8) = ltei8(a, b);
export fn lte(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: int16, b: int16) = ltei16(a, b);
export fn lte(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: int32, b: int32) = ltei32(a, b);
export fn lte(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: int64, b: int64) = ltei64(a, b);
export fn lte(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: float32, b: float32) = ltef32(a, b);
export fn lte(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: float64, b: float64) = ltef64(a, b);
export fn lte(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}
export fn lte(a: string, b: string) = ltestr(a, b);
export fn lte(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return lte(a.getR(), b);
}
export fn lte(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return lte(a, b.getR());
}
export fn lte(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return lte(a.getR(), b.getR());
}

export fn gt(a: int8, b: int8) = gti8(a, b);
export fn gt(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: int16, b: int16) = gti16(a, b);
export fn gt(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: int32, b: int32) = gti32(a, b);
export fn gt(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: int64, b: int64) = gti64(a, b);
export fn gt(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: float32, b: float32) = gtf32(a, b);
export fn gt(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: float64, b: float64) = gtf64(a, b);
export fn gt(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}
export fn gt(a: string, b: string) = gtstr(a, b);
export fn gt(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return gt(a.getR(), b);
}
export fn gt(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return gt(a, b.getR());
}
export fn gt(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gt(a.getR(), b.getR());
}

export fn gte(a: int8, b: int8) = gtei8(a, b);
export fn gte(a: Result<int8>, b: int8): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: int8, b: Result<int8>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<int8>, b: Result<int8>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: int16, b: int16) = gtei16(a, b);
export fn gte(a: Result<int16>, b: int16): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: int16, b: Result<int16>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<int16>, b: Result<int16>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: int32, b: int32) = gtei32(a, b);
export fn gte(a: Result<int32>, b: int32): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: int32, b: Result<int32>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<int32>, b: Result<int32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: int64, b: int64) = gtei64(a, b);
export fn gte(a: Result<int64>, b: int64): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: int64, b: Result<int64>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<int64>, b: Result<int64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: float32, b: float32) = gtef32(a, b);
export fn gte(a: Result<float32>, b: float32): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: float32, b: Result<float32>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<float32>, b: Result<float32>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: float64, b: float64) = gtef64(a, b);
export fn gte(a: Result<float64>, b: float64): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: float64, b: Result<float64>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<float64>, b: Result<float64>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}
export fn gte(a: string, b: string) = gtestr(a, b);
export fn gte(a: Result<string>, b: string): bool {
  if a.isErr() {
    return false;
  }
  return gte(a.getR(), b);
}
export fn gte(a: string, b: Result<string>): bool {
  if b.isErr() {
    return false;
  }
  return gte(a, b.getR());
}
export fn gte(a: Result<string>, b: Result<string>): bool {
  if or(a.isErr(), b.isErr()) {
    return false;
  }
  return gte(a.getR(), b.getR());
}

// Wait functions
export fn wait(n: int8) = waitop(i8i64(n));
export fn wait(n: int16) = waitop(i16i64(n));
export fn wait(n: int32) = waitop(i32i64(n));
export fn wait(n: int64) = waitop(n);

// String functions
export fn concat(a: string, b: string) = catstr(a, b);
export split // opcode with signature `fn split(str: string, spl: string): Array<string>`
export fn repeat(s: string, n: int64) = repstr(s, n);
// export fn template(str: string, map: Map<string, string>) = templ(str, map)
export matches // opcode with signature `fn matches(s: string, t: string): bool`
export fn index(s: string, t: string) = indstr(s, t);
export fn length(s: string) = lenstr(s);
export trim // opcode with signature `fn trim(s: string): string`
// toCharArray would be better as an opcode, but this works for now.
export fn toCharArray(a: string): Array<string> = a.split('').filter(fn (c: string) = c.length().gt(0));

// Array functions
export fn concat(a: Array<any>, b: Array<any>) = catarr(a, b);
export fn repeat(arr: Array<any>, n: int64) = reparr(arr, n);
export fn index(arr: Array<any>, val: any) = indarrv(arr, val);
export fn index(arr: Array<int8>, val: int8) = indarrf(arr, val);
export fn index(arr: Array<int16>, val: int16) = indarrf(arr, val);
export fn index(arr: Array<int32>, val: int32) = indarrf(arr, val);
export fn index(arr: Array<int64>, val: int64) = indarrf(arr, val);
export fn index(arr: Array<float32>, val: float32) = indarrf(arr, val);
export fn index(arr: Array<float64>, val: float64) = indarrf(arr, val);
export fn index(arr: Array<bool>, val: bool) = indarrf(arr, val);
export fn has(arr: Array<any>, val: any) = indarrv(arr, val).isOk();
export fn has(arr: Array<int8>, val: int8) = indarrf(arr, val).isOk();
export fn has(arr: Array<int16>, val: int16) = indarrf(arr, val).isOk();
export fn has(arr: Array<int32>, val: int32) = indarrf(arr, val).isOk();
export fn has(arr: Array<int64>, val: int64) = indarrf(arr, val).isOk();
export fn has(arr: Array<float32>, val: float32) = indarrf(arr, val).isOk();
export fn has(arr: Array<float64>, val: float64) = indarrf(arr, val).isOk();
export fn has(arr: Array<bool>, val: bool) = indarrf(arr, val).isOk();
export fn length(arr: Array<any>) = lenarr(arr);
export fn push(arr: Array<any>, val: any) {
  pusharr(arr, val, 0);
  return arr;
}
export fn push(arr: Array<int8>, val: int8) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<int16>, val: int16) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<int32>, val: int32) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<int64>, val: int64) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<float32>, val: float32) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<float64>, val: float64) {
  pusharr(arr, val, 8);
  return arr;
}
export fn push(arr: Array<bool>, val: bool) {
  pusharr(arr, val, 8);
  return arr;
}
export fn pop(arr: Array<any>) = poparr(arr);
export each // parallel opcode with signature `fn each(arr: Array<any>, cb: function): void`
export fn eachLin(arr: Array<any>, cb: function): void = eachl(arr, cb);
export map // parallel opcode with signature `fn map(arr: Array<any>, cb: function): Array<any>`
export fn mapLin(arr: Array<any>, cb: function): Array<anythingElse> = mapl(arr, cb);
/**
 * Unlike the other array functions, reduce is sequential by default and parallelism must be opted
 * in. This is due to the fact that parallelism requires the reducer function to be commutative or
 * associative, otherwise it will return different values on each run, and the compiler has no way
 * to guarantee that your reducer function is commutative or associative.
 *
 * There are four reduce functions instead of two as expected, because a reducer that reduces into
 * the same datatype requires less work than one that reduces into a new datatype. To reduce into a
 * new datatype you need an initial value in that new datatype that the reducer can provide to the
 * first reduction call to "get the ball rolling." And there are extra constraints if you want the
 * reducer to run in parallel: that initial value will be used multiple times for each of the
 * parallel threads of computation, so that initial value has to be idempotent for it to work. Then
 * you're left with multiple reduced results that cannot be combined with each other with the main
 * reducer, so you need to provide a second reducer function that takes the resulting datatype and
 * can combine them with each other successfully, and that one *also* needs to be a commutative or
 * associative function.
 *
 * The complexities involved in writing a parallel reducer are why we decided to make the sequential
 * version the default, as the extra overhead is not something most developers are used to, whether
 * they hail from the functional programming world or the imperative world.
 *
 * On that note, you'll notice that the opcodes are named after `reduce` and `fold`. This is the
 * naming scheme that functional language programmers would be used to, but Java and Javascript
 * combined them both as `reduce`, so we have maintained that convention as we expect fewer people
 * needing to adapt to that change, it being a change they're likely already familiar with, and
 * noting that an extra argument that makes it equivalent to `fold` is easier than trying to find
 * the 3 or 4 arg variant under a different name.
 */
export fn reduce(arr: Array<any>, cb: function): any = reducel(arr, cb);
export fn reducePar(arr: Array<any>, cb: function): any = reducep(arr, cb);
/**
 * This type is used to reduce the number of arguments passed to the opcodes, which can only take 2
 * arguments if they return a value, or 3 arguments if they are a side-effect-only opcode, and is an
 * implementation detail of the 3 and 4 arg reduce functions.
 */
type InitialReduce<T, U> {
  arr: Array<T>,
  initial: U,
}
export fn reduce(arr: Array<any>, cb: function, initial: anythingElse): anythingElse {
  const args = new InitialReduce<any, anythingElse> {
    arr: arr,
    initial: initial,
  };
  return foldl(args, cb);
}
export fn reducePar(arr: Array<any>, transformer: function, merger: function, initial: anythingElse): anythingElse {
  const args = new InitialReduce<any, anythingElse> {
    arr: arr,
    initial: initial,
  };
  const intermediate = new Array<any> [foldl(args, transformer)];
  return reducep(intermediate, merger);
}
export filter // opcode with signature `fn filter(arr: Array<any>, cb: function): Array<any>`
export find // opcode with signature `fn find(arr: Array<any>, cb: function): Result<any>`
export fn findLin(arr: Array<any>, cb: function): Result<any> = findl(arr, cb);
export every // parallel opcode with signature `fn every(arr: Array<any>, cb: function): bool`
export fn everyLin(arr: Array<any>, cb: function): bool = everyl(arr, cb);
export some // parallel opcode with signature `fn some(arr: Array<any>, cb: function): bool`
export fn someLin(arr: Array<any>, cb: function): bool = somel(arr, cb);
export join // opcode with signature `fn join(arr: Array<string>, sep: string): string`
export fn delete(arr: Array<any>, idx: int64): Result<any> = delindx(arr, idx);
export fn delete(arr: Array<any>, idx: Result<int64>): Result<any> {
  if idx.isErr() {
    return idx;
  }
  return delindx(arr, idx.getR());
}
export fn set(arr: Array<any>, idx: int64, val: any) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytov(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<int8>, idx: int64, val: int8) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<int16>, idx: int64, val: int16) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<int32>, idx: int64, val: int32) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<int64>, idx: int64, val: int64) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<float32>, idx: int64, val: float32) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<float64>, idx: int64, val: float64) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn set(arr: Array<bool>, idx: int64, val: bool) {
  if (idx < 0) | (idx > arr.length()) {
    return err('array out-of-bounds access');
  } else {
    copytof(arr, idx, val);
    return some(arr);
  }
}
export fn toString(arr: Array<Stringifiable>): string {
  const strings = arr.map(toString);
  return '[' + strings.join(', ') + ']';
}

// Ternary functions
export fn pair(trueval: any, falseval: any) = new Array<any> [ trueval, falseval ];
export fn cond(c: bool, options: Array<any>) = getR(options[1.sub(c.toInt64())]);
export fn cond(c: bool, optional: function): void = condfn(c, optional);

// "clone" function useful for hoisting assignments and making duplicates
export fn clone(a: any) = copyarr(a);
export fn clone(a: Array<any>) = copyarr(a);
export fn clone(a: void) = copyvoid(a); // TODO: Eliminate this, covering up a weird error
export fn clone() = zeroed(); // TODO: Used for conditionals, eliminate with more clever compiler
export fn clone(a: int8) = copyi8(a);
export fn clone(a: int16) = copyi16(a);
export fn clone(a: int32) = copyi32(a);
export fn clone(a: int64) = copyi64(a);
export fn clone(a: float32) = copyf32(a);
export fn clone(a: float64) = copyf64(a);
export fn clone(a: bool) = copybool(a);
export fn clone(a: string) = copystr(a);

// toHash functions for all data types
export fn toHash(val: any) = hashv(val);
export fn toHash(val: int8) = hashf(val);
export fn toHash(val: int16) = hashf(val);
export fn toHash(val: int32) = hashf(val);
export fn toHash(val: int64) = hashf(val);
export fn toHash(val: float32) = hashf(val);
export fn toHash(val: float64) = hashf(val);
export fn toHash(val: bool) = hashf(val);

// HashMap implementation
export type KeyVal<K, V> {
  key: K,
  val: V,
}

export interface Hashable {
  toHash(Hashable): int64,
  eq(Hashable, Hashable): bool,
}

export type HashMap<K, V> {
  keyVal: Array<KeyVal<K, V>>,
  lookup: Array<Array<int64>>,
}

export fn keyVal(hm: HashMap<Hashable, any>) = hm.keyVal;
export fn keys(hm: HashMap<Hashable, any>): Array<Hashable> = map(hm.keyVal, fn (kv: KeyVal<Hashable, any>): Hashable = kv.key);
export fn vals(hm: HashMap<Hashable, any>): Array<any> = map(hm.keyVal, fn (kv: KeyVal<Hashable, any>): any = kv.val);
export fn length(hm: HashMap<Hashable, any>): int64 = length(hm.keyVal);

export fn get(hm: HashMap<Hashable, any>, key: Hashable): Result<any> {
  const hash = key.toHash().abs() % length(hm.lookup);
  const list = getR(hm.lookup[hash]);
  const index = list.find(fn (i: int64): Result<int64> {
    const kv = getR(hm.keyVal[i]);
    return eq(kv.key, key);
  });
  if index.isOk() {
    const i = index.getOr(0);
    const kv = getR(hm.keyVal[i]);
    return ok(kv.val);
  } else {
    return err('key not found');
  }
}

export fn set(hm: HashMap<Hashable, any>, key: Hashable, val: any): HashMap<Hashable, any> {
  const kv = new KeyVal<Hashable, any> {
    key: key,
    val: val,
  };
  const hash = key.toHash().abs() % length(hm.lookup);
  const list = getR(hm.lookup[hash]);
  if list.length() == 8 {
    // Rebucket everything
    const lookupLen = length(hm.lookup) * 2 || 0;
    hm.lookup = new Array<Array<int64>> [ new Array<int64> [], ] * lookupLen;
    eachl(hm.keyVal, fn (kv: KeyVal<Hashable, any>, i: int64) {
      const hash = toHash(kv.key).abs() % lookupLen;
      const list = getR(hm.lookup[hash]);
      list.push(i);
    });
  } else if list.find(fn (idx: int64): bool {
    const rec = hm.keyVal[idx].getR();
    return eq(rec.key, key);
  }).isOk() {
    list.eachLin(fn (idx: int64, i: int64) {
      const rec = hm.keyVal[idx].getR();
      if eq(rec.key, key) {
        hm.keyVal.set(idx, kv);
      }
    });
  } else {
    const index = length(hm.keyVal);
    push(hm.keyVal, kv);
    list.push(index);
  }
  return hm;
}

export fn newHashMap(firstKey: Hashable, firstVal: any): HashMap<Hashable, any> { // TODO: Rust-like fn::<typeA, typeB> syntax?
  let hm = new HashMap<Hashable, any> {
    keyVal: new Array<KeyVal<Hashable, any>> [],
    lookup: new Array<Array<int64>> [ new Array<int64> [] ] * 128, // 1KB of space
  };
  return hm.set(firstKey, firstVal);
}

export fn toHashMap(kva: Array<KeyVal<Hashable, any>>): HashMap<Hashable, any> {
  let hm = new HashMap<Hashable, any> {
    keyVal: kva,
    lookup: new Array<Array<int64>> [ new Array<int64> [] ] * 128,
  };
  kva.eachl(fn (kv: KeyVal<Hashable, any>, i: int64) {
    const hash = toHash(kv.key).abs() % length(hm.lookup);
    const list = getR(hm.lookup[hash]);
    list.push(i);
  });
  return hm;
}

// Tree implementation

// The Tree type houses all of the values attached to a tree in an array and two secondary arrays to
// hold the metadata on which value is the parent and which are children, if any. The parent value
// is `-1` if it has no parent and a positive integer otherwise.
export type Tree<T> {
  vals: Array<T>,
  parents: Array<int64>,
  children: Array<Array<int64>>,
}

// The Node type simply holds the index to look into the tree for a particular value-parent-children
// triplet, where that index is referred to as a node ID. This allows node-based code to be written
// while not actually having a recursive data structure that a traditional Node type would define.
export type Node<T> {
  id: int64,
  tree: Tree<T>,
}

export fn newTree(rootVal: any): Tree<any> = new Tree<any> {
  vals: new Array<any> [ rootVal ],
  parents: new Array<int64> [ -1 ], // The root node has no parent, so its parent ID is -1.
  children: new Array<Array<int64>> [ new Array<int64> [ ] ],
};

export fn getRootNode(t: Tree<any>): Node<any> {
  if has(t.parents, -1) {
    return new Node<any> {
      id: index(t.parents, -1).getOr(0),
      tree: t,
    };
  } else {
    // Return an invalid node, will behave like an error result
    return new Node<any> {
      id: -1,
      tree: new Tree<any> {
        vals: new Array<any> [],
        parents: new Array<int64> [],
        children: new Array<Array<int64>> [],
      },
    };
  }
}

export fn getTree(n: Node<any>): Tree<any> = n.tree;

export fn length(t: Tree<any>): int64 = length(t.vals);

export fn getNodeById(t: Tree<any>, i: int64): Node<any> {
  if length(t.vals).gt(i) {
    return new Node<any> {
      id: i,
      tree: t,
    };
  } else {
    // Return an invalid node, will behave like an error result
    return new Node<any> {
      id: -1,
      tree: new Tree<any> {
        vals: new Array<any> [],
        parents: new Array<int64> [],
        children: new Array<Array<int64>> [],
      },
    };
  }
}

export fn getParent(n: Node<any>): Node<any> {
  const parentId = getOr(n.tree.parents[n.id], -1);
  if parentId > -1 {
    return new Node<any> {
      id: parentId,
      tree: n.tree,
    };
  } else {
    // Return an invalid node, will behave like an error result
    return new Node<any> {
      id: -1,
      tree: new Tree<any> {
        vals: new Array<any> [],
        parents: new Array<int64> [],
        children: new Array<Array<int64>> [],
      },
    };
  }
}

export fn getChildren(n: Node<any>): Array<Node<any>> {
  if length(n.tree.vals).gt(n.id) {
    const childIds = getOr(n.tree.children[n.id], new Array<int64> []);
    return childIds.filter(fn (id: int64): bool {
      const parentId = getOr(n.tree.parents[id], -1);
      return parentId.eq(n.id);
    }).map(fn (id: int64): Node<any> {
      return new Node<any> {
        id: id,
        tree: n.tree,
      };
    });
  } else {
    return new Array<Node<any>> [ ];
  }
}

// Returns the pruned Tree
export fn prune(n: Node<any>): Tree<any> {
  // adjust parent's children
  const parentRes = n.tree.parents[n.id];
  if parentRes.isOk() {
    const parentId = parentRes.getR();
    const children = getOr(n.tree.children[parentId], new Array<int64> []);
    const idxRes = index(children, n.id);
    if idxRes.isOk() {
      delete(children, idxRes);
    }
  }
  // This is, unfortunately for now, a sequential algorithm. Hope to figure out a parallel version
  let nodeStack = new Array<int64> [ n.id ];
  let rmdIds = new Array<int64> [ ];
  seqdo(newseq(pow(2, 62).getOr(0)), fn (): bool {
    // Get the nodeId, exit if none left
    const nodeRes = nodeStack.pop();
    if nodeRes.isErr() {
      return false;
    }
    const nodeId = nodeRes.getR();
    // Push the children onto the stack to process if the node has them
    const childrenRes = n.tree.children[nodeId];
    if childrenRes.isOk() {
      const childrenIds = childrenRes.getR();
      nodeStack = nodeStack.concat(childrenIds);
    }
    const delIdx = nodeId - length(rmdIds);
    delete(n.tree.vals, delIdx);
    delete(n.tree.parents, delIdx);
    delete(n.tree.children, delIdx);
    push(rmdIds, nodeId);
    return true;
  });

  // adjust indices for remaining elements
  const iters = length(n.tree.parents);
  seqeach(newseq(iters), fn (i: int64) {
    const parentId = getOr(n.tree.parents[i], -1);
    const parentDelta = rmdIds.filter(fn (rmId: int64): bool = parentId > rmId).length();
    if parentDelta > 0 {
      set(n.tree.parents, i, parentId - parentDelta || 0);
    }
    const children = getOr(n.tree.children[i], new Array<int64> []);
    const newChildren = children.map(fn (cId: int64): int64 {
      const delta = rmdIds.filter(fn (rmdId: int64): bool = cId > rmdId).length();
      if delta > 0 {
        return cId - delta || 0;
      }
      return cId;
    });
    set(n.tree.children, i, newChildren);
  });
  return n.tree;
}

// Takes the given node and copies that node and all of its children into a new tree with the
// current node as the root. Unfortunately a sequential algorithm right now.
export fn toSubtree(n: Node<any>): Tree<any> {
  const val = n.tree.vals[n.id].getR();
  let outTree = newTree(val);
  let children = n.tree.children[n.id].getOr(new Array<int64> []);
  if children.length().gt(0) {
    let parentIds = [0].repeat(children.length());
    seqdo(newseq(pow(2, 62).getOr(0)), fn (): bool {
      const childId = children.pop().getOr(-1);
      const parentId = parentIds.pop().getOr(-1);
      const childVal = n.tree.vals[childId].getR();
      const grandchildIds = n.tree.children[childId].getOr(new Array<int64> []);
      const newParentId = outTree.vals.length();
      outTree.vals.push(childVal);
      outTree.parents.push(parentId);
      outTree.children.push(new Array<int64> []);
      children = grandchildIds.concat(children);
      parentIds = [newParentId].repeat(grandchildIds.length()).concat(parentIds);
      return parentIds.length().gt(0);
    });
  }
  return outTree;
}

export fn getChildren(t: Tree<any>): Array<Node<any>> = t.getRootNode().getChildren();

// Attaches the value as a child of the specified node. Returns the new child node added for easier
// method chaining
export fn addChild(n: Node<any>, val: any): Node<any> {
  const childId = n.tree.vals.length();
  n.tree.vals.push(val);
  n.tree.parents.push(n.id);
  n.tree.children.push(new Array<int64> []);
  n.tree.children[n.id].getOr(new Array<int64> []).push(childId);
  return new Node<any> {
    id: childId,
    tree: n.tree,
  };
}

// Attaches the specified Tree to the specified Node. Can be done with simple maps and concats. This
// returns the new child node corresponding to the root node of the tree. When adding a tree, we
// duplicate that tree and attach it to the specified node on the new tree with the parent-child
// relationships "re-stitched" on the node's own tree. This means it is even possible to attach a
// tree to itself without producing loops in the tree structure:
//    A          A
//   / \   =>   / \
//  B   C      B   C
//                 |
//                 A'
//                / \
//               B'  C'
export fn addChild(n: Node<any>, val: Tree<any>): Node<any> {
  const childIdOffset = n.tree.vals.length();
  const newParents = val.parents.map(fn (p: int64): int64 {
    if p == -1 {
      return n.id;
    } else {
      return p.add(childIdOffset).getOr(0);
    }
  });
  const newChildren = val.children.map(fn (ca: Array<int64>): Array<int64> {
    return ca.map(fn (c: int64): int64 = c.add(childIdOffset).getOr(0));
  });
  n.tree.children = n.tree.children.concat(newChildren);
  n.tree.children[n.id].getOr(new Array<int64> []).push(childIdOffset);
  n.tree.vals = n.tree.vals.concat(val.vals);
  n.tree.parents = n.tree.parents.concat(newParents);
  return new Node<any> {
    id: childIdOffset,
    tree: n.tree,
  };
}

// Attaches the specified Node and its children to the specified Node. This returns the new child
// node corresponding to the attached node
export fn addChild(n: Node<any>, val: Node<any>): Node<any> = n.addChild(val.toSubtree());

// Attaches the specified value to the specified Tree, by referencing a Tree directly, attaches to
// the root node, and returns the new child node
export fn addChild(t: Tree<any>, val: any): Node<any> = t.getRootNode().addChild(val);

// Attaches the specified Node and its children to the specified Tree's root node
export fn addChild(t: Tree<any>, val: Node<any>): Node<any> = t.getRootNode().addChild(val.toSubtree());

// Attahces one tree to the root node of another tree. Returns the node of the attached tree's root
export fn addChild(t: Tree<any>, val: Tree<any>): Node<any> = t.getRootNode().addChild(val);

export fn getOr(n: Node<any>, default: any): any = getOr(n.tree.vals[n.id], default);

export fn toNodeArray(t: Tree<any>): Array<Node<any>> = map(
  t.vals,
  fn (val: any, i: int64): Node<any> = t.getNodeById(i)
);

export fn map(t: Tree<any>, mapper: function): Tree<anythingElse> {
  return new Tree<anythingElse> {
    vals: t.toNodeArray().map(mapper),
    parents: clone(t.parents),
    children: clone(t.children),
  };
}

export fn some(t: Tree<any>, mapper: function): bool = t.toNodeArray().some(mapper);

export fn every(t: Tree<any>, mapper: function): bool = t.toNodeArray().every(mapper);

export fn reduce(t: Tree<any>, cb: function, initial: anythingElse): bool = t
  .toNodeArray()
  .reduce(cb, initial);

export fn find(t: Tree<any>, mapper: function): Node<any> {
  // Return an invalid node, will behave like an error result
  return t.toNodeArray().find(mapper).getOr(
    new Node<any> {
      id: -1,
      tree: new Tree<any> {
        vals: new Array<any> [],
        parents: new Array<int64> [],
        children: new Array<Array<int64>> [],
      },
    }
  );
}

// Operator declarations
export infix add as + precedence 2
export infix concat as + precedence 2
export infix sub as - precedence 2
export prefix negate as - precedence 1
export infix mul as * precedence 3
export infix repeat as * precedence 3
export infix div as / precedence 3
export infix split as / precedence 3
export infix mod as % precedence 3
// export infix template as % precedence 3
export infix pow as ** precedence 4
export infix sadd as +. precedence 2
export infix ssub as -. precedence 2
export infix smul as *. precedence 3
export infix sdiv as /. precedence 3
export infix spow as **. precedence 4
export infix and as & precedence 3
export infix and as && precedence 3
export infix or as | precedence 2
export infix boolor as || precedence 2
export infix xor as ^ precedence 2
export prefix not as ! precedence 4
export infix nand as !& precedence 3
export infix nor as !| precedence 2
export infix xnor as !^ precedence 2
export infix eq as == precedence 1
export infix neq as != precedence 1
export infix lt as < precedence 1
export infix lte as <= precedence 1
export infix gt as > precedence 1
export infix gte as >= precedence 1
export infix matches as ~ precedence 1
export infix index as @ precedence 1
export prefix length as # precedence 4
export prefix trim as ` precedence 4
export infix pair as : precedence 5
export infix push as : precedence 6
export infix cond as ? precedence 0
export infix getOr as || precedence 2
